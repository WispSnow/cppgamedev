# 读取/保存配置文件

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1VzKfzpEFY&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1VzKfzpEFY)

## 📌 问题背景

随着引擎功能的逐渐丰富，一个问题也日益凸显：我们的许多核心参数，如窗口大小、标题、目标帧率等，都是直接写在代码里的 **"魔法数字"（Magic Numbers）**。这种硬编码的方式极大地降低了灵活性。如果我们想改变窗口大小，就必须修改代码并重新编译。

为了解决这个问题，本节课我们将引入一个配置管理系统。我们将创建一个 `Config` 类，负责从一个外部的 `config.json` 文件中读取所有设置。这不仅让调整参数变得轻而易举，也为未来让玩家自定义游戏设置（如画质、音量、键位）打下了基础。

<img src="https://theorhythm.top/gamedev/SL/SL.032.webp" alt="配置管理类" style="display: block; margin: auto; width: 700px;" />

---

## 1. config.json：引擎的"大脑"

首先，我们在 `assets` 目录下创建一个名为 `config.json` 的新文件。这个文件将成为我们引擎所有可配置选项的中央存储库。

```json
{
    "window": {
        "title": "SunnyLand",
        "width": 1280,
        "height": 720,
        "resizable": true
    },
    "graphics": {
        "vsync": true
    },
    "performance": {
        "target_fps": 144
    },
    "audio": {
        "music_volume": 0.5,
        "sound_volume": 0.5
    },
    "input_mappings": {
        "pause": [ "P", "Escape" ],
        "move_down": [ "S", "Down" ],
        "jump": [ "J", "Space" ],
        "move_up": [ "W", "Up" ],
        "move_right": [ "D", "Right" ],
        "attack": [ "K", "MouseLeft" ],
        "move_left": [ "A", "Left" ]
    }
}
```

### 配置文件包含的内容

如你所见，我们把以下配置都定义在了这里：

- **窗口设置**：标题、尺寸、是否可调整大小
- **图形选项**：垂直同步（VSync）
- **性能目标**：目标帧率
- **音频设置**：音乐音量、音效音量
- **输入映射**：未来的按键绑定配置

---

## 2. Config 类：配置的管理者

接下来，我们将在 `engine/core` 目录下创建一个新的 `Config` 类。它的职责很简单：

### 核心功能

- ✅ 在程序启动时，加载 `config.json` 文件
- ✅ 将 JSON 中的数据解析并存储到类的成员变量中
- ✅ 提供一个 `saveToFile` 方法，以便在需要时（比如玩家修改了设置）将当前配置写回文件

### 健壮性设计

> 💡 如果 `config.json` 文件不存在，它会自动用默认值创建一个。如果文件内容损坏或缺少某些字段，它会使用预设的默认值，保证程序不会因此崩溃。

### config.h

```cpp
#pragma once
#include <string>
#include <vector>
#include <unordered_map>
#include <nlohmann/json_fwd.hpp>    // nlohmann_json 提供的前向声明

namespace engine::core {

/**
 * @brief 管理应用程序的配置设置。
 *
 * 提供配置项的默认值，并支持从 JSON 文件加载/保存配置。
 * 如果加载失败或文件不存在，将使用默认值。
 */
class Config final {
public:
    // --- 默认配置值 --- (为了方便拓展，全部设置为公有)
    // 窗口设置
    std::string window_title_ = "SunnyLand";
    int window_width_ = 1280;
    int window_height_ = 720;
    bool window_resizable_ = true;

    // 图形设置
    bool vsync_enabled_ = true;             ///< @brief 是否启用垂直同步

    // 性能设置
    int target_fps_ = 144;                  ///< @brief 目标 FPS 设置，0 表示不限制

    // 音频设置
    float music_volume_ = 0.5f;
    float sound_volume_ = 0.5f;

    // 存储动作名称到 SDL Scancode 名称列表的映射
    std::unordered_map<std::string, std::vector<std::string>> input_mappings_ = {
        // 提供一些合理的默认值，以防配置文件加载失败或缺少此部分
        {"move_left", {"A", "Left"}},
        {"move_right", {"D", "Right"}},
        {"move_up", {"W", "Up"}},
        {"move_down", {"S", "Down"}},
        {"jump", {"J", "Space"}},
        {"attack", {"K", "MouseLeft"}},
        {"pause", {"P", "Escape"}},
        // 可以继续添加更多默认动作
    };

    explicit Config(const std::string& filepath);                     ///< @brief 构造函数，指定配置文件路径。

    // 删除拷贝和移动语义
    Config(const Config&) = delete;
    Config& operator=(const Config&) = delete;
    Config(Config&&) = delete;
    Config& operator=(Config&&) = delete;

    bool loadFromFile(const std::string& filepath);                   ///< @brief 从指定的 JSON 文件加载配置。成功返回 true，否则返回 false。
    [[nodiscard]] bool saveToFile(const std::string& filepath);       ///< @brief 将当前配置保存到指定的 JSON 文件。成功返回 true，否则返回 false。

private:
    void fromJson(const nlohmann::json& j);                           ///< @brief 从 JSON 对象反序列化配置。
    nlohmann::ordered_json toJson() const;                            ///< @brief 将当前配置转换为 JSON 对象（按顺序）。
};

} // namespace engine::core
```

`Config` 类的头文件定义了所有可配置的选项作为公有成员变量，并赋予它们默认值。这样做的好处是，引擎的其他部分可以非常直观地通过 `config->window_width_` 这样的方式来访问配置项。

### config.cpp

```cpp
#include "config.h"
#include <fstream>
#include <nlohmann/json.hpp>
#include "spdlog/spdlog.h"

namespace engine::core {

Config::Config(const std::string &filepath)
{
    loadFromFile(filepath);
}

bool Config::loadFromFile(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        spdlog::warn("配置文件 '{}' 未找到。使用默认设置并创建默认配置文件。", filepath);
        if (!saveToFile(filepath)) {
            spdlog::error("无法创建默认配置文件 '{}'。", filepath);
            return false;
        }
        return false; // 文件不存在，使用默认值
    }

    try {
        nlohmann::json j;
        file >> j;
        fromJson(j);
        spdlog::info("成功从 '{}' 加载配置。", filepath);
        return true;
    } catch (const std::exception& e) {
        spdlog::error("读取配置文件 '{}' 时出错：{}。使用默认设置。", filepath, e.what());
    }
    return false;
}

bool Config::saveToFile(const std::string& filepath) {
    std::ofstream file(filepath);
    if (!file.is_open()) {
        spdlog::error("无法打开配置文件 '{}' 进行写入。", filepath);
        return false;
    }

    try {
        nlohmann::ordered_json j = toJson();
        file << j.dump(4);
        spdlog::info("成功将配置保存到 '{}'。", filepath);
        return true;
    } catch (const std::exception& e) {
        spdlog::error("写入配置文件 '{}' 时出错：{}", filepath, e.what());
    }
    return false;
}

void Config::fromJson(const nlohmann::json& j) {
    if (j.contains("window")) {
        const auto& window_config = j["window"];
        window_title_ = window_config.value("title", window_title_);
        window_width_ = window_config.value("width", window_width_);
        window_height_ = window_config.value("height", window_height_);
        window_resizable_ = window_config.value("resizable", window_resizable_);
    }
    if (j.contains("graphics")) {
        const auto& graphics_config = j["graphics"];
        vsync_enabled_ = graphics_config.value("vsync", vsync_enabled_);
    }
    if (j.contains("performance")) {
        const auto& perf_config = j["performance"];
        target_fps_ = perf_config.value("target_fps", target_fps_);
        if (target_fps_ < 0) {
            spdlog::warn("目标 FPS 不能为负数。设置为 0（无限制）。");
            target_fps_ = 0;
        }
    }
    if (j.contains("audio")) {
        const auto& audio_config = j["audio"];
        music_volume_ = audio_config.value("music_volume", music_volume_);
        sound_volume_ = audio_config.value("sound_volume", sound_volume_);
    }

    // 从 JSON 加载 input_mappings
    if (j.contains("input_mappings") && j["input_mappings"].is_object()) {
        const auto& mappings_json = j["input_mappings"];
        try {
            // 直接尝试从 JSON 对象转换为 map<string, vector<string>>
            auto input_mappings = mappings_json.get<std::unordered_map<std::string, std::vector<std::string>>>();
            // 如果成功，则将 input_mappings 移动到 input_mappings_
            input_mappings_ = std::move(input_mappings);
            spdlog::trace("成功从配置加载输入映射。");
        } catch (const std::exception& e) {
            spdlog::warn("配置加载警告：解析 'input_mappings' 时发生异常。使用默认映射。错误：{}", e.what());
        }
    } else {
        spdlog::trace("配置跟踪：未找到 'input_mappings' 部分或不是对象。使用头文件中定义的默认映射。");
    }
}

nlohmann::ordered_json Config::toJson() const {
    return nlohmann::ordered_json{
        {"window", {
            {"title", window_title_},
            {"width", window_width_},
            {"height", window_height_},
            {"resizable", window_resizable_}
        }},
        {"graphics", {
            {"vsync", vsync_enabled_}
        }},
        {"performance", {
            {"target_fps", target_fps_}
        }},
        {"audio", {
            {"music_volume", music_volume_},
            {"sound_volume", sound_volume_}
        }},
        {"input_mappings", input_mappings_}
    };
}

} // namespace engine::core 
```

实现文件中，我们充分利用了第二课学习的 `nlohmann/json` 库。

#### 关键方法说明

| 方法 | 功能描述 |
|------|----------|
| `loadFromFile()` | 尝试打开并解析 JSON 文件。如果文件打不开，它会调用 `saveToFile()` 来生成一个包含默认设置的新配置文件 |
| `saveToFile()` | 调用 `toJson()` 将当前对象的状态序列化，然后写入文件 |
| `fromJson()` | 核心的解析逻辑。它使用 `.value("key", default_value)` 这种安全的方式从 JSON 对象中提取数据。即使 JSON 文件中缺少某个字段，程序也能平稳地使用 `default_value`（即成员变量的初始值） |
| `toJson()` | 将所有成员变量打包成一个 `nlohmann::ordered_json` 对象，以便能以固定的顺序写入文件，增加可读性 |

---

## 3. 集成到 GameApp

最后一步是将新的 `Config` 模块无缝集成到我们的主应用 `GameApp` 中。

### 新的初始化流程

```cpp
// game_app.h

class Config;

class GameApp final {   // final 表示该类不能被继承
private:
    // ...
    std::unique_ptr<engine::core::Config> config_;
    // ...
private:
    // ...
    // 各模块的初始化/创建函数，在init()中调用
    [[nodiscard]] bool initConfig();
    // ...
};
```

我们在 `GameApp` 中添加了一个 `initConfig()` 方法，并确保它在 `init()` 函数中 **最先被调用**。因为后续所有的初始化步骤（如创建窗口、设置帧率）都依赖于从配置文件中读取的数据。

### 移除硬编码
```cpp
// game_app.cpp

bool GameApp::init() {
    spdlog::trace("初始化 GameApp ...");
    if (!initConfig()) return false;
    // ...
}

bool GameApp::initConfig()
{
    try {
        config_ = std::make_unique<engine::core::Config>("assets/config.json");
    } catch (const std::exception& e) {
        spdlog::error("初始化配置失败: {}", e.what());
        return false;
    }
    spdlog::trace("配置初始化成功。");
    return true;
}
// ...
bool GameApp::initSDL()
{
    // ...
    window_ = SDL_CreateWindow(config_->window_title_.c_str(), config_->window_width_, config_->window_height_, SDL_WINDOW_RESIZABLE);
    // ...
    // 设置 VSync (注意: VSync 开启时，驱动程序会尝试将帧率限制到显示器刷新率，有可能会覆盖我们手动设置的 target_fps)
    int vsync_mode = config_->vsync_enabled_ ? SDL_RENDERER_VSYNC_ADAPTIVE : SDL_RENDERER_VSYNC_DISABLED;
    SDL_SetRenderVSync(sdl_renderer_, vsync_mode);
    spdlog::trace("VSync 设置为: {}", config_->vsync_enabled_ ? "Enabled" : "Disabled");

    // 设置逻辑分辨率为窗口大小的一半（针对像素游戏）
    SDL_SetRenderLogicalPresentation(sdl_renderer_, config_->window_width_ / 2, config_->window_height_ / 2, SDL_LOGICAL_PRESENTATION_LETTERBOX);
    spdlog::trace("SDL 初始化成功。");
    return true;
}

bool GameApp::initTime() {
    // ...
    time_->setTargetFps(config_->target_fps_);
    // ...
}

bool GameApp::initCamera() {
    try {
        camera_ = std::make_unique<engine::render::Camera>(glm::vec2(config_->window_width_ / 2, config_->window_height_ / 2));
    } catch (const std::exception& e) {
        // ...
    }
    // ...
}
```

我们仔细检查了 `GameApp` 的代码，并将所有之前硬编码的值替换为从 `config_` 对象中获取的动态值：

- ✨ `SDL_CreateWindow` 的参数现在来自 `config_->window_title_`, `config_->window_width_` 等
- ✨ 垂直同步的开关由 `config_->vsync_enabled_` 控制
- ✨ `time_->setTargetFps()` 的目标值来自 `config_->target_fps_`
- ✨ 我们的逻辑分辨率和相机视口大小现在也动态地设置为窗口尺寸的一半，以更好地适应不同的分辨率

---

## 4. 编译与测试

### 准备工作

在编译前，请确保 `config.cpp` 已经添加到了 `CMakeLists.txt` 中。

### 测试步骤

现在，编译并运行项目。游戏窗口应该会根据 `config.json` 中的设置来创建。接下来，尝试做几个实验：

#### 🧪 实验 1：修改配置

1. 关闭游戏
2. 打开 `assets/config.json` 文件
3. 将 `title` 改为 `"我的阳光岛"`，将 `target_fps` 改为 `60`
4. 保存文件后重新运行游戏
5. 观察窗口标题和（通过日志观察的）帧率是否发生了变化

#### 🧪 实验 2：自动生成配置

1. 关闭游戏
2. 删除 `assets/config.json` 文件
3. 重新运行游戏
4. 你会发现程序不仅没有报错，还在 `assets` 目录下自动生成了一个包含默认设置的 `config.json` 文件

---

## 🎯 总结

通过本节课的改造，我们的引擎在灵活性和健壮性上迈出了一大步。我们不再受制于写死在代码里的参数，为未来的功能拓展（如图形设置菜单、按键绑定界面）铺平了道路。

**关键要点：**
- 📁 配置文件集中管理所有可配置参数
- 🛡️ 健壮的错误处理机制
- 🔄 支持运行时读取和保存配置
- 🚀 为未来功能扩展打下基础
