# ç¢°æ’å™¨ç»„ä»¶ä¸ç¢°æ’æ£€æµ‹

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- Bç«™åµŒå…¥ï¼šä½¿ç”¨ https æ˜ç¡®åè®®ï¼ˆé¿å… file:// æˆ– http å¯¼è‡´è¢«æµè§ˆå™¨æ‹¦æˆªï¼‰ -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1fsuFzBEd7&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[åœ¨ Bilibili ä¸Šè§‚çœ‹](https://www.bilibili.com/video/BV1fsuFzBEd7)

## ğŸ“Œ é—®é¢˜èƒŒæ™¯

åœ¨ä¸Šä¸€è¯¾ä¸­ï¼Œæˆ‘ä»¬æˆåŠŸåœ°ä¸ºæ¸¸æˆå¯¹è±¡å¼•å…¥äº†åŸºæœ¬çš„ç‰©ç†è¿åŠ¨ã€‚ç„¶è€Œï¼Œè¿™äº›ç‰©ä½“ç›®å‰è¿˜ç”Ÿæ´»åœ¨ä¸€ä¸ª **"å¹½çµä¸–ç•Œ"** é‡Œï¼Œå¯ä»¥æ¯«æ— é˜»ç¢åœ°ç›¸äº’ç©¿é€ã€‚ä¸ºäº†å»ºç«‹ä¸€ä¸ªæœ‰ç§©åºçš„ç‰©ç†ä¸–ç•Œï¼Œæˆ‘ä»¬å¿…é¡»æ•™ä¼šå¼•æ“å¦‚ä½• **æ£€æµ‹ç¢°æ’**ã€‚

### âš ï¸ å½“å‰çš„é—®é¢˜

```
å¹½çµä¸–ç•Œï¼ˆå½“å‰çŠ¶æ€ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“¦                 â”‚
â”‚   â†“ ä¸‹è½             â”‚
â”‚    â†“                â”‚
â”‚  â”â”â”â”â”â”â”â”â”           â”‚
â”‚    â†“ ç©¿é€åœ°é¢ï¼      â”‚
â”‚     ğŸ“¦              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ¯ æœ¬è¯¾ç›®æ ‡

æœ¬èŠ‚è¯¾çš„ç›®æ ‡ **ä¸æ˜¯** å®ç°ç¢°æ’åçš„ç‰©ç†ååº”ï¼ˆå³ç¢°æ’è§£æï¼Œé‚£æ˜¯ä¸‹ä¸€è¯¾çš„å†…å®¹ï¼‰ï¼Œè€Œæ˜¯æ„å»ºä¸€ä¸ªèƒ½å¤Ÿå‡†ç¡®åˆ¤æ–­ **"å“ªä¸¤ä¸ªç‰©ä½“åœ¨å½“å‰å¸§å‘ç”Ÿäº†é‡å "** çš„ç³»ç»Ÿã€‚

æˆ‘ä»¬å°†é€šè¿‡åˆ›å»ºä¸€ç³»åˆ—æ–°çš„ç»„ä»¶å’Œç±»æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼š

<img src="https://theorhythm.top/gamedev/SL/SL.058.webp" alt="ç¢°æ’å™¨ä¸æ£€æµ‹" style="display: block; margin: auto; width: 700px;" />

| æ¨¡å— | èŒè´£ |
|------|------|
| **Collider** | å®šä¹‰ç¢°æ’å½¢çŠ¶ï¼ˆçŸ©å½¢ã€åœ†å½¢ï¼‰ |
| **ColliderComponent** | å°†ç¢°æ’å™¨é™„åŠ åˆ° GameObject |
| **collision å‘½åç©ºé—´** | æä¾›ç¢°æ’æ£€æµ‹ç®—æ³• |
| **PhysicsEngine** | åœ¨æ¯å¸§æ£€æµ‹æ‰€æœ‰ç¢°æ’å¯¹ |

---

## 1. ç¢°æ’å½¢çŠ¶ï¼ˆColliderï¼‰

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ç”¨æ•°å­¦æ–¹å¼æ¥æè¿°ä¸€ä¸ªç‰©ä½“çš„ **ç‰©ç†è¾¹ç•Œ**ã€‚åœ¨ 2D æ¸¸æˆä¸­ï¼Œæœ€å¸¸ç”¨çš„ç¢°æ’å½¢çŠ¶æ˜¯ **çŸ©å½¢ï¼ˆAABBï¼‰** å’Œ **åœ†å½¢ï¼ˆCircleï¼‰**ã€‚

### ç¢°æ’å½¢çŠ¶ç±»å‹

| å½¢çŠ¶ | å…¨ç§° | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| **AABB** | Axis-Aligned Bounding Box | è½´å¯¹é½ï¼Œè®¡ç®—å¿«é€Ÿ | ç®±å­ã€å¹³å°ã€å»ºç­‘ |
| **Circle** | Circle Collider | ç²¾ç¡®çš„åœ†å½¢æ£€æµ‹ | çƒã€ç¡¬å¸ã€å¼¹ä¸¸ |

æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª `Collider` åŸºç±»å’Œå‡ ä¸ªæ´¾ç”Ÿç±»æ¥ä»£è¡¨è¿™äº›å½¢çŠ¶ã€‚

---

### engine/physics/collider.hï¼ˆæ–°å»ºï¼‰

```cpp
#pragma once
#include <glm/vec2.hpp>
#include <utility>

namespace engine::physics {

/**
 * @brief å®šä¹‰ä¸åŒç±»å‹çš„ç¢°æ’å™¨ã€‚
 */
enum class ColliderType {
    NONE,
    AABB,
    CIRCLE,
    // æœªæ¥å¯èƒ½æ·»åŠ å…¶ä»–ç±»å‹ï¼Œå¦‚ Capsule, Polygon ç­‰
};

/**
 * @brief ç¢°æ’å™¨çš„æŠ½è±¡åŸºç±»ã€‚
 * æ‰€æœ‰å…·ä½“çš„ç¢°æ’å™¨éƒ½åº”ç»§æ‰¿æ­¤ç±»ã€‚
 */
class Collider {
protected:
    glm::vec2 aabb_size_ = {0.0f, 0.0f};    ///< @brief è¦†ç›–Colliderçš„æœ€å°åŒ…å›´ç›’çš„å°ºå¯¸ï¼ˆå®½åº¦å’Œé«˜åº¦ï¼‰ã€‚

public:
    virtual ~Collider() = default;
    virtual ColliderType getType() const = 0;   ///< @brief è·å–ç¢°æ’å™¨çš„ç±»å‹ã€‚

    void setAABBSize(glm::vec2 size) { aabb_size_ = std::move(size); }  ///< @brief è®¾ç½®æœ€å°åŒ…å›´ç›’çš„å°ºå¯¸ï¼ˆå®½åº¦å’Œé«˜åº¦ï¼‰ã€‚
    const glm::vec2& getAABBSize() const { return aabb_size_; }     ///< @brief è·å–æœ€å°åŒ…å›´ç›’çš„å°ºå¯¸ï¼ˆå®½åº¦å’Œé«˜åº¦ï¼‰ã€‚
};

/**
 * @brief è½´å¯¹é½åŒ…å›´ç›’ (Axis-Aligned Bounding Box) ç¢°æ’å™¨ã€‚
 */
class AABBCollider final : public Collider {
private:
    glm::vec2 size_ = {0.0f, 0.0f};  ///< @brief åŒ…å›´ç›’çš„å°ºå¯¸ï¼ˆå’Œaabb_size_ç›¸åŒï¼‰ã€‚

public:
    /**
     * @brief æ„é€ å‡½æ•°ã€‚
     * @param size åŒ…å›´ç›’çš„å®½åº¦å’Œé«˜åº¦ã€‚
     */
    explicit AABBCollider(glm::vec2 size) : size_(std::move(size)) { setAABBSize(size_); }
    ~AABBCollider() override = default;

    // --- Getters and Setters ---
    ColliderType getType() const override { return ColliderType::AABB; }
    const glm::vec2& getSize() const { return size_; }
    void setSize(glm::vec2 size) { size_ = std::move(size); }
};

/**
 * @brief åœ†å½¢ç¢°æ’å™¨ã€‚
 */
class CircleCollider final : public Collider {
private:
    float radius_ = 0.0f;  ///< @brief åœ†çš„åŠå¾„ã€‚

public:
    /**
     * @brief æ„é€ å‡½æ•°ã€‚
     * @param radius åœ†çš„åŠå¾„ã€‚
     */
    explicit CircleCollider(float radius) : radius_(radius) { setAABBSize(glm::vec2(radius * 2.0f, radius * 2.0f)); }
    ~CircleCollider() override = default;

    // --- Getters and Setters ---
    ColliderType getType() const override { return ColliderType::CIRCLE; }
    float getRadius() const { return radius_; }
    void setRadius(float radius) { radius_ = radius; }
};

} // namespace engine::physics
```

### è®¾è®¡è¦ç‚¹

| è¦ç‚¹ | è¯´æ˜ |
|------|------|
| **æŠ½è±¡åŸºç±»** | `Collider` æ˜¯æŠ½è±¡åŸºç±»ï¼Œå®šä¹‰äº†æ‰€æœ‰ç¢°æ’å™¨å…±æœ‰çš„æ¥å£ï¼Œå¦‚ `getType()` |
| **AABB å°ºå¯¸** | å®ƒè¿˜åŒ…å«ä¸€ä¸ª `aabb_size_`ï¼Œä»£è¡¨èƒ½å®Œå…¨åŒ…å›´è¿™ä¸ªç¢°æ’å™¨çš„æœ€å°çŸ©å½¢å°ºå¯¸ï¼Œè¿™åœ¨åç»­çš„ä¼˜åŒ–ä¸­éå¸¸æœ‰ç”¨ |
| **å…·ä½“å®ç°** | `AABBCollider` å’Œ `CircleCollider` æ˜¯å…·ä½“çš„ç¢°æ’å½¢çŠ¶å®ç° |

### ğŸ’¡ ä¸ºä»€ä¹ˆåœ†å½¢ä¹Ÿéœ€è¦ AABBï¼Ÿ

```
åœ†å½¢ç¢°æ’å™¨çš„ AABBï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â•±â”€â”€â”€â•²   â”‚ â† AABB (å®½åº¦ = åŠå¾„Ã—2)
â”‚  â•±     â•²  â”‚
â”‚ â”‚   â—   â”‚ â”‚ â† åœ†å¿ƒ
â”‚  â•²     â•±  â”‚
â”‚   â•²â”€â”€â”€â•±   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åŸå› **ï¼šå¯ä»¥å…ˆç”¨å¿«é€Ÿçš„ AABB æ£€æµ‹è¿‡æ»¤å¤§éƒ¨åˆ†ä¸ç¢°æ’çš„æƒ…å†µï¼Œåªå¯¹ AABB é‡å çš„æƒ…å†µå†è¿›è¡Œç²¾ç¡®çš„åœ†å½¢æ£€æµ‹ã€‚

---

## 2. ColliderComponentï¼šä¸º GameObject æ·»åŠ ç¢°æ’ä½“

å’Œ `PhysicsComponent` ç±»ä¼¼ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ª `ColliderComponent` æ¥å°†ä¸€ä¸ª `Collider` å½¢çŠ¶é™„åŠ åˆ° `GameObject` ä¸Šã€‚

### æ ¸å¿ƒåŠŸèƒ½

| åŠŸèƒ½ | è¯´æ˜ |
|------|------|
| **æŒæœ‰ Collider** | é€šè¿‡ `std::unique_ptr` ç®¡ç† Collider çš„ç”Ÿå‘½å‘¨æœŸ |
| **å¯¹é½æ–¹å¼** | é€šè¿‡ `offset_` å’Œ `alignment_` ç¡®å®šç¢°æ’ä½“ç›¸å¯¹äº Transform çš„ä½ç½® |
| **ä¸–ç•Œåæ ‡è½¬æ¢** | æä¾› `getWorldAABB()` æ–¹æ³•ï¼Œè®¡ç®—ç¢°æ’ä½“åœ¨ä¸–ç•Œåæ ‡ç³»ä¸­çš„ç²¾ç¡®åŒ…å›´ç›’ |
| **è§¦å‘å™¨æ”¯æŒ** | æ”¯æŒ `is_trigger_` æ ‡å¿—ï¼Œç”¨äºä¸äº§ç”Ÿç‰©ç†å“åº”çš„åŒºåŸŸ |

---

### engine/component/collider_component.hï¼ˆæ–°å»ºï¼‰

```cpp
#pragma once
#include "./component.h"
#include "../physics/collider.h"
#include "../utils/math.h"
#include "../utils/alignment.h"
#include <memory>

// å‰ç½®å£°æ˜
namespace engine::component {
    class TransformComponent;
}

namespace engine::component {

/**
 * @brief ç¢°æ’å™¨ç»„ä»¶ã€‚
 *
 * æŒæœ‰ Collider å¯¹è±¡ï¼ˆå¦‚ AABBColliderï¼‰å¹¶æä¾›è·å–ä¸–ç•Œåæ ‡ç³»ä¸‹ç¢°æ’å½¢çŠ¶çš„æ–¹æ³•ã€‚
 */
class ColliderComponent final : public Component {
    friend class engine::object::GameObject;
private:
    TransformComponent* transform_ = nullptr;               ///< @brief ç¼“å­˜çš„ TransformComponent æŒ‡é’ˆ (éæ‹¥æœ‰)

    std::unique_ptr<engine::physics::Collider> collider_;   ///< @brief æ‹¥æœ‰çš„ç¢°æ’å™¨å¯¹è±¡ã€‚
    glm::vec2 offset_ = {0.0f, 0.0f};                       ///< @brief ç¢°æ’å™¨(æœ€å°åŒ…å›´ç›’çš„)å·¦ä¸Šè§’ç›¸å¯¹äºå˜æ¢åŸç‚¹çš„åç§»é‡ã€‚
    engine::utils::Alignment alignment_ = engine::utils::Alignment::NONE;   ///< @brief å¯¹é½æ–¹å¼ã€‚

    bool is_trigger_ = false;                               ///< @brief æ˜¯å¦ä¸ºè§¦å‘å™¨ (ä»…æ£€æµ‹ç¢°æ’ï¼Œä¸äº§ç”Ÿç‰©ç†å“åº”)
    bool is_active_ = true;                                 ///< @brief æ˜¯å¦æ¿€æ´»

public:
    /**
     * @brief æ„é€ å‡½æ•°ã€‚
     * @param collider æŒ‡å‘ Collider å®ä¾‹çš„ unique_ptrï¼Œæ‰€æœ‰æƒå°†è¢«è½¬ç§»ã€‚
     * @param alignment åˆå§‹çš„å¯¹é½é”šç‚¹ã€‚
     * @param is_trigger æ­¤ç¢°æ’å™¨æ˜¯å¦ä¸ºè§¦å‘å™¨ã€‚
     * @param is_active æ­¤ç¢°æ’å™¨æ˜¯å¦æ¿€æ´»ã€‚
     */
    explicit ColliderComponent(
        std::unique_ptr<engine::physics::Collider> collider,
        engine::utils::Alignment alignment = engine::utils::Alignment::NONE,
        bool is_trigger = false,
        bool is_active = true
    );

    /**
     * @brief æ ¹æ®å½“å‰çš„ alignment_anchor_ å’Œ collider_ å°ºå¯¸è®¡ç®— offset_ã€‚
     * @note éœ€è¦ç”¨åˆ°TransformComponentçš„scaleï¼Œå› æ­¤TransformComponentæ›´æ–°scaleæ—¶ï¼Œä¹Ÿè¦è°ƒç”¨æ­¤æ–¹æ³•ã€‚
     */
    void updateOffset(); 

    // --- Getters ---
    const TransformComponent* getTransform() const { return transform_; }               ///< @brief è·å–ç¼“å­˜çš„TransformComponent
    const engine::physics::Collider* getCollider() const { return collider_.get(); }    ///< @brief è·å– Collider å¯¹è±¡ã€‚
    const glm::vec2& getOffset() const { return offset_; }                              ///< @brief è·å–å½“å‰è®¡ç®—å‡ºçš„åç§»é‡ã€‚
    engine::utils::Alignment getAlignment() const { return alignment_; }                ///< @brief è·å–è®¾ç½®çš„å¯¹é½é”šç‚¹ã€‚
    engine::utils::Rect getWorldAABB() const;           ///< @brief è·å–ä¸–ç•Œåæ ‡ç³»ä¸‹çš„æœ€å°è½´å¯¹é½åŒ…å›´ç›’ï¼ˆAABBï¼‰ã€‚
    bool isTrigger() const { return is_trigger_; }      ///< @brief æ£€æŸ¥æ­¤ç¢°æ’å™¨æ˜¯å¦ä¸ºè§¦å‘å™¨ã€‚
    bool isActive() const { return is_active_; }        ///< @brief æ£€æŸ¥æ­¤ç¢°æ’å™¨æ˜¯å¦æ¿€æ´»ã€‚

    void setAlignment(engine::utils::Alignment anchor);             ///< @brief è®¾ç½®æ–°çš„å¯¹é½æ–¹å¼å¹¶é‡æ–°è®¡ç®—åç§»é‡ã€‚
    void setOffset(const glm::vec2& offset) { offset_ = offset; }   ///< @brief è®¾ç½®åç§»é‡ã€‚
    void setTrigger(bool is_trigger) { is_trigger_ = is_trigger; }  ///< @brief è®¾ç½®æ­¤ç¢°æ’å™¨æ˜¯å¦ä¸ºè§¦å‘å™¨ã€‚
    void setActive(bool is_active) { is_active_ = is_active; }      ///< @brief è®¾ç½®æ­¤ç¢°æ’å™¨æ˜¯å¦æ¿€æ´»ã€‚

private:
    // æ ¸å¿ƒå¾ªç¯æ–¹æ³•
    void init() override;
    void update(float, engine::core::Context&) override {}
};

} // namespace engine::component
```

### engine/component/collider_component.cppï¼ˆæ–°å»ºï¼‰

```cpp
#include "collider_component.h"
#include "transform_component.h"
#include "../object/game_object.h"
#include "../physics/collider.h"
#include <spdlog/spdlog.h>

namespace engine::component {

ColliderComponent::ColliderComponent(
    std::unique_ptr<engine::physics::Collider> collider,
    engine::utils::Alignment alignment,
    bool is_trigger,
    bool is_active)
    : collider_(std::move(collider)),
      alignment_(alignment),
      is_trigger_(is_trigger),
      is_active_(is_active)
{
    if (!collider_) {
        spdlog::error("åˆ›å»º ColliderComponent æ—¶ä¼ å…¥äº†ç©ºçš„ç¢°æ’å™¨ï¼");
    }
}

void ColliderComponent::init() {
    if (!owner_) {
        spdlog::error("ColliderComponent æ²¡æœ‰æ‰€æœ‰è€… GameObjectï¼");
        return;
    }
    transform_ = owner_->getComponent<TransformComponent>();
    if (!transform_) {
        spdlog::error("ColliderComponent éœ€è¦ä¸€ä¸ªåœ¨åŒä¸€ä¸ª GameObject ä¸Šçš„ TransformComponentï¼");
        return;
    }

    // åœ¨è·å– transform_ ä¹‹åè®¡ç®—åˆå§‹åç§»é‡
    updateOffset();
}

// å®ç° setAlignment æ–¹æ³•
void ColliderComponent::setAlignment(engine::utils::Alignment anchor) {
    alignment_ = anchor;
    // é‡æ–°è®¡ç®—åç§»é‡ï¼Œç¡®ä¿ transform_ å’Œ collider_ æœ‰æ•ˆ
    if (transform_ && collider_) {
        updateOffset();
    }
}

void ColliderComponent::updateOffset() {
    if (!collider_) return;

    // è·å–ç¢°æ’ç›’çš„æœ€å°åŒ…å›´ç›’å°ºå¯¸
    auto collider_size = collider_->getAABBSize();

    // å¦‚æœå°ºå¯¸æ— æ•ˆï¼Œåç§»ä¸º0
    if (collider_size.x <= 0.0f || collider_size.y <= 0.0f) {
        offset_ = {0.0f, 0.0f};
        return;
    }
    auto scale = transform_->getScale();

    // æ ¹æ® alignment_anchor_ è®¡ç®— AABB å·¦ä¸Šè§’ç›¸å¯¹äº Transform ä¸­å¿ƒçš„åç§»é‡
    switch (alignment_) {
        case engine::utils::Alignment::TOP_LEFT:
            offset_ = glm::vec2{0.0f, 0.0f} * scale;
            break;
        case engine::utils::Alignment::TOP_CENTER:
            offset_ = glm::vec2{-collider_size.x / 2.0f, 0.0f} * scale;
            break;
        case engine::utils::Alignment::TOP_RIGHT:
            offset_ = glm::vec2{-collider_size.x, 0.0f} * scale;
            break;
        case engine::utils::Alignment::CENTER_LEFT:
            offset_ = glm::vec2{0.0f, -collider_size.y / 2.0f} * scale;
            break;
        case engine::utils::Alignment::CENTER:
            offset_ = glm::vec2{-collider_size.x / 2.0f, -collider_size.y / 2.0f} * scale;
            break;
        case engine::utils::Alignment::CENTER_RIGHT:
             offset_ = glm::vec2{-collider_size.x, -collider_size.y / 2.0f} * scale;
            break;
        case engine::utils::Alignment::BOTTOM_LEFT:
            offset_ = glm::vec2{0.0f, -collider_size.y} * scale;
            break;
        case engine::utils::Alignment::BOTTOM_CENTER:
            offset_ = glm::vec2{-collider_size.x / 2.0f, -collider_size.y} * scale;
            break;
        case engine::utils::Alignment::BOTTOM_RIGHT:
            offset_ = glm::vec2{-collider_size.x, -collider_size.y} * scale;
            break;
        default:
            break; // å¦‚æœ alignment_ æ˜¯ NONEï¼Œåˆ™ä¸åšä»»ä½•æ“ä½œï¼ˆæ‰‹åŠ¨è®¾ç½® offset_ï¼‰
    }
}

engine::utils::Rect ColliderComponent::getWorldAABB() const {
    if (!transform_ || !collider_) {
        return {glm::vec2(0.0f, 0.0f), glm::vec2(0.0f, 0.0f)};
    }
    // è®¡ç®—æœ€å°åŒ…å›´ç›’çš„å·¦ä¸Šè§’åæ ‡ï¼ˆpositionï¼‰
    const glm::vec2 top_left_pos = transform_->getPosition() + offset_;
    // è®¡ç®—æœ€å°åŒ…å›´ç›’çš„å°ºå¯¸ï¼ˆsizeï¼‰
    const glm::vec2 base_size = collider_->getAABBSize();
    const glm::vec2 scale = transform_->getScale();
    glm::vec2 scaled_size = base_size * scale;
    // è¿”å›æœ€å°åŒ…å›´ç›’çš„ Rect
    return { top_left_pos, scaled_size };
}

} // namespace engine::component
```

### å…³é”®æ–¹æ³•è§£æ

| æ–¹æ³• | èŒè´£ |
|------|------|
| `updateOffset()` | æ ¹æ®å¯¹é½æ–¹å¼è®¡ç®—ç¢°æ’å™¨ç›¸å¯¹äº Transform çš„åç§»é‡ |
| `getWorldAABB()` | **å…³é”®æ–¹æ³•**ï¼šè®¡ç®—ç¢°æ’ä½“åœ¨ä¸–ç•Œåæ ‡ç³»ä¸­çš„ç²¾ç¡®åŒ…å›´ç›’ï¼Œä¸ºç¢°æ’æ£€æµ‹æä¾›æ•°æ® |

è¿™ä¸ªç»„ä»¶æŒæœ‰ `Collider`ï¼ˆé€šè¿‡ `std::unique_ptr` ç®¡ç†å…¶ç”Ÿå‘½å‘¨æœŸï¼‰ï¼Œå¹¶åƒ `SpriteComponent` ä¸€æ ·ï¼Œé€šè¿‡ `offset_` å’Œ `alignment_` æ¥ç¡®å®šç¢°æ’ä½“ç›¸å¯¹äº `TransformComponent` çš„ä½ç½®ã€‚

---

## 3. ç¢°æ’æ£€æµ‹ç®—æ³•ï¼ˆcollision.h/cppï¼‰

æˆ‘ä»¬å°†æ‰€æœ‰çº¯ç²¹çš„ **æ•°å­¦ç¢°æ’æ£€æµ‹å‡½æ•°** æ”¾åœ¨ä¸€ä¸ªç‹¬ç«‹çš„ `collision` å‘½åç©ºé—´ä¸‹ï¼Œè¿™è®©æˆ‘ä»¬çš„ä»£ç æ›´åŠ æ¸…æ™°ã€‚

### æ£€æµ‹ç®—æ³•æ¦‚è§ˆ

| æ£€æµ‹ç±»å‹ | ç®—æ³• | å¤æ‚åº¦ |
|---------|------|--------|
| **AABB vs AABB** | åˆ†ç¦»è½´å®šç† | O(1) |
| **Circle vs Circle** | åœ†å¿ƒè·ç¦»æ¯”è¾ƒ | O(1) |
| **AABB vs Circle** | æœ€è¿‘ç‚¹æ£€æµ‹ | O(1) |

---

### engine/physics/collision.hï¼ˆæ–°å»ºï¼‰

```cpp
#pragma once
#include "../utils/math.h"

namespace engine::component {
class ColliderComponent;
}

namespace engine::physics::collision {

/**
 * @brief æ£€æŸ¥ä¸¤ä¸ªç¢°æ’å™¨ç»„ä»¶æ˜¯å¦é‡å ã€‚
 * @param a ç¬¬ä¸€ä¸ªç¢°æ’å™¨ç»„ä»¶ã€‚
 * @param b ç¬¬äºŒä¸ªç¢°æ’å™¨ç»„ä»¶ã€‚
 * @return true å¦‚æœç¢°æ’å™¨ç»„ä»¶é‡å ï¼Œå¦åˆ™ä¸º falseã€‚
 */
bool checkCollision(const engine::component::ColliderComponent& a, const engine::component::ColliderComponent& b);

/**
 * @brief æ£€æŸ¥ä¸¤ä¸ªåœ†å½¢æ˜¯å¦é‡å ã€‚
 * 
 * @param a_center ç¬¬ä¸€ä¸ªåœ†çš„ä¸­å¿ƒã€‚
 * @param a_radius ç¬¬ä¸€ä¸ªåœ†çš„åŠå¾„ã€‚
 * @param b_center ç¬¬äºŒä¸ªåœ†çš„ä¸­å¿ƒã€‚
 * @param b_radius ç¬¬äºŒä¸ªåœ†çš„åŠå¾„ã€‚
 * @return true å¦‚æœä¸¤ä¸ªåœ†é‡å ï¼Œå¦åˆ™ä¸º falseã€‚
 */
bool checkCircleOverlap(const glm::vec2& a_center, const float a_radius, const glm::vec2& b_center, const float b_radius);

/**
 * @brief æ£€æŸ¥ä¸¤ä¸ªè½´å¯¹é½åŒ…å›´ç›’ (AABB) æ˜¯å¦é‡å ã€‚
 * @param a_pos ç¬¬ä¸€ä¸ªAABBçš„å·¦ä¸Šè§’åæ ‡ã€‚
 * @param a_size ç¬¬ä¸€ä¸ªAABBçš„å°ºå¯¸ã€‚
 * @param b_pos ç¬¬äºŒä¸ªAABBçš„å·¦ä¸Šè§’åæ ‡ã€‚
 * @param b_size ç¬¬äºŒä¸ªAABBçš„å°ºå¯¸ã€‚
 * @return true å¦‚æœAABBé‡å ï¼Œå¦åˆ™ä¸º falseã€‚
 */
bool checkAABBOverlap(const glm::vec2& a_pos, const glm::vec2& a_size, const glm::vec2& b_pos, const glm::vec2& b_size);

/**
 * @brief æ£€æŸ¥ä¸¤ä¸ªçŸ©å½¢æ˜¯å¦é‡å ã€‚
 * 
 * @param a ç¬¬ä¸€ä¸ªçŸ©å½¢ã€‚
 * @param b ç¬¬äºŒä¸ªçŸ©å½¢ã€‚
 * @return true å¦‚æœçŸ©å½¢é‡å ï¼Œå¦åˆ™ä¸º falseã€‚
 */
bool checkRectOverlap(const engine::utils::Rect& a, const engine::utils::Rect& b);

/**
 * @brief æ£€æŸ¥ä¸€ä¸ªç‚¹æ˜¯å¦åœ¨åœ†å†…ã€‚
 * 
 * @param point è¦æ£€æŸ¥çš„ç‚¹ã€‚
 * @param center åœ†çš„ä¸­å¿ƒã€‚
 * @param radius åœ†çš„åŠå¾„ã€‚
 * @return true å¦‚æœç‚¹åœ¨åœ†å†…ï¼Œå¦åˆ™ä¸º falseã€‚
 */
bool checkPointInCircle(const glm::vec2& point, const glm::vec2& center, const float radius);

// æœªæ¥å¯ä»¥æ·»åŠ æ›´å¤šç¢°æ’æ£€æµ‹ç›¸å…³çš„å‡½æ•°ï¼Œ

} // namespace engine::physics::collision
```

### engine/physics/collision.cppï¼ˆæ–°å»ºï¼‰

```cpp
#include "collision.h"
#include "../component/collider_component.h"
#include "../component/transform_component.h"

namespace engine::physics::collision {

bool checkCollision(const engine::component::ColliderComponent& a, const engine::component::ColliderComponent& b) {
    // è·å–ä¸¤ä¸ªç¢°æ’ç›’åŠå¯¹åº”Transformä¿¡æ¯
    auto a_collider = a.getCollider();
    auto b_collider = b.getCollider();
    auto a_transform = a.getTransform();
    auto b_transform = b.getTransform();

    // å…ˆè®¡ç®—æœ€å°åŒ…å›´ç›’æ˜¯å¦ç¢°æ’ï¼Œå¦‚æœæ²¡æœ‰ç¢°æ’ï¼Œé‚£ä¸€å®šæ˜¯è¿”å›false (ä¸è€ƒè™‘AABBçš„æ—‹è½¬)
    auto a_size = a_collider->getAABBSize() * a_transform->getScale();
    auto b_size = b_collider->getAABBSize() * b_transform->getScale();
    auto a_pos = a_transform->getPosition() + a.getOffset();
    auto b_pos = b_transform->getPosition() + b.getOffset();
    if (!checkAABBOverlap(a_pos, a_size, b_pos, b_size)) {
        return false;
    }

    // --- å¦‚æœæœ€å°åŒ…å›´ç›’æœ‰ç¢°æ’ï¼Œå†è¿›è¡Œæ›´ç»†è‡´çš„åˆ¤æ–­ ---
    // AABB vs AABB, ç›´æ¥è¿”å›çœŸ
    if (a_collider->getType() == engine::physics::ColliderType::AABB && b_collider->getType() == engine::physics::ColliderType::AABB) {
        return true;
    }
    // Circle vs Circle: åˆ¤æ–­ä¸¤ä¸ªåœ†å¿ƒè·ç¦»æ˜¯å¦å°äºä¸¤ä¸ªåœ†çš„åŠå¾„ä¹‹å’Œ
    else if (a_collider->getType() == engine::physics::ColliderType::CIRCLE && b_collider->getType() == engine::physics::ColliderType::CIRCLE)
    {
        auto a_center = a_pos + 0.5f * a_size;  // åœ†å¿ƒä½ç½®
        auto b_center = b_pos + 0.5f * b_size;
        auto a_radius = 0.5f * a_size.x;        // åœ†çš„åŠå¾„ç­‰äºAABBçš„ä¸€åŠå®½åº¦
        auto b_radius = 0.5f * b_size.x;
        return checkCircleOverlap(a_center, a_radius, b_center, b_radius);
    }
    // AABB vs Circle: åˆ¤æ–­åœ†å¿ƒåˆ°AABBçš„æœ€é‚»è¿‘ç‚¹æ˜¯å¦åœ¨åœ†å†…
    else if (a_collider->getType() == engine::physics::ColliderType::AABB && b_collider->getType() == engine::physics::ColliderType::CIRCLE)
    {
        auto b_center = b_pos + 0.5f * b_size;
        auto b_radius = 0.5f * b_size.x;
        auto nearest_point = glm::clamp(b_center, a_pos, a_pos + a_size);   // è®¡ç®—åœ†å¿ƒåˆ°AABBçš„æœ€é‚»è¿‘ç‚¹
        return checkPointInCircle(nearest_point, b_center, b_radius);
    }
    // Circle vs AABB
    else if (a_collider->getType() == engine::physics::ColliderType::CIRCLE && b_collider->getType() == engine::physics::ColliderType::AABB)
    {
        auto a_center = a_pos + 0.5f * a_size;
        auto a_radius = 0.5f * a_size.x;
        auto nearest_point = glm::clamp(a_center, b_pos, b_pos + b_size);   // è®¡ç®—åœ†å¿ƒåˆ°AABBçš„æœ€é‚»è¿‘ç‚¹
        return checkPointInCircle(nearest_point, a_center, a_radius);
    }
    return false;
}

bool checkCircleOverlap(const glm::vec2& a_center, const float a_radius, const glm::vec2& b_center, const float b_radius)
{
    return (glm::length(a_center - b_center) < a_radius + b_radius);
}

bool checkAABBOverlap(const glm::vec2& a_pos, const glm::vec2& a_size, const glm::vec2& b_pos, const glm::vec2& b_size) {
    // æ£€æŸ¥ä¸¤ä¸ªAABBæ˜¯å¦é‡å 
    if (a_pos.x + a_size.x <= b_pos.x || a_pos.x >= b_pos.x + b_size.x ||
        a_pos.y + a_size.y <= b_pos.y || a_pos.y >= b_pos.y + b_size.y) {
        return false;
    }
    return true;
}

bool checkRectOverlap(const engine::utils::Rect& a, const engine::utils::Rect& b) {
    return checkAABBOverlap(a.position, a.size, b.position, b.size);
}

bool checkPointInCircle(const glm::vec2 &point, const glm::vec2 &center, const float radius)
{
    return (glm::length(point - center) < radius);
}

} // namespace engine::physics::collision
```

### ğŸ”‘ æ ¸å¿ƒç®—æ³•ï¼šä¸¤é˜¶æ®µæ£€æµ‹

`checkCollision` å‡½æ•°é‡‡ç”¨ **ä¸¤é˜¶æ®µæ£€æµ‹** ç­–ç•¥ï¼š

#### é˜¶æ®µ 1ï¼šç²—ç•¥æ£€æµ‹ï¼ˆAABB è¿‡æ»¤ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          â”‚      â”‚          â”‚
â”‚  AABB A  â”‚      â”‚  AABB B  â”‚
â”‚          â”‚      â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“                â†“
  AABB ä¸é‡å ï¼Ÿâ†’ ç›´æ¥è¿”å› false
  AABB é‡å ï¼Ÿâ†’ ç»§ç»­ç²¾ç¡®æ£€æµ‹
```

**ä¼˜åŠ¿**ï¼š
- âš¡ AABB æ£€æµ‹éå¸¸å¿«é€Ÿï¼ˆä»… 4 æ¬¡æ¯”è¾ƒï¼‰
- ğŸ¯ èƒ½è¿‡æ»¤æ‰å¤§éƒ¨åˆ†ä¸ç¢°æ’çš„æƒ…å†µ
- ğŸ’° èŠ‚çœäº†æ˜‚è´µçš„ç²¾ç¡®æ£€æµ‹è®¡ç®—

#### é˜¶æ®µ 2ï¼šç²¾ç¡®æ£€æµ‹

æ ¹æ® Collider çš„ç±»å‹è¿›è¡Œç²¾ç¡®æ£€æµ‹ï¼š

| ç±»å‹ç»„åˆ | æ£€æµ‹æ–¹æ³• | è¯´æ˜ |
|---------|---------|------|
| **AABB vs AABB** | ç›´æ¥è¿”å› true | å·²ç»åœ¨é˜¶æ®µ 1 æ£€æµ‹è¿‡äº† |
| **Circle vs Circle** | åœ†å¿ƒè·ç¦» < åŠå¾„å’Œ | `distance(c1, c2) < r1 + r2` |
| **AABB vs Circle** | æœ€è¿‘ç‚¹æ£€æµ‹ | æ‰¾åˆ° AABB ä¸Šç¦»åœ†å¿ƒæœ€è¿‘çš„ç‚¹ï¼Œæ£€æŸ¥æ˜¯å¦åœ¨åœ†å†… |

### ğŸ“ AABB vs Circle ç®—æ³•è¯¦è§£

```
        Circle
          â—
         /â”‚\
        / â”‚ \
       /  â”‚  \
      /   â”‚   \
AABB â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”
     â”‚    â†“    â”‚
     â”‚  æœ€è¿‘ç‚¹  â”‚
     â”‚         â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ­¥éª¤ï¼š
1. æ‰¾åˆ°åœ†å¿ƒåˆ° AABB çš„æœ€è¿‘ç‚¹ï¼ˆclampï¼‰
2. æ£€æŸ¥è¯¥ç‚¹æ˜¯å¦åœ¨åœ†å†…
```

---

## 4. åœ¨ PhysicsEngine ä¸­é›†æˆç¢°æ’æ£€æµ‹

ç°åœ¨ï¼Œ`PhysicsEngine` ä¸ä»…è¦æ›´æ–°ç‰©ä½“ä½ç½®ï¼Œè¿˜è¦è´Ÿè´£åœ¨æ›´æ–°åæ£€æµ‹æ‰€æœ‰ç‰©ä½“ä¹‹é—´çš„ç¢°æ’ã€‚

### engine/physics/physics_engine.hï¼ˆæ›´æ–°ï¼‰

```cpp
// ...
class PhysicsEngine {
private:
    // ... components_, gravity_, max_speed_ ...
    // æ–°å¢ï¼šå­˜å‚¨æœ¬å¸§å‘ç”Ÿçš„ç¢°æ’å¯¹
    std::vector<std::pair<engine::object::GameObject*, engine::object::GameObject*>> collision_pairs_;

public:
    // ...
    void update(float delta_time);
    
    // æ–°å¢ï¼šè·å–ç¢°æ’å¯¹åˆ—è¡¨
    const auto& getCollisionPairs() const { return collision_pairs_; };

private:
    // æ–°å¢ï¼šç¢°æ’æ£€æµ‹å¾ªç¯
    void checkObjectCollisions();
};
```

### engine/physics/physics_engine.cppï¼ˆæ›´æ–°ï¼‰

```cpp
// ...
void PhysicsEngine::update(float delta_time) {
    // 1. æ¯å¸§å¼€å§‹æ—¶æ¸…ç©ºä¸Šä¸€å¸§çš„ç¢°æ’è®°å½•
    collision_pairs_.clear();

    // 2. æ›´æ–°æ‰€æœ‰ç‰©ç†ç»„ä»¶çš„ä½ç½®ï¼ˆä¸ä¸Šä¸€è¯¾ç›¸åŒï¼‰
    for (auto* pc : components_) {
        // ... (æ›´æ–°é€Ÿåº¦å’Œä½ç½®) ...
    }

    // 3. æ‰§è¡Œç¢°æ’æ£€æµ‹
    checkObjectCollisions();
}

void PhysicsEngine::checkObjectCollisions()
{
    // ä¸¤å±‚å¾ªç¯éå†æ‰€æœ‰åŒ…å«ç‰©ç†ç»„ä»¶çš„ GameObject
    for (size_t i = 0; i < components_.size(); ++i) {
        auto* pc_a = components_[i];
        if (!pc_a || !pc_a->isEnabled()) continue;
        auto* obj_a = pc_a->getOwner();
        if (!obj_a) continue;
        auto* cc_a = obj_a->getComponent<engine::component::ColliderComponent>();
        if (!cc_a || !cc_a->isActive()) continue;

        for (size_t j = i + 1; j < components_.size(); ++j) {
            auto* pc_b = components_[j];
            if (!pc_b || !pc_b->isEnabled()) continue;
            auto* obj_b = pc_b->getOwner();
            if (!obj_b) continue;
            auto* cc_b = obj_b->getComponent<engine::component::ColliderComponent>();
            if (!cc_b || !cc_b->isActive()) continue;
            /* --- é€šè¿‡ä¿æŠ¤æ€§æµ‹è¯•åï¼Œæ­£å¼æ‰§è¡Œé€»è¾‘ --- */

            if (collision::checkCollision(*cc_a, *cc_b)) {
                // TODO: å¹¶ä¸æ˜¯æ‰€æœ‰ç¢°æ’éƒ½éœ€è¦æ’å…¥collision_pairs_ï¼Œæœªæ¥ä¼šæ·»åŠ è¿‡æ»¤æ¡ä»¶
                // è®°å½•ç¢°æ’å¯¹
                collision_pairs_.emplace_back(obj_a, obj_b);
            }
        }
    }
}
```

### ä»£ç è§£æ

| æ­¥éª¤ | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| **1. æ¸…ç©ºç¢°æ’è®°å½•** | `collision_pairs_.clear()` | æ¯å¸§å¼€å§‹æ—¶æ¸…ç©ºä¸Šä¸€å¸§çš„ç¢°æ’è®°å½• |
| **2. æ›´æ–°ä½ç½®** | éå†æ‰€æœ‰ `PhysicsComponent` | åº”ç”¨ç‰©ç†è§„åˆ™æ›´æ–°ä½ç½®ï¼ˆä¸ä¸Šä¸€è¯¾ç›¸åŒï¼‰ |
| **3. æ£€æµ‹ç¢°æ’** | `checkObjectCollisions()` | æ‰§è¡Œç¢°æ’æ£€æµ‹ |

### âš™ï¸ checkObjectCollisions ä¼˜åŒ–

```cpp
for (size_t i = 0; i < components_.size(); ++i) {
    for (size_t j = i + 1; j < components_.size(); ++j) {
        // æ£€æµ‹ i å’Œ j ä¹‹é—´çš„ç¢°æ’
    }
}
```

**ä¼˜åŒ–ç‚¹**ï¼š
- âœ… å†…å±‚å¾ªç¯ `j = i + 1`ï¼šé¿å…é‡å¤æ£€æµ‹ï¼ˆA vs B å’Œ B vs Aï¼‰
- âœ… é¿å…è‡ªæˆ‘æ£€æµ‹ï¼ˆA vs Aï¼‰
- â±ï¸ æ—¶é—´å¤æ‚åº¦ï¼šO(nÂ²)

> ğŸ’¡ **æ€§èƒ½è€ƒè™‘**ï¼šå¯¹äºå¯¹è±¡å±‚çš„ç‰©ä½“ä¸å¤šçš„æƒ…å†µï¼ŒO(nÂ²) æš´åŠ›æ³•æ˜¯å¯ä»¥æ¥å—çš„ã€‚ç“¦ç‰‡å±‚ä¼šåœ¨ç¬¬ 17 è¯¾ä½¿ç”¨ä¸“é—¨çš„ä¼˜åŒ–ç®—æ³•ã€‚

### ç¢°æ’å¯¹çš„å­˜å‚¨

```cpp
collision_pairs_.emplace_back(obj_a, obj_b);
```

å¦‚æœ `collision::checkCollision` è¿”å› trueï¼Œå°±å°†è¿™å¯¹å‘ç”Ÿç¢°æ’çš„ `GameObject` æŒ‡é’ˆå­˜å…¥ `collision_pairs_`ã€‚

**èŒè´£åˆ†ç¦»**ï¼š
- âœ… ç‰©ç†å¼•æ“ï¼šæŠ¥å‘Šç¢°æ’äº‹ä»¶
- âœ… ä¸Šå±‚é€»è¾‘ï¼šå†³å®šå¦‚ä½•å“åº”ç¢°æ’

---

## 5. æµ‹è¯•ç¢°æ’

æˆ‘ä»¬åœ¨ `GameScene` ä¸­åˆ›å»ºä¸¤ä¸ªç‰©ä½“ï¼šä¸€ä¸ªå—é‡åŠ›å½±å“çš„ç®±å­ï¼ˆAABB ç¢°æ’ä½“ï¼‰å’Œä¸€ä¸ªé™æ­¢çš„ç®±å­ï¼ˆåœ†å½¢ç¢°æ’ä½“ï¼‰ï¼Œå¹¶ç»™å®ƒä»¬éƒ½åŠ ä¸Š `ColliderComponent`ã€‚

### src/game/scene/game_scene.cppï¼ˆæ›´æ–°ï¼‰

```cpp
#include "../../engine/component/collider_component.h"

// ... in GameScene::createTestObject() ...
void GameScene::createTestObject() {
    // ç‰©ä½“1: å—é‡åŠ›çš„ç®±å­ (AABB)
    auto test_object = std::make_unique<engine::object::GameObject>("test_object");
    test_object_ = test_object.get();
    test_object->addComponent<engine::component::TransformComponent>(glm::vec2(100.0f, 100.0f));
    test_object->addComponent<engine::component::SpriteComponent>(/*...*/);
    test_object->addComponent<engine::component::PhysicsComponent>(&context_.getPhysicsEngine());
    test_object->addComponent<engine::component::ColliderComponent>(
        std::make_unique<engine::physics::AABBCollider>(glm::vec2(32.0f, 32.0f))
    );
    addGameObject(std::move(test_object));

    // ç‰©ä½“2: é™æ­¢çš„ç®±å­ (Circle)
    auto test_object2 = std::make_unique<engine::object::GameObject>("test_object2");
    test_object2->addComponent<engine::component::TransformComponent>(glm::vec2(50.0f, 250.0f)); // æ”¾åœ¨ä¸‹è½è·¯å¾„ä¸Š
    test_object2->addComponent<engine::component::SpriteComponent>(/*...*/);
    test_object2->addComponent<engine::component::PhysicsComponent>(&context_.getPhysicsEngine(), false); // ä¸å—é‡åŠ›
    test_object2->addComponent<engine::component::ColliderComponent>(
        std::make_unique<engine::physics::CircleCollider>(16.0f)
    );
    addGameObject(std::move(test_object2));
}

// ... in GameScene::update() ...
void GameScene::update(float delta_time) {
    Scene::update(delta_time);
    TestCollisionPairs(); // æ¯å¸§æ£€æŸ¥å¹¶æ‰“å°ç¢°æ’å¯¹
}

// new test function
void GameScene::TestCollisionPairs()
{
    auto& collision_pairs = context_.getPhysicsEngine().getCollisionPairs();
    for (auto& pair : collision_pairs) {
        spdlog::info("ç¢°æ’å¯¹: {} å’Œ {}", pair.first->getName(), pair.second->getName());
    }
}
```

### âš™ï¸ é…ç½®è°ƒæ•´

å¦å¤–ï¼Œä¸ºäº†æ–¹ä¾¿è§‚å¯Ÿï¼Œæˆ‘ä»¬å°† `assets/config.json` ä¸­çš„ `target_fps` æ”¹ä¸º `60`ã€‚

### âœ… ç¼–è¯‘ä¸è¿è¡Œ

ç¼–è¯‘å¹¶è¿è¡Œã€‚ä½ ä¼šçœ‹åˆ°ï¼š

```
è¿è¡Œæ•ˆæœï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“¦ (AABB)             â”‚
â”‚   â†“ ä¸‹è½                â”‚
â”‚   â†“                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”              â”‚
â”‚   â—  (Circle)          â”‚
â”‚   â†“                     â”‚
â”‚  ğŸ“¦ğŸ’¥â— â† é‡å æ£€æµ‹åˆ°ï¼   â”‚
â”‚                         â”‚
â”‚ æ§åˆ¶å°è¾“å‡ºï¼š            â”‚
â”‚ [info] ç¢°æ’å¯¹: test_object å’Œ test_object2
â”‚ [info] ç¢°æ’å¯¹: test_object å’Œ test_object2
â”‚ ...                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å½“æ‰è½çš„ç®±å­ä¸é™æ­¢çš„ç®±å­é‡å æ—¶ï¼Œæ§åˆ¶å°ä¼šå¼€å§‹æŒç»­æ‰“å°ç¢°æ’ä¿¡æ¯ï¼**

è¿™è¯æ˜æˆ‘ä»¬çš„ç¢°æ’æ£€æµ‹ç³»ç»Ÿå·²ç»æˆåŠŸè¿è¡Œèµ·æ¥äº†ï¼ ğŸ‰

---

## ğŸ¯ ç³»ç»Ÿæ¶æ„æ€»ç»“

### å®Œæ•´çš„ç¢°æ’æ£€æµ‹æ¶æ„

```
GameObject
    â†“ æ·»åŠ 
ColliderComponent (æŒæœ‰ Collider)
    â†“ æä¾›
getWorldAABB() (ä¸–ç•Œåæ ‡åŒ…å›´ç›’)
    â†“ ç”¨äº
collision::checkCollision() (æ£€æµ‹ç®—æ³•)
    â†“ è¢«è°ƒç”¨äº
PhysicsEngine::checkObjectCollisions()
    â†“ è®°å½•åˆ°
collision_pairs_ (ç¢°æ’å¯¹åˆ—è¡¨)
    â†“ ä¾›ä¸Šå±‚æŸ¥è¯¢
æ¸¸æˆé€»è¾‘ / ç¢°æ’è§£æ
```

### æ ¸å¿ƒæˆå°±

æˆ‘ä»¬æˆåŠŸåœ°ï¼š

1. âœ… **å®šä¹‰ç¢°æ’å½¢çŠ¶**ï¼šAABB å’Œ Circle ä¸¤ç§åŸºæœ¬å½¢çŠ¶
2. âœ… **åˆ›å»ºç¢°æ’ç»„ä»¶**ï¼šColliderComponent ç®¡ç†ç¢°æ’å™¨
3. âœ… **å®ç°æ£€æµ‹ç®—æ³•**ï¼šä¸¤é˜¶æ®µæ£€æµ‹ä¼˜åŒ–æ€§èƒ½
4. âœ… **é›†æˆåˆ°å¼•æ“**ï¼šPhysicsEngine ç»Ÿä¸€ç®¡ç†ç¢°æ’æ£€æµ‹
5. âœ… **ç¢°æ’å¯¹è®°å½•**ï¼šä¸ºä¸‹ä¸€æ­¥ç¢°æ’è§£æåšå‡†å¤‡

### è®¾è®¡äº®ç‚¹

| ç‰¹æ€§ | å®ç° | ä¼˜åŠ¿ |
|------|------|------|
| **ä¸¤é˜¶æ®µæ£€æµ‹** | AABB ç²—æ£€æµ‹ + ç²¾ç¡®æ£€æµ‹ | æ€§èƒ½ä¼˜åŒ– |
| **å¤šå½¢çŠ¶æ”¯æŒ** | AABBã€Circleã€æ··åˆæ£€æµ‹ | çµæ´»æ€§é«˜ |
| **ç‹¬ç«‹ç®—æ³•å±‚** | collision å‘½åç©ºé—´ | æ˜“äºæµ‹è¯•å’Œå¤ç”¨ |
| **è§¦å‘å™¨æ”¯æŒ** | is_trigger_ æ ‡å¿— | æ”¯æŒä¸åŒç¢°æ’ç±»å‹ |
| **O(nÂ²) æš´åŠ›æ³•** | ç®€å•ç›´æ¥ | å¯¹è±¡å±‚æ•°é‡é€‚ä¸­æ—¶å¯æ¥å— |

### æ£€æµ‹ç®—æ³•æ€»ç»“

| æ£€æµ‹ç±»å‹ | æ ¸å¿ƒå…¬å¼ | æ—¶é—´å¤æ‚åº¦ |
|---------|---------|-----------|
| **AABB vs AABB** | åˆ†ç¦»è½´æ£€æµ‹ | O(1) |
| **Circle vs Circle** | `distance < r1 + r2` | O(1) |
| **AABB vs Circle** | æœ€è¿‘ç‚¹ + ç‚¹åœ¨åœ†å†… | O(1) |

---

## ğŸ“š æ€»ç»“

æˆ‘ä»¬å·²ç»ä¸ºæ¸¸æˆä¸–ç•Œå»ºç«‹äº†ç¢°æ’æ£€æµ‹ç³»ç»Ÿï¼

**å…³é”®è¦ç‚¹ï¼š**
- ğŸ”· Collider å®šä¹‰ç¢°æ’å½¢çŠ¶ï¼ˆAABBã€Circleï¼‰
- ğŸ§© ColliderComponent å°†ç¢°æ’å™¨é™„åŠ åˆ° GameObject
- ğŸ” ä¸¤é˜¶æ®µæ£€æµ‹ï¼šAABB ç²—æ£€ + ç²¾ç¡®æ£€æµ‹
- âš¡ PhysicsEngine ç»Ÿä¸€ç®¡ç†ç¢°æ’æ£€æµ‹
- ğŸ“Š collision_pairs_ è®°å½•æ‰€æœ‰ç¢°æ’å¯¹
- ğŸ¯ O(nÂ²) é€‚ç”¨äºå¯¹è±¡å±‚ï¼Œç“¦ç‰‡å±‚éœ€ç‰¹æ®Šä¼˜åŒ–

> ğŸ’¡ **è®¾è®¡å“²å­¦**ï¼šç¢°æ’æ£€æµ‹åªè´Ÿè´£"æ£€æµ‹"ï¼Œä¸è´Ÿè´£"å“åº”"ã€‚èŒè´£åˆ†ç¦»è®©ç³»ç»Ÿæ›´åŠ çµæ´»â€”â€”æˆ‘ä»¬å¯ä»¥å¯¹ä¸åŒçš„ç¢°æ’åšå‡ºä¸åŒçš„å“åº”ï¼ˆç‰©ç†åå¼¹ã€è§¦å‘äº‹ä»¶ã€ä¼¤å®³è®¡ç®—ç­‰ï¼‰ã€‚

---

è¿™èŠ‚è¯¾æˆ‘ä»¬è§£å†³äº† **æ¸¸æˆå¯¹è±¡ä¹‹é—´çš„ç¢°æ’æ£€æµ‹**ï¼Œå› ä¸ºæ¸¸æˆä¸­å¯¹è±¡å±‚çš„ç‰©ä½“ä¸å¤šï¼Œå› æ­¤é‡‡ç”¨ä½¿ç”¨æš´åŠ›æ³• O(nÂ²) æ£€æŸ¥æ‰€æœ‰ç¢°æ’å¯¹æ˜¯å¯ä»¥æ¥å—çš„ã€‚

ä¸‹èŠ‚è¯¾æˆ‘ä»¬å°†ç»§ç»­å¤„ç† **ç“¦ç‰‡å±‚ä¸æ¸¸æˆå¯¹è±¡ä¹‹é—´çš„ç¢°æ’è§£æ**ï¼š

- ğŸ—ºï¸ ç“¦ç‰‡å±‚ä¸­çš„ç‰©ä½“éå¸¸å¤šï¼ˆå¯èƒ½ä¸Šåƒä¸ªç“¦ç‰‡ï¼‰
- âš¡ æˆ‘ä»¬ä¼šé‡‡ç”¨ä¸“é—¨é’ˆå¯¹ç“¦ç‰‡åœ°å›¾çš„ä¼˜åŒ–ç®—æ³•
- ğŸ¯ é«˜æ•ˆå®ç°ç¢°æ’æ£€æµ‹ï¼ˆè¿œå¿«äº O(nÂ²)ï¼‰
- ğŸƒ è®©è§’è‰²çœŸæ­£ç«™åœ¨åœ°é¢ä¸Šï¼Œè€Œä¸æ˜¯ç©¿é€