# 对象间的碰撞解析

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1XbgezoEds&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1XbgezoEds)

## 📌 问题背景

我们已经成功实现了动态物体与静态瓦片地图的碰撞。然而，一个丰富的游戏世界中充满了各种独立的对象——敌人、移动平台、可推动的箱子等。本节课，我们将实现这些对象之间的碰撞解析，重点关注动态物体与被标记为 **"实体"（Solid）** 的静态对象（如木箱障碍物）之间的交互。

### ⚠️ 当前的问题

```
对象穿透问题：
┌─────────────────────┐
│   👤 → 移动          │
│   ↓                  │
│  📦 木箱             │
│   👤 ← 穿过去了！    │
└─────────────────────┘
```

### 🎯 本课目标

| 目标 | 说明 |
|------|------|
| **理解对象属性** | 区分地图级属性和图块集级属性 |
| **增强属性读取** | 实现通用的属性解析系统 |
| **MTV 算法** | 实现最小平移向量碰撞解析 |
| **数据驱动** | 完全通过 Tiled 配置游戏对象 |

---

## 1. Tiled 中更复杂的对象定义

对象层中的物体，其属性信息可能分散在 **两个地方**：

### 📝 属性来源

| 文件类型 | 存储内容 | 应用场景 |
|---------|---------|---------|
| **地图文件（.tmj）** | 位置、大小、旋转<br>针对当前关卡的自定义属性 | 特定于当前地图的配置 |
| **图块集文件（.tsj）** | 原型的通用属性<br>如 `solid`、`tag`、`gravity` | 跨地图的共享属性 |

### 💡 设计思想

我们将利用 Tiled 强大的自定义属性功能，来丰富对象层的 **数据驱动能力**。

```
对象属性的继承关系：
┌──────────────────────┐
│  图块集 (.tsj)       │  ← 原型定义
│  - solid: true       │
│  - tag: "crate"      │
│  - gravity: true     │
└──────────┬───────────┘
           │ 继承
           ↓
┌──────────────────────┐
│  地图 (.tmj)         │  ← 实例定义
│  - position: (100,50)│
│  - name: "crate_01"  │
└──────────────────────┘
```

### Tiled 地图解析思路

```
解析对象层流程：
    ↓
type: "objectgroup" → 载入对象层
    ↓
遍历 "objects" 数组 → 为每个对象创建 GameObject
    ↓
通过 gid 查找源图片信息 (图块集)
    ↓
从 layer 数据读取位置信息 (地图文件)
    ↓
判断类型并添加组件：
    │
    ├─ 如果是 "solid" 类型
    │     → 静止障碍物
    │     → 碰撞盒 = 整个图片大小
    │
    └─ 如果非 "solid" 类型
          → 从 "objectgroup" 读取自定义碰撞盒
          → 获取其他属性 (tag、gravity 等)
```

### ⚠️ 特别注意

对象层物体的信息分散在两个区块中：

| 数据源 | 存储内容 | 示例 |
|--------|---------|------|
| **地图 .tmj** | 绘制区域、名字<br>针对当前地图的自定义属性 | `position`、`name`<br>可覆盖默认值 |
| **图块集 .tsj**<br>（gid 对应） | 源图片信息<br>任何地图都会有的属性 | `solid`、`tag`、`gravity`<br>碰撞盒定义 |

---

## 2. 增强 LevelLoader 以读取更丰富的属性

为了实现更复杂的数据驱动，我们需要让 `LevelLoader` 能够解析出我们在 Tiled 中为对象原型定义的各种自定义属性，如 `tag`、`gravity`，以及自定义的碰撞盒。

### 设计思路

我们将添加：

| 功能 | 实现方式 | 用途 |
|------|---------|------|
| **通用属性读取** | 模板函数 `getTileProperty<T>()` | 读取任意类型的自定义属性 |
| **碰撞盒解析** | `getColliderRect()` | 解析 Tiled 碰撞编辑器中绘制的矩形 |
| **完整瓦片数据** | `getTileJsonByGid()` | 获取瓦片的完整 JSON 数据 |

### engine/scene/level_loader.h（更新）

```cpp
#pragma once
#include <string>
#include <glm/vec2.hpp>
#include <nlohmann/json.hpp>
#include <map>
#include <optional>
#include "../utils/math.h"

// ... (前向声明)

namespace engine::scene {

class LevelLoader final {
    // ... (已有成员)
public:
    // ...
private:
    // ... (已有加载函数)

    // 新增：模板函数，通用地获取瓦片的自定义属性
    template<typename T>
    std::optional<T> getTileProperty(const nlohmann::json& tile_json, const std::string& property_name) {
        if (!tile_json.contains("properties")) return std::nullopt;
        const auto& properties = tile_json["properties"];
        for (const auto& property : properties) {
            if (property.value("name", "") == property_name) {
                return property.value("value", T{});
            }
        }
        return std::nullopt;
    }

    // 新增：获取在Tiled碰撞编辑器中为瓦片定义的矩形
    std::optional<engine::utils::Rect> getColliderRect(const nlohmann::json& tile_json);

    // ... (已有函数)
    
    // 新增：根据 GID 获取完整的瓦片 JSON 数据
    std::optional<nlohmann::json> getTileJsonByGid(int gid) const;
};

}
```

### 模板函数的优势

| 特性 | 说明 | 示例 |
|------|------|------|
| **类型安全** | 编译期类型检查 | `getTileProperty<bool>(json, "solid")` |
| **代码复用** | 一个函数处理所有类型 | `string`、`int`、`float`、`bool` |
| **可选返回** | 使用 `std::optional` | 属性不存在时返回 `nullopt` |

---

## 3. 实现数据驱动的对象加载

现在，`loadObjectLayer` 的逻辑将变得非常强大。它会根据从 Tiled 读取的属性，动态地为 `GameObject` 添加和配置组件。

### engine/scene/level_loader.cpp（更新）

```cpp
// ...
void LevelLoader::loadObjectLayer(const nlohmann::json& layer_json, Scene& scene)
{
    // ... (遍历 objects 数组)
    for (const auto& object : objects) {
        auto gid = object.value("gid", 0);
        if (gid != 0) { // 只处理有图像的对象
            auto tile_info = getTileInfoByGid(gid);
            // ... (获取位置、旋转、缩放等信息)

            auto game_object = std::make_unique<engine::object::GameObject>(object_name);
            game_object->addComponent<TransformComponent>(position, scale, rotation);
            game_object->addComponent<SpriteComponent>(std::move(tile_info.sprite), scene.getContext().getResourceManager());
            
            // --- 新增逻辑 ---
            auto tile_json_opt = getTileJsonByGid(gid);
            if (!tile_json_opt) continue;
            const auto& tile_json = tile_json_opt.value();

            // 1. 根据'solid'类型添加碰撞器和物理组件
            if (tile_info.type == engine::component::TileType::SOLID) {
                auto collider = std::make_unique<engine::physics::AABBCollider>(src_size);
                game_object->addComponent<ColliderComponent>(std::move(collider));
                game_object->addComponent<PhysicsComponent>(&scene.getContext().getPhysicsEngine(), false); // 不受重力
                game_object->setTag("solid");
            } 
            // 2. 否则，检查是否有自定义碰撞盒
            else if (auto rect = getColliderRect(tile_json); rect) {
                auto collider = std::make_unique<engine::physics::AABBCollider>(rect->size);
                auto* cc = game_object->addComponent<ColliderComponent>(std::move(collider));
                cc->setOffset(rect->position); // 自定义碰撞盒位置是相对偏移
                game_object->addComponent<PhysicsComponent>(&scene.getContext().getPhysicsEngine(), false);
            }

            // 3. 检查并设置'tag'属性
            if (auto tag = getTileProperty<std::string>(tile_json, "tag"); tag) {
                game_object->setTag(tag.value());
            }

            // 4. 检查并设置'gravity'属性
            if (auto gravity = getTileProperty<bool>(tile_json, "gravity"); gravity) {
                auto* pc = game_object->getComponent<PhysicsComponent>();
                if (pc) {
                    pc->setUseGravity(gravity.value());
                } else { // 如果对象还没有物理组件，则为其添加一个
                    game_object->addComponent<PhysicsComponent>(&scene.getContext().getPhysicsEngine(), gravity.value());
                }
            }
            
            scene.addGameObject(std::move(game_object));
        }
    }
}
// ... (其他函数的实现)
```

### 加载逻辑流程

```
对象加载与配置流程：
    ↓
1. 读取 gid → 获取图片和 TileType
    ↓
2. 添加基础组件 (Transform + Sprite)
    ↓
3. 获取完整的瓦片 JSON 数据
    ↓
4. 判断类型并添加碰撞器：
    │
    ├─ solid 类型：
    │    - 碰撞盒 = 图片尺寸
    │    - 添加物理组件（不受重力）
    │    - 设置 tag = "solid"
    │
    └─ 非 solid 类型：
         - 检查自定义碰撞盒
         - 设置碰撞盒偏移
    ↓
5. 读取并应用其他属性：
    - tag: 设置对象标签
    - gravity: 配置重力
    ↓
6. 添加到场景中
```

### 属性应用优先级

| 优先级 | 来源 | 说明 |
|--------|------|------|
| **高** | 地图文件 | 可以覆盖图块集中的默认值 |
| **低** | 图块集文件 | 提供默认配置 |

---

## 4. 核心算法：最小平移向量（MTV）

当两个动态（或一个动态一个静态）物体碰撞时，我们需要一种方法将它们分开。与瓦片碰撞不同，我们不能简单地将物体"贴"到网格线上。这里我们采用一种经典的方法——**最小平移向量（Minimum Translation Vector, MTV）**。

### 💡 核心思想

MTV 的思想是：找出将两个重叠的物体分开所需移动的 **最小距离和方向**。

```
MTV 示例：
┌─────┐
│  A  │
│  ┌──┼──┐
│  │重│  │
└──┼──┘  │
   │  B  │
   └─────┘
   
重叠区域 → 计算 MTV → 沿最小轴推开
```

### 算法步骤

| 步骤 | 操作 | 说明 |
|------|------|------|
| **1. 计算中心点** | `center = position + size / 2` | 获取两个 AABB 的中心 |
| **2. 计算重叠量** | X 和 Y 轴分别计算 | 每个轴的重叠距离 |
| **3. 选择最小轴** | `overlap.x < overlap.y ?` | 沿重叠更小的轴推开 |
| **4. 确定方向** | 比较中心点位置 | 根据相对位置决定推开方向 |
| **5. 应用平移** | `translate(mtv)` | 移动物体到刚好接触的位置 |
| **6. 清零速度** | `velocity = 0` | 阻止继续向碰撞方向移动 |

### 为什么选择最小轴？

| 方案 | 效果 | 问题 |
|------|------|------|
| ❌ 沿两个轴都推开 | 物体跳跃式移动 | 不自然，可能卡顿 |
| ✅ 沿重叠最小的轴推开 | 物体滑动 | 自然的碰撞响应 |

### 可视化说明

```
对角碰撞的处理：
┌────────┐
│ 玩家   │ ← 向右下移动
│   ↘    │
└────┬───┘
     │ overlap_x = 10
     │ overlap_y = 5  ← 更小！
┌────┴───┐
│  木箱  │
│        │
└────────┘

结果：沿 Y 轴推开 5 像素
效果：玩家站在木箱上，可以继续左右移动
```

---

## 5. 实现对象间碰撞解析

### engine/physics/physics_engine.cpp（更新）

我们将在 `checkObjectCollisions` 中分派任务，并实现新的解析函数 `resolveSolidObjectCollisions`。

```cpp
// ...
void PhysicsEngine::checkObjectCollisions()
{
    // ... (双重循环遍历 components_)
    for (size_t i = 0; i < components_.size(); ++i) {
        // ... (获取 a 的组件)
        for (size_t j = i + 1; j < components_.size(); ++j) {
            // ... (获取 b 的组件)

            if (collision::checkCollision(*cc_a, *cc_b)) {
                // 如果是动态物体 vs SOLID静态物体
                if (obj_a->getTag() != "solid" && obj_b->getTag() == "solid") {
                    resolveSolidObjectCollisions(obj_a, obj_b);
                }
                else if (obj_a->getTag() == "solid" && obj_b->getTag() != "solid") {
                    resolveSolidObjectCollisions(obj_b, obj_a);
                }
                else {
                    // 其他情况（如 玩家 vs 敌人）先记录下来，交由游戏逻辑处理
                    collision_pairs_.emplace_back(obj_a, obj_b);
                }
            }
        }
    }
}

void PhysicsEngine::resolveSolidObjectCollisions(engine::object::GameObject* move_obj, engine::object::GameObject* solid_obj)
{
    auto* move_tc = move_obj->getComponent<TransformComponent>();
    auto* move_pc = move_obj->getComponent<PhysicsComponent>();
    auto* move_cc = move_obj->getComponent<ColliderComponent>();
    auto* solid_cc = solid_obj->getComponent<ColliderComponent>();
    
    auto move_aabb = move_cc->getWorldAABB();
    auto solid_aabb = solid_cc->getWorldAABB();

    // 计算中心点
    auto move_center = move_aabb.position + move_aabb.size / 2.0f;
    auto solid_center = solid_aabb.position + solid_aabb.size / 2.0f;

    // 计算两个AABB在x和y轴上的重叠量
    auto overlap = (move_aabb.size / 2.0f + solid_aabb.size / 2.0f) - glm::abs(move_center - solid_center);
    if (overlap.x <= 0 || overlap.y <= 0) return;

    // 判断哪个轴的重叠更小，就沿哪个轴的反方向推开
    if (overlap.x < overlap.y) { // X轴重叠更小
        if (move_center.x < solid_center.x) { // 移动物在左侧，向左推
            move_tc->translate(glm::vec2(-overlap.x, 0.0f));
            if (move_pc->velocity_.x > 0) move_pc->velocity_.x = 0; // 阻止继续向右
        } else { // 移动物在右侧，向右推
            move_tc->translate(glm::vec2(overlap.x, 0.0f));
            if (move_pc->velocity_.x < 0) move_pc->velocity_.x = 0; // 阻止继续向左
        }
    } else { // Y轴重叠更小
        if (move_center.y < solid_center.y) { // 移动物在上方，向上推
            move_tc->translate(glm::vec2(0.0f, -overlap.y));
            if (move_pc->velocity_.y > 0) move_pc->velocity_.y = 0; // 阻止继续向下
        } else { // 移动物在下方，向下推
            move_tc->translate(glm::vec2(0.0f, overlap.y));
            if (move_pc->velocity_.y < 0) move_pc->velocity_.y = 0; // 阻止继续向上
        }
    }
}
```

### 碰撞分类策略

```
碰撞类型判断：
    ↓
检测到碰撞
    ↓
┌───────────────────────────┐
│ 判断对象标签 (Tag)        │
└──────┬────────────────────┘
       │
       ├─ 动态物体 vs "solid" 物体
       │     → resolveSolidObjectCollisions()
       │     → 立即解析，分离物体
       │
       └─ 其他情况（玩家 vs 敌人等）
             → 记录到 collision_pairs_
             → 交由游戏逻辑处理
```

### 重要修正

⚠️ **注意**：在 `resolveTileCollisions` 中，我们需要将以下代码：

```cpp
tc->setPosition(new_obj_pos)
```

修改为：

```cpp
tc->translate(new_obj_pos - obj_pos)
```

**原因**：使用 `translate` 而非 `setPosition` 能正确处理带 `offset` 的碰撞体，确保偏移量得到保留。

---

## 6. 场景设置与测试

现在，我们的 `LevelLoader` 足够智能，可以 **完全由 Tiled 地图来驱动场景的创建** 了。

### 在 Tiled 中配置

| 配置项 | 操作 | 说明 |
|--------|------|------|
| **玩家原型** | 打开图块集 `.tsj` 文件 | 添加自定义属性 |
| → `tag` | 类型：`string`，值：`"player"` | 标记为玩家 |
| → `gravity` | 类型：`bool`，值：`true` | 受重力影响 |
| → 碰撞盒 | 使用碰撞编辑器绘制矩形 | 精确的碰撞区域 |
| **木箱原型** | 选择木箱瓦片 | 配置障碍物 |
| → `solid` | 类型：`bool`，值：`true` | 标记为实体 |
| **放置对象** | 在对象层中拖拽实例 | 创建游戏对象 |

### 步骤说明

```
Tiled 配置流程：
    ↓
1. 配置图块集原型
   - 玩家：tag="player", gravity=true, 绘制碰撞盒
   - 木箱：solid=true
    ↓
2. 在地图的对象层中
   - 放置一个玩家实例（命名为 "player"）
   - 放置多个木箱障碍物
    ↓
3. 保存地图文件
```

---

## 7. 代码清理与重构

### src/game/scene/game_scene.cpp（更新）

```cpp
// ...
void GameScene::init() {
    engine::scene::LevelLoader level_loader;
    level_loader.loadLevel("assets/maps/level1.tmj", *this);

    // 注册"main"层到物理引擎
    // ...
    
    // 获取由LevelLoader创建的玩家对象
    player_ = findGameObjectByName("player");
    if (!player_) {
        spdlog::error("在场景中未找到名为 'player' 的对象！");
        return;
    }

    Scene::init();
}

void GameScene::handleInput() {
    Scene::handleInput();
    TestPlayer(); // 控制玩家
}

void GameScene::TestPlayer() {
    if (!player_) return;
    auto& input_manager = context_.getInputManager();
    auto* pc = player_->getComponent<engine::component::PhysicsComponent>();
    // ... (与上一课TestObject相同的控制逻辑) ...
}
// ...
```

### 重构清单

| 操作 | 说明 |
|------|------|
| ✅ **删除** `createTestObject()` | 不再手动创建测试对象 |
| ✅ **修改** `init()` | 通过 `findGameObjectByName("player")` 获取玩家 |
| ✅ **重命名** `TestObject()` → `TestPlayer()` | 更准确的命名 |
| ✅ **数据驱动** | 所有对象从 Tiled 地图加载 |

### 架构优势

```
旧方式：代码硬编码
┌────────────────┐
│ C++ 代码       │ → 创建对象
│ GameScene.cpp  │ → 设置属性
└────────────────┘ → 难以调整

新方式：数据驱动
┌────────────────┐
│ Tiled 地图     │ → 可视化编辑
│ level1.tmj     │ → 快速迭代
└────────────────┘ → 易于维护
        ↓
  LevelLoader 自动加载
```

---

## ✅ 编译与运行

编译并运行游戏。你会看到：

```
运行效果：
┌─────────────────────────┐
│  👤 ← 玩家              │
│  ↓                       │
│ 📦📦 ← 木箱障碍物       │
│                          │
│ ✅ 站在木箱上            │
│ ✅ 不再穿透              │
│ ✅ 可以跳到木箱上        │
│ ✅ 撞墙时停止            │
└─────────────────────────┘
```

**你会看到：**
- ✅ 玩家受重力下落
- ✅ 站在地面和木箱上不再穿透
- ✅ 可以跳到木箱上
- ✅ 撞到木箱侧面时停止水平移动
- ✅ 可以沿木箱边缘滑动
- ✅ 完全由 Tiled 地图配置，无需修改代码

---

## 🎯 系统架构总结

### 完整的对象碰撞流程

```
1. Tiled 编辑器
   ↓ 配置对象原型（图块集）
   ↓ 放置对象实例（地图）
2. JSON 文件
   ↓ LevelLoader 读取
3. 数据驱动加载
   ↓ getTileJsonByGid()
   ↓ getTileProperty<T>()
   ↓ getColliderRect()
4. 动态添加组件
   ↓ 根据属性配置对象
5. 物理引擎更新
   ↓ checkObjectCollisions()
6. 碰撞分类
   ↓ 判断对象标签
7. MTV 算法解析
   ↓ resolveSolidObjectCollisions()
8. 位置校正 + 速度清零
```

### 核心成就

我们成功地：

1. ✅ **属性系统**：区分地图级和图块集级属性
2. ✅ **通用解析**：模板函数读取任意类型属性
3. ✅ **数据驱动**：完全由 Tiled 配置游戏对象
4. ✅ **MTV 算法**：优雅的对象间碰撞解析
5. ✅ **智能分类**：根据标签自动分派碰撞处理
6. ✅ **无缝集成**：瓦片碰撞 + 对象碰撞统一管理

### MTV vs 轴分离对比

| 特性 | 瓦片碰撞（轴分离） | 对象碰撞（MTV） |
|------|-------------------|-----------------|
| **适用场景** | 动态物体 vs 静态网格 | 动态物体 vs 任意对象 |
| **检测方式** | 预测位置 + 分轴检测 | 重叠检测 + 最小平移 |
| **效率** | O(1) - 极快 | O(n²) - 适用于少量对象 |
| **效果** | 精确对齐网格 | 自然的滑动效果 |

### 性能特点

```
碰撞解析性能：
┌─────────────────────────────┐
│ 瓦片碰撞：                  │
│   时间复杂度：O(1)          │
│   每物体检测：≈4 个瓦片      │
│   适用场景：大型地图         │
├─────────────────────────────┤
│ 对象碰撞：                  │
│   时间复杂度：O(n²)         │
│   检测次数：n(n-1)/2         │
│   适用场景：少量动态对象     │
└─────────────────────────────┘
```

---

## 📚 总结

我们已经实现了对象间的碰撞解析！

**关键要点：**
- 🏷️ 理解对象属性的二级结构（地图 + 图块集）
- 📖 实现通用的属性解析系统
- 🧩 数据驱动的组件自动配置
- 🎯 MTV 算法优雅解决对象碰撞
- 🏗️ 智能的碰撞分类机制
- ⚡ 完全由 Tiled 驱动的场景创建

> 💡 **设计哲学**：通过数据驱动设计，我们将游戏逻辑从代码中分离出来，放入关卡编辑器。设计师可以自由调整对象属性、放置位置，无需修改任何代码。这是现代游戏引擎的核心理念之一！

---

## 🚀 下一步展望

现在我们的物体可以与地图和其他对象正确交互了！但还有一些高级特性等待实现：

- ❓ 如何实现单向平台（只能从下方穿过）？
- ❓ 如何支持斜坡（倾斜的地形）？
- ❓ 如何优化斜坡上的移动体验？

下一课，我们将实现 **瓦片层单向平台与斜坡**：

- 🪜 单向平台（可穿过的平台）
- ⛰️ 斜坡地形
- 🎮 自然的斜坡移动

让我们继续完善这个物理世界！🎮🌟