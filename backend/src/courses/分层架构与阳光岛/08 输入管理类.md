# è¾“å…¥ç®¡ç†ç±»

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- Bç«™åµŒå…¥ï¼šä½¿ç”¨ https æ˜ç¡®åè®®ï¼ˆé¿å… file:// æˆ– http å¯¼è‡´è¢«æµè§ˆå™¨æ‹¦æˆªï¼‰ -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1ts3FzxEje&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[åœ¨ Bilibili ä¸Šè§‚çœ‹](https://www.bilibili.com/video/BV1ts3FzxEje)

## ğŸ“Œ é—®é¢˜èƒŒæ™¯

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»èƒ½æ¸²æŸ“å‡ºæ¼‚äº®çš„ç”»é¢ï¼Œä½†æ¸¸æˆä¸–ç•Œè¿˜æ˜¯é™æ‚„æ‚„çš„â€”â€”æˆ‘ä»¬æ— æ³•ä¸ä¹‹äº¤äº’ã€‚æ˜¯æ—¶å€™æ‰“ç ´è¿™ç‰‡æ²‰å¯‚ï¼Œä¸ºå¼•æ“è£…ä¸Š **"ç¥ç»ç³»ç»Ÿ"** äº†ã€‚æœ¬èŠ‚è¯¾ï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªå¼ºå¤§ä¸”é«˜åº¦å¯é…ç½®çš„è¾“å…¥ç®¡ç†æ¨¡å— `InputManager`ã€‚

### è®¾è®¡ç›®æ ‡

<img src="https://theorhythm.top/gamedev/SL/SL.034.webp" alt="è¾“å…¥ç®¡ç†ç±»1" style="display: block; margin: auto; width: 700px;" />
<img src="https://theorhythm.top/gamedev/SL/SL.035.webp" alt="è¾“å…¥ç®¡ç†ç±»2" style="display: block; margin: auto; width: 700px;" />

æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å»ºç«‹ä¸€ä¸ªç³»ç»Ÿï¼Œå®ƒèƒ½ï¼š

- ğŸ¯ **æŠ½è±¡åŒ–è¾“å…¥**ï¼šæ¸¸æˆé€»è¾‘ä¸åº”è¯¥å…³å¿ƒç©å®¶æŒ‰çš„æ˜¯"Wé”®"è¿˜æ˜¯"æ‰‹æŸ„ä¸Šæ‘‡æ†"ã€‚å®ƒåªå…³å¿ƒ"å‘ä¸Šç§»åŠ¨"è¿™ä¸ªåŠ¨ä½œï¼ˆActionï¼‰ã€‚æˆ‘ä»¬å°†æŠŠå…·ä½“çš„ç‰©ç†æŒ‰é”®ï¼ˆé”®ç›˜ã€é¼ æ ‡ã€æ‰‹æŸ„ï¼‰æ˜ å°„åˆ°æŠ½è±¡çš„æ¸¸æˆåŠ¨ä½œä¸Š
- âš™ï¸ **æ˜“äºé…ç½®**ï¼šæ‰€æœ‰çš„æŒ‰é”®æ˜ å°„éƒ½å°†å®šä¹‰åœ¨æˆ‘ä»¬çš„ `config.json` æ–‡ä»¶ä¸­ï¼Œç©å®¶ï¼ˆæˆ–å¼€å‘è€…ï¼‰å¯ä»¥è½»æ¾ä¿®æ”¹é”®ä½ï¼Œè€Œæ— éœ€æ”¹åŠ¨ä¸€è¡Œä»£ç 
- ğŸ“Š **ç²¾ç¡®çš„çŠ¶æ€ç®¡ç†**ï¼šåŒºåˆ†"åˆšåˆšæŒ‰ä¸‹"ã€"æŒç»­æŒ‰ä½"å’Œ"åˆšåˆšé‡Šæ”¾"è¿™ä¸‰ç§çŠ¶æ€å¯¹äºå®ç°æŸäº›æ¸¸æˆæœºåˆ¶ï¼ˆå¦‚è·³è·ƒã€è“„åŠ›æ”»å‡»ï¼‰è‡³å…³é‡è¦

> ğŸ’¡ æˆ‘ä»¬å°†åˆ†ä¸¤æ­¥æ¥å®Œæˆè¿™ä¸ªæ¨¡å—ï¼šé¦–å…ˆå®ç°ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ç‰ˆæœ¬ï¼Œç„¶ååˆ©ç”¨ç°ä»£ C++ çš„ç‰¹æ€§å¯¹å…¶è¿›è¡Œä¸€æ¬¡ä¼˜é›…çš„é‡æ„ã€‚

---

## ç¬¬ä¸€æ­¥ï¼šæ„å»ºåŠŸèƒ½å®Œå¤‡çš„ InputManager

### 1. æ¶æ„è®¾è®¡

`InputManager` å°†æˆä¸ºæˆ‘ä»¬å¤„ç†æ‰€æœ‰è¾“å…¥çš„å”¯ä¸€å…¥å£ã€‚å®ƒçš„æ ¸å¿ƒå·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š

#### å·¥ä½œæµç¨‹

| é˜¶æ®µ | è¯´æ˜ |
|------|------|
| **åˆå§‹åŒ–** | åœ¨æ„é€ æ—¶ï¼Œä» `Config` æ¨¡å—è¯»å– `input_mappings`ã€‚ç„¶åï¼Œå®ƒä¼šå»ºç«‹ä¸¤ä¸ªåå‘æ˜ å°„è¡¨ï¼šä¸€ä¸ªæ˜¯ä» `SDL_Scancode`ï¼ˆé”®ç›˜æŒ‰é”®ï¼‰åˆ°åŠ¨ä½œåˆ—è¡¨ï¼Œå¦ä¸€ä¸ªæ˜¯ä» `Uint8`ï¼ˆé¼ æ ‡æŒ‰é’®ï¼‰åˆ°åŠ¨ä½œåˆ—è¡¨ |
| **æ¯å¸§æ›´æ–°** | åœ¨æ¸¸æˆä¸»å¾ªç¯çš„æœ€å¼€å§‹è¢«è°ƒç”¨ã€‚å®ƒä¼šå¤„ç†æ‰€æœ‰ SDL äº‹ä»¶é˜Ÿåˆ—ä¸­çš„äº‹ä»¶ï¼ˆå¦‚ `SDL_EVENT_KEY_DOWN`ï¼‰ï¼Œå¹¶æ®æ­¤æ›´æ–°å†…éƒ¨æ‰€æœ‰åŠ¨ä½œçš„çŠ¶æ€ |
| **çŠ¶æ€æŸ¥è¯¢** | æä¾› `isActionDown()`, `isActionPressed()`, `isActionReleased()` ç­‰æ¥å£ï¼Œä¾›æ¸¸æˆé€»è¾‘çš„å…¶ä»–éƒ¨åˆ†æŸ¥è¯¢ç‰¹å®šåŠ¨ä½œçš„å½“å‰çŠ¶æ€ |

---

### 2. åŠ¨ä½œçŠ¶æ€æœº ActionState

ä¸ºäº†ç²¾ç¡®æ•æ‰æŒ‰é”®çš„æ¯ä¸€ä¸ªç¬é—´ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªæšä¸¾ç±» `ActionState`ï¼š

```cpp
enum class ActionState {
    INACTIVE,              // æœªæ¿€æ´»
    PRESSED_THIS_FRAME,    // åœ¨å½“å‰å¸§åˆšåˆšè¢«æŒ‰ä¸‹
    HELD_DOWN,             // åœ¨å‰ä¸€å¸§è¢«æŒ‰ä¸‹åï¼ŒæŒç»­æŒ‰ä½
    RELEASED_THIS_FRAME    // åœ¨å½“å‰å¸§åˆšåˆšè¢«é‡Šæ”¾
};
```

#### çŠ¶æ€è½¬æ¢è¯´æ˜

`InputManager::update()` æ–¹æ³•ä¼šè´Ÿè´£åœ¨è¿™ä¸ªçŠ¶æ€æœºä¹‹é—´è¿›è¡Œæ­£ç¡®çš„è½¬æ¢ã€‚ä¾‹å¦‚ï¼Œä¸Šä¸€å¸§æ˜¯ `PRESSED_THIS_FRAME` çš„åŠ¨ä½œï¼Œå¦‚æœåœ¨æœ¬å¸§æ²¡æœ‰æ”¶åˆ°"é‡Šæ”¾"äº‹ä»¶ï¼Œå®ƒçš„çŠ¶æ€å°±ä¼šè‡ªåŠ¨å˜ä¸º `HELD_DOWN`ã€‚

```mermaid
stateDiagram-v2
    [*] --> INACTIVE
    INACTIVE --> PRESSED_THIS_FRAME: æŒ‰é”®æŒ‰ä¸‹
    PRESSED_THIS_FRAME --> HELD_DOWN: æŒç»­æŒ‰ä½
    PRESSED_THIS_FRAME --> RELEASED_THIS_FRAME: ç«‹å³é‡Šæ”¾
    HELD_DOWN --> HELD_DOWN: ç»§ç»­æŒ‰ä½
    HELD_DOWN --> RELEASED_THIS_FRAME: æŒ‰é”®é‡Šæ”¾
    RELEASED_THIS_FRAME --> INACTIVE: ä¸‹ä¸€å¸§
    RELEASED_THIS_FRAME --> PRESSED_THIS_FRAME: å¿«é€Ÿé‡æŒ‰
```

---

### 3. å®ç° InputManager

æˆ‘ä»¬åœ¨ `src/engine/` ä¸‹åˆ›å»º `input` ç›®å½•ï¼Œå¹¶æ·»åŠ  `input_manager.h` å’Œ `input_manager.cpp`ã€‚

#### input_manager.h

```cpp
#pragma once
#include <string>
#include <unordered_map>
#include <vector>
#include <SDL3/SDL_render.h>
#include <glm/vec2.hpp>

namespace engine::core {
    class Config;
}

namespace engine::input {

enum class ActionState {
    INACTIVE,           ///< @brief åŠ¨ä½œæœªæ¿€æ´»
    PRESSED_THIS_FRAME, ///< @brief åŠ¨ä½œåœ¨æœ¬å¸§åˆšåˆšè¢«æŒ‰ä¸‹
    HELD_DOWN,          ///< @brief åŠ¨ä½œè¢«æŒç»­æŒ‰ä¸‹
    RELEASED_THIS_FRAME ///< @brief åŠ¨ä½œåœ¨æœ¬å¸§åˆšåˆšè¢«é‡Šæ”¾
};

class InputManager final {
private:
    SDL_Renderer* sdl_renderer_;                                            ///< @brief ç”¨äºè·å–é€»è¾‘åæ ‡çš„ SDL_Renderer æŒ‡é’ˆ
    std::unordered_map<std::string, std::vector<std::string>> actions_to_keyname_map_;      ///< @brief å­˜å‚¨åŠ¨ä½œåç§°åˆ°æŒ‰é”®åç§°åˆ—è¡¨çš„æ˜ å°„
    std::unordered_map<SDL_Scancode, std::vector<std::string>> scancode_to_actions_map_;///< @brief ä»é”®ç›˜ï¼ˆScancodeï¼‰åˆ°å…³è”çš„åŠ¨ä½œåç§°åˆ—è¡¨
    std::unordered_map<Uint8, std::vector<std::string>> mouse_button_to_actions_map_;   ///< @brief ä»é¼ æ ‡æŒ‰é’® (Uint8) åˆ°å…³è”çš„åŠ¨ä½œåç§°åˆ—è¡¨

    std::unordered_map<std::string, ActionState> action_states_;    ///< @brief å­˜å‚¨æ¯ä¸ªåŠ¨ä½œçš„å½“å‰çŠ¶æ€

    bool should_quit_ = false;                                      ///< @brief é€€å‡ºæ ‡å¿—
    glm::vec2 mouse_position_;                                      ///< @brief é¼ æ ‡ä½ç½® (é’ˆå¯¹å±å¹•åæ ‡)

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param sdl_renderer æŒ‡å‘ SDL_Renderer çš„æŒ‡é’ˆ
     * @param config é…ç½®å¯¹è±¡
     * @throws std::runtime_error å¦‚æœä»»ä¸€æŒ‡é’ˆä¸º nullptrã€‚
     */
    InputManager(SDL_Renderer* sdl_renderer, const engine::core::Config* config);

    void update();                                    ///< @brief æ›´æ–°è¾“å…¥çŠ¶æ€ï¼Œæ¯è½®å¾ªç¯æœ€å…ˆè°ƒç”¨


    // åŠ¨ä½œçŠ¶æ€æ£€æŸ¥
    bool isActionDown(const std::string& action_name) const;        ///< @brief åŠ¨ä½œå½“å‰æ˜¯å¦è§¦å‘ (æŒç»­æŒ‰ä¸‹æˆ–æœ¬å¸§æŒ‰ä¸‹)
    bool isActionPressed(const std::string& action_name) const;     ///< @brief åŠ¨ä½œæ˜¯å¦åœ¨æœ¬å¸§åˆšåˆšæŒ‰ä¸‹
    bool isActionReleased(const std::string& action_name) const;    ///< @brief åŠ¨ä½œæ˜¯å¦åœ¨æœ¬å¸§åˆšåˆšé‡Šæ”¾

    bool shouldQuit() const;                                         ///< @brief æŸ¥è¯¢é€€å‡ºçŠ¶æ€
    void setShouldQuit(bool should_quit);                            ///< @brief è®¾ç½®é€€å‡ºçŠ¶æ€

    glm::vec2 getMousePosition() const;                              ///< @brief è·å–é¼ æ ‡ä½ç½® ï¼ˆå±å¹•åæ ‡ï¼‰
    glm::vec2 getLogicalMousePosition() const;                       ///< @brief è·å–é¼ æ ‡ä½ç½® ï¼ˆé€»è¾‘åæ ‡ï¼‰

private:
    void processEvent(const SDL_Event& event);                      ///< @brief å¤„ç† SDL äº‹ä»¶ï¼ˆå°†æŒ‰é”®è½¬æ¢ä¸ºåŠ¨ä½œçŠ¶æ€ï¼‰
    void initializeMappings(const engine::core::Config* config);                            ///< @brief æ ¹æ® Configé…ç½®åˆå§‹åŒ–æ˜ å°„è¡¨
    
    void updateActionState(const std::string& action_name, bool is_input_active, bool is_repeat_event); ///< @brief è¾…åŠ©æ›´æ–°åŠ¨ä½œçŠ¶æ€
    SDL_Scancode scancodeFromString(const std::string& key_name);                           ///< @brief å°†å­—ç¬¦ä¸²é”®åè½¬æ¢ä¸º SDL_Scancode
    Uint8 mouseButtonUint8FromString(const std::string& button_name);                       ///< @brief å°†å­—ç¬¦ä¸²æŒ‰é’®åè½¬æ¢ä¸º SDL_Button
};

} // namespace engine::input 
```

å®šä¹‰äº† `InputManager` çš„æ¥å£ï¼ŒåŒ…æ‹¬çŠ¶æ€æŸ¥è¯¢å‡½æ•°å’Œç§æœ‰çš„æ˜ å°„è¡¨ã€‚

#### input_manager.cpp

```cpp
#include "input_manager.h"
#include "../core/config.h"
#include <stdexcept>
#include <SDL3/SDL.h>
#include <spdlog/spdlog.h>
#include <glm/vec2.hpp>


namespace engine::input {

InputManager::InputManager(SDL_Renderer* sdl_renderer, const engine::core::Config* config): sdl_renderer_(sdl_renderer) {
    if (!sdl_renderer_) {
        spdlog::error("è¾“å…¥ç®¡ç†å™¨: SDL_Renderer ä¸ºç©ºæŒ‡é’ˆ");
        throw std::runtime_error("è¾“å…¥ç®¡ç†å™¨: SDL_Renderer ä¸ºç©ºæŒ‡é’ˆ");
    }
    initializeMappings(config);
    // è·å–åˆå§‹é¼ æ ‡ä½ç½®
    float x, y;
    SDL_GetMouseState(&x, &y);
    mouse_position_ = {x, y};
    spdlog::trace("åˆå§‹é¼ æ ‡ä½ç½®: ({}, {})", mouse_position_.x, mouse_position_.y);
}

// --- æ›´æ–°å’Œäº‹ä»¶å¤„ç† ---

void InputManager::update() {
    // 1. æ ¹æ®ä¸Šä¸€å¸§çš„å€¼æ›´æ–°é»˜è®¤çš„åŠ¨ä½œçŠ¶æ€
    for (auto& [action_name, state] : action_states_) {
        if (state == ActionState::PRESSED_THIS_FRAME) {
            state = ActionState::HELD_DOWN;                 // å½“æŸä¸ªé”®æŒ‰ä¸‹ä¸åŠ¨æ—¶ï¼Œå¹¶ä¸ä¼šç”ŸæˆSDL_Eventã€‚
        } else if (state == ActionState::RELEASED_THIS_FRAME) {
            state = ActionState::INACTIVE;
        }
    }

    // 2. å¤„ç†æ‰€æœ‰å¾…å¤„ç†çš„ SDL äº‹ä»¶ (è¿™å°†è®¾å®š action_states_ çš„å€¼)
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        processEvent(event);
    }
}

void InputManager::processEvent(const SDL_Event& event) {
    switch (event.type) {
        case SDL_EVENT_KEY_DOWN:
        case SDL_EVENT_KEY_UP: {
            SDL_Scancode scancode = event.key.scancode;     // è·å–æŒ‰é”®çš„scancode
            bool is_down = event.key.down; 
            bool is_repeat = event.key.repeat;

            auto it = scancode_to_actions_map_.find(scancode);
            if (it != scancode_to_actions_map_.end()) {     // å¦‚æœæŒ‰é”®æœ‰å¯¹åº”çš„action
                const std::vector<std::string>& associated_actions = it->second;
                for (const std::string& action_name : associated_actions) {
                    updateActionState(action_name, is_down, is_repeat); // æ›´æ–°actionçŠ¶æ€
                }
            }
            break;
        }
        case SDL_EVENT_MOUSE_BUTTON_DOWN:
        case SDL_EVENT_MOUSE_BUTTON_UP: {
            Uint8 button = event.button.button;              // è·å–é¼ æ ‡æŒ‰é’®
            bool is_down = event.button.down;
            auto it = mouse_button_to_actions_map_.find(button);
            if (it != mouse_button_to_actions_map_.end()) {     // å¦‚æœé¼ æ ‡æŒ‰é’®æœ‰å¯¹åº”çš„action
                const std::vector<std::string>& associated_actions = it->second;
                for (const std::string& action_name : associated_actions) {
                    // é¼ æ ‡äº‹ä»¶ä¸è€ƒè™‘repeat, æ‰€ä»¥ç¬¬ä¸‰ä¸ªå‚æ•°ä¼ false
                    updateActionState(action_name, is_down, false); // æ›´æ–°actionçŠ¶æ€
                }
            }
            // åœ¨ç‚¹å‡»æ—¶æ›´æ–°é¼ æ ‡ä½ç½®
            mouse_position_ = {event.button.x, event.button.y};
            break;
        }
        case SDL_EVENT_MOUSE_MOTION:        // å¤„ç†é¼ æ ‡è¿åŠ¨
            mouse_position_ = {event.motion.x, event.motion.y};
            break;
        case SDL_EVENT_QUIT:
            should_quit_ = true;
            break;
        default:
            break;
    }
}

// --- çŠ¶æ€æŸ¥è¯¢æ–¹æ³• ---

bool InputManager::isActionDown(const std::string& action_name) const {
    // C++17 å¼•å…¥çš„ â€œå¸¦æœ‰åˆå§‹åŒ–è¯­å¥çš„ if è¯­å¥â€
    if (auto it = action_states_.find(action_name); it != action_states_.end()) {
        return it->second == ActionState::PRESSED_THIS_FRAME || it->second == ActionState::HELD_DOWN;
    }
    return false;
}

bool InputManager::isActionPressed(const std::string& action_name) const {
    if (auto it = action_states_.find(action_name); it != action_states_.end()) {
        return it->second == ActionState::PRESSED_THIS_FRAME;
    }
    return false;
}

bool InputManager::isActionReleased(const std::string& action_name) const {
    if (auto it = action_states_.find(action_name); it != action_states_.end()) {
        return it->second == ActionState::RELEASED_THIS_FRAME;
    }
    return false;
}

bool InputManager::shouldQuit() const {
    return should_quit_;
}

void InputManager::setShouldQuit(bool should_quit)
{
    should_quit_ = should_quit;
}

glm::vec2 InputManager::getMousePosition() const
{
    return mouse_position_;
}

glm::vec2 InputManager::getLogicalMousePosition() const
{
    glm::vec2 logical_pos;
    // é€šè¿‡çª—å£åæ ‡è·å–æ¸²æŸ“åæ ‡ï¼ˆé€»è¾‘åæ ‡ï¼‰
    SDL_RenderCoordinatesFromWindow(sdl_renderer_, mouse_position_.x, mouse_position_.y, &logical_pos.x, &logical_pos.y);
    return logical_pos;
}

// --- åˆå§‹åŒ–è¾“å…¥æ˜ å°„ ---

void InputManager::initializeMappings(const engine::core::Config* config) {
    spdlog::trace("åˆå§‹åŒ–è¾“å…¥æ˜ å°„...");
    if (!config) {
        spdlog::error("è¾“å…¥ç®¡ç†å™¨: Config ä¸ºç©ºæŒ‡é’ˆ");
        throw std::runtime_error("è¾“å…¥ç®¡ç†å™¨: Config ä¸ºç©ºæŒ‡é’ˆ");
    }
    actions_to_keyname_map_ = config->input_mappings_;      // è·å–é…ç½®ä¸­çš„è¾“å…¥æ˜ å°„ï¼ˆåŠ¨ä½œ -> æŒ‰é”®åç§°ï¼‰
    scancode_to_actions_map_.clear();
    mouse_button_to_actions_map_.clear();
    action_states_.clear();

    // å¦‚æœé…ç½®ä¸­æ²¡æœ‰å®šä¹‰é¼ æ ‡æŒ‰é’®åŠ¨ä½œ(é€šå¸¸ä¸éœ€è¦é…ç½®),åˆ™æ·»åŠ é»˜è®¤æ˜ å°„, ç”¨äº UI
    if (actions_to_keyname_map_.find("MouseLeftClick") == actions_to_keyname_map_.end()) {
         spdlog::debug("é…ç½®ä¸­æ²¡æœ‰å®šä¹‰ 'MouseLeftClick' åŠ¨ä½œ,æ·»åŠ é»˜è®¤æ˜ å°„åˆ° 'MouseLeft'.");
         actions_to_keyname_map_["MouseLeftClick"] = {"MouseLeft"};     // å¦‚æœç¼ºå¤±åˆ™æ·»åŠ é»˜è®¤æ˜ å°„
    }
     if (actions_to_keyname_map_.find("MouseRightClick") == actions_to_keyname_map_.end()) {
         spdlog::debug("é…ç½®ä¸­æ²¡æœ‰å®šä¹‰ 'MouseRightClick' åŠ¨ä½œ,æ·»åŠ é»˜è®¤æ˜ å°„åˆ° 'MouseRight'.");
         actions_to_keyname_map_["MouseRightClick"] = {"MouseRight"};   // å¦‚æœç¼ºå¤±åˆ™æ·»åŠ é»˜è®¤æ˜ å°„
    }
    // éå† åŠ¨ä½œ -> æŒ‰é”®åç§° çš„æ˜ å°„
    for (const auto& [action_name, key_names] : actions_to_keyname_map_) {
        // æ¯ä¸ªåŠ¨ä½œå¯¹åº”ä¸€ä¸ªåŠ¨ä½œçŠ¶æ€ï¼Œåˆå§‹åŒ–ä¸º INACTIVE
        action_states_[action_name] = ActionState::INACTIVE;
        spdlog::trace("æ˜ å°„åŠ¨ä½œ: {}", action_name);
        // è®¾ç½® "æŒ‰é”® -> åŠ¨ä½œ" çš„æ˜ å°„
        for (const std::string& key_name : key_names) {
            SDL_Scancode scancode = scancodeFromString(key_name);       // å°è¯•æ ¹æ®æŒ‰é”®åç§°è·å–scancode
            Uint8 mouse_button = mouseButtonUint8FromString(key_name);  // å°è¯•æ ¹æ®æŒ‰é”®åç§°è·å–é¼ æ ‡æŒ‰é’®
            // æœªæ¥å¯æ·»åŠ å…¶å®ƒè¾“å…¥ç±»å‹ ...

            if (scancode != SDL_SCANCODE_UNKNOWN) {      // å¦‚æœscancodeæœ‰æ•ˆ,åˆ™å°†actionæ·»åŠ åˆ°scancode_to_actions_map_ä¸­
                scancode_to_actions_map_[scancode].push_back(action_name);     
                spdlog::trace("  æ˜ å°„æŒ‰é”®: {} (Scancode: {}) åˆ°åŠ¨ä½œ: {}", key_name, static_cast<int>(scancode), action_name);
            } else if (mouse_button != 0) {             // å¦‚æœé¼ æ ‡æŒ‰é’®æœ‰æ•ˆ,åˆ™å°†actionæ·»åŠ åˆ°mouse_button_to_actions_map_ä¸­
                mouse_button_to_actions_map_[mouse_button].push_back(action_name); 
                spdlog::trace("  æ˜ å°„é¼ æ ‡æŒ‰é’®: {} (Button ID: {}) åˆ°åŠ¨ä½œ: {}", key_name, static_cast<int>(mouse_button), action_name);
                // else if: æœªæ¥å¯æ·»åŠ å…¶å®ƒè¾“å…¥ç±»å‹ ...
            } else {
                spdlog::warn("è¾“å…¥æ˜ å°„è­¦å‘Š: æœªçŸ¥é”®æˆ–æŒ‰é’®åç§° '{}' ç”¨äºåŠ¨ä½œ '{}'.", key_name, action_name);
            }
        }
    }
    spdlog::trace("è¾“å…¥æ˜ å°„åˆå§‹åŒ–å®Œæˆ.");
}

// --- å·¥å…·å‡½æ•° ---
// å°†å­—ç¬¦ä¸²åç§°è½¬æ¢ä¸º SDL_Scancode
SDL_Scancode InputManager::scancodeFromString(const std::string& key_name) {
    return SDL_GetScancodeFromName(key_name.c_str());
}

// å°†é¼ æ ‡æŒ‰é’®åç§°å­—ç¬¦ä¸²è½¬æ¢ä¸º SDL æŒ‰é’® Uint8 å€¼
Uint8 InputManager::mouseButtonUint8FromString(const std::string& button_name) {
    if (button_name == "MouseLeft") return SDL_BUTTON_LEFT;
    if (button_name == "MouseMiddle") return SDL_BUTTON_MIDDLE;
    if (button_name == "MouseRight") return SDL_BUTTON_RIGHT;
    // SDL è¿˜å®šä¹‰äº† SDL_BUTTON_X1 å’Œ SDL_BUTTON_X2
    if (button_name == "MouseX1") return SDL_BUTTON_X1;
    if (button_name == "MouseX2") return SDL_BUTTON_X2;
    return 0; // 0 ä¸æ˜¯æœ‰æ•ˆçš„æŒ‰é’®å€¼ï¼Œè¡¨ç¤ºæ— æ•ˆ
}

void InputManager::updateActionState(const std::string& action_name, bool is_input_active, bool is_repeat_event) {
    auto it = action_states_.find(action_name);
    if (it == action_states_.end()) {
        spdlog::warn("å°è¯•æ›´æ–°æœªæ³¨å†Œçš„åŠ¨ä½œçŠ¶æ€: {}", action_name);
        return;
    }

    if (is_input_active) { // è¾“å…¥è¢«æ¿€æ´» (æŒ‰ä¸‹)
        if (is_repeat_event) {
            it->second = ActionState::HELD_DOWN; 
        } else {            // éé‡å¤çš„æŒ‰ä¸‹äº‹ä»¶
            it->second = ActionState::PRESSED_THIS_FRAME;
        }
    } else { // è¾“å…¥è¢«é‡Šæ”¾ (æ¾å¼€)
        it->second = ActionState::RELEASED_THIS_FRAME;
    }
}

} // namespace engine::input 
```

> ğŸ¯ **é‡è¦åŠŸèƒ½**ï¼šç”±äºæˆ‘ä»¬ä½¿ç”¨äº†é€»è¾‘åˆ†è¾¨ç‡ï¼Œé¼ æ ‡çš„ç‰©ç†çª—å£åæ ‡éœ€è¦é€šè¿‡ `SDL_RenderCoordinatesFromWindow` è½¬æ¢æˆæ¸¸æˆä¸–ç•Œä¸­çš„é€»è¾‘åæ ‡ï¼Œè¿™å¯¹äº UI äº¤äº’è‡³å…³é‡è¦ã€‚

---

### 4. é›†æˆåˆ° GameApp

<img src="https://theorhythm.top/gamedev/SL/SL.036.webp" alt="è¾“å…¥ç®¡ç†ç±»3" style="display: block; margin: auto; width: 700px;" />

#### åˆå§‹åŒ–

```cpp
// game_app.h
class InputManager;

class GameApp final {
private:
    std::unique_ptr<engine::input::InputManager> input_manager_;
    
    [[nodiscard]] bool initInputManager();
};
```

```cpp
// game_app.cpp
bool GameApp::initInputManager()
{
    try {
        input_manager_ = std::make_unique<engine::input::InputManager>(sdl_renderer_, config_.get());
    } catch (const std::exception& e) {
        spdlog::error("åˆå§‹åŒ–è¾“å…¥ç®¡ç†å™¨å¤±è´¥: {}", e.what());
        return false;
    }
    spdlog::trace("è¾“å…¥ç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸã€‚");
    return true;
}
```

åœ¨ `GameApp` ä¸­æ·»åŠ  `initInputManager()`ï¼Œåˆ›å»º `InputManager` çš„å®ä¾‹ã€‚

#### æ›´æ–°

```cpp
void GameApp::run() {
    // ...
    while (is_running_) {
        time_->update();
        float delta_time = time_->getDeltaTime();
        input_manager_->update();   // æ¯å¸§é¦–å…ˆæ›´æ–°è¾“å…¥ç®¡ç†å™¨
        
        handleEvents();
        update(delta_time);
        render();

        // spdlog::info("delta_time: {}", delta_time);
    }
    close();
}
```

åœ¨ `GameApp::run()` çš„ä¸»å¾ªç¯ä¸Šæ–¹è°ƒç”¨ `input_manager_->update()`ã€‚

#### äº‹ä»¶å¤„ç†

```cpp
void GameApp::handleEvents() {
    if (input_manager_->shouldQuit()) {
        spdlog::trace("GameApp æ”¶åˆ°æ¥è‡ª InputManager çš„é€€å‡ºè¯·æ±‚ã€‚");
        is_running_ = false;
        return;
    }

    testInputManager();
}
```

æ”¹é€  `GameApp::handleEvents()`ã€‚ç°åœ¨å®ƒä¸å†éœ€è¦è‡ªå·±çš„ `SDL_PollEvent` å¾ªç¯ï¼Œè€Œæ˜¯ç›´æ¥å‘ `InputManager` æŸ¥è¯¢æ˜¯å¦åº”è¯¥é€€å‡ºã€‚

#### æµ‹è¯•

```cpp
void GameApp::testInputManager()
{
    std::vector<std::string> actions = {
        "move_up",
        "move_down",
        "move_left",
        "move_right",
        "jump",
        "attack",
        "pause",
        "MouseLeftClick",
        "MouseRightClick"
    };

    for (const auto& action : actions) {
        if (input_manager_->isActionPressed(action)) {
            spdlog::info(" {} æŒ‰ä¸‹ ", action);
        }
        if (input_manager_->isActionReleased(action)) {
            spdlog::info(" {} æŠ¬èµ· ", action);
        }
        if (input_manager_->isActionDown(action)) {
            spdlog::info(" {} æŒ‰ä¸‹ä¸­ ", action);
        }
    }
}
```

æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª `testInputManager()` å‡½æ•°ï¼Œå®ƒä¼šæ£€æŸ¥ä¸€ç³»åˆ—åŠ¨ä½œçš„çŠ¶æ€ï¼Œå¹¶å°†ç»“æœæ‰“å°åˆ°æ§åˆ¶å°ï¼Œä»¥ä¾¿æˆ‘ä»¬éªŒè¯ç³»ç»Ÿæ˜¯å¦æ­£å¸¸å·¥ä½œã€‚

#### âœ… ç¼–è¯‘ä¸è¿è¡Œ

ç¼–è¯‘å¹¶è¿è¡Œã€‚ç°åœ¨ï¼Œå½“ä½ æŒ‰ä¸‹åœ¨ `config.json` ä¸­å®šä¹‰çš„æŒ‰é”®æ—¶ï¼Œä½ åº”è¯¥èƒ½åœ¨æ§åˆ¶å°çœ‹åˆ°å¯¹åº”çš„åŠ¨ä½œçŠ¶æ€ï¼ˆæŒ‰ä¸‹ã€æŠ¬èµ·ã€æŒ‰ä½ä¸­ï¼‰è¢«æ‰“å°å‡ºæ¥ã€‚

---

## ç¬¬äºŒæ­¥ï¼šä½¿ç”¨ std::variant è¿›è¡Œé‡æ„

### ğŸ¤” ä¸ºä»€ä¹ˆè¦é‡æ„ï¼Ÿ

æˆ‘ä»¬ç¬¬ä¸€ç‰ˆçš„å®ç°æ˜¯æœ‰æ•ˆçš„ï¼Œä½†å­˜åœ¨ä¸€ä¸ªè®¾è®¡ä¸Šçš„å°ç‘•ç–µï¼šæˆ‘ä»¬ç”¨äº†ä¸¤ä¸ªç‹¬ç«‹çš„æ˜ å°„è¡¨æ¥å¤„ç†é”®ç›˜å’Œé¼ æ ‡è¾“å…¥ã€‚

```cpp
// æ—§ç‰ˆ - ä¸å¤Ÿä¼˜é›…
std::unordered_map<SDL_Scancode, ...> scancode_to_actions_map_;
std::unordered_map<Uint8, ...> mouse_button_to_actions_map_;
```

**é—®é¢˜**ï¼šå¦‚æœæœªæ¥æˆ‘ä»¬è¦åŠ å…¥æ‰‹æŸ„æ”¯æŒï¼Œå°±å¾—å†åŠ ç¬¬ä¸‰ä¸ªæ˜ å°„è¡¨ã€‚è¿™ä¸ç¬¦åˆ"å¼€æ”¾-å°é—­åŸåˆ™"ï¼Œæ‰©å±•æ€§è¾ƒå·®ã€‚

> ğŸ’¡ **C++17 çš„è§£å†³æ–¹æ¡ˆ**ï¼š`std::variant` æ˜¯ä¸€ä¸ªç±»å‹å®‰å…¨çš„è”åˆä½“ï¼Œå¯ä»¥å­˜å‚¨å¤šç§ä¸åŒç±»å‹çš„å€¼ã€‚æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥åˆ›å»ºä¸€ä¸ªç»Ÿä¸€çš„æ˜ å°„è¡¨ã€‚

---

### æ”¹è¿›å®ç°

#### input_manager.hï¼ˆé‡æ„ç‰ˆï¼‰

```cpp
#pragma once
#include <variant>
#include <unordered_map>

namespace engine::input {

// å®šä¹‰è¾“å…¥é”®çš„å˜ä½“ç±»å‹
using InputKey = std::variant<SDL_Scancode, Uint32>;

class InputManager final {
private:
    // ç»Ÿä¸€çš„æ˜ å°„è¡¨ï¼
    std::unordered_map<InputKey, std::vector<std::string>> input_to_actions_map_;
    std::unordered_map<std::string, ActionState> action_states_;
    
    bool should_quit_ = false;
};

} // namespace engine::input
```

**å…³é”®æ”¹åŠ¨**ï¼š
- ä½¿ç”¨ `std::variant<SDL_Scancode, Uint32>` å®šä¹‰ç»Ÿä¸€çš„é”®ç±»å‹
- å°†ä¸¤ä¸ªæ—§çš„æ˜ å°„è¡¨åˆå¹¶ä¸ºä¸€ä¸ª `input_to_actions_map_`

> âš ï¸ **æ³¨æ„**ï¼šSDL_MouseButtonEvent ä¸­çš„ button åœ¨ SDL3 ä¸­æ˜¯ `Uint32` ç±»å‹

#### input_manager.cppï¼ˆé‡æ„ç‰ˆï¼‰

```cpp
void InputManager::processEvent(const SDL_Event& event) {
    switch (event.type) {
        case SDL_EVENT_KEY_DOWN:
        case SDL_EVENT_KEY_UP: {
            SDL_Scancode scancode = event.key.scancode;     // è·å–æŒ‰é”®çš„scancode
            bool is_down = event.key.down; 
            bool is_repeat = event.key.repeat;

            auto it = input_to_actions_map_.find(scancode);
            if (it != input_to_actions_map_.end()) {     // å¦‚æœæŒ‰é”®æœ‰å¯¹åº”çš„action
                const std::vector<std::string>& associated_actions = it->second;
                for (const std::string& action_name : associated_actions) {
                    updateActionState(action_name, is_down, is_repeat); // æ›´æ–°actionçŠ¶æ€
                }
            }
            break;
        }
        case SDL_EVENT_MOUSE_BUTTON_DOWN:
        case SDL_EVENT_MOUSE_BUTTON_UP: {
            Uint32 button = event.button.button;              // è·å–é¼ æ ‡æŒ‰é’®
            bool is_down = event.button.down;
            auto it = input_to_actions_map_.find(button);
            if (it != input_to_actions_map_.end()) {     // å¦‚æœé¼ æ ‡æŒ‰é’®æœ‰å¯¹åº”çš„action
                const std::vector<std::string>& associated_actions = it->second;
                for (const std::string& action_name : associated_actions) {
                    // é¼ æ ‡äº‹ä»¶ä¸è€ƒè™‘repeat, æ‰€ä»¥ç¬¬ä¸‰ä¸ªå‚æ•°ä¼ false
                    updateActionState(action_name, is_down, false); // æ›´æ–°actionçŠ¶æ€
                }
            }
            // åœ¨ç‚¹å‡»æ—¶æ›´æ–°é¼ æ ‡ä½ç½®
            mouse_position_ = {event.button.x, event.button.y};
            break;
        }
        case SDL_EVENT_MOUSE_MOTION:        // å¤„ç†é¼ æ ‡è¿åŠ¨
            mouse_position_ = {event.motion.x, event.motion.y};
            break;
        case SDL_EVENT_QUIT:
            should_quit_ = true;
            break;
        default:
            break;
    }
}

void InputManager::initializeMappings(const engine::core::Config* config) {
    spdlog::trace("åˆå§‹åŒ–è¾“å…¥æ˜ å°„...");
    if (!config) {
        spdlog::error("è¾“å…¥ç®¡ç†å™¨: Config ä¸ºç©ºæŒ‡é’ˆ");
        throw std::runtime_error("è¾“å…¥ç®¡ç†å™¨: Config ä¸ºç©ºæŒ‡é’ˆ");
    }
    actions_to_keyname_map_ = config->input_mappings_;      // è·å–é…ç½®ä¸­çš„è¾“å…¥æ˜ å°„ï¼ˆåŠ¨ä½œ -> æŒ‰é”®åç§°ï¼‰
    input_to_actions_map_.clear();
    action_states_.clear();

    // å¦‚æœé…ç½®ä¸­æ²¡æœ‰å®šä¹‰é¼ æ ‡æŒ‰é’®åŠ¨ä½œ(é€šå¸¸ä¸éœ€è¦é…ç½®),åˆ™æ·»åŠ é»˜è®¤æ˜ å°„, ç”¨äº UI
    if (actions_to_keyname_map_.find("MouseLeftClick") == actions_to_keyname_map_.end()) {
         spdlog::debug("é…ç½®ä¸­æ²¡æœ‰å®šä¹‰ 'MouseLeftClick' åŠ¨ä½œ,æ·»åŠ é»˜è®¤æ˜ å°„åˆ° 'MouseLeft'.");
         actions_to_keyname_map_["MouseLeftClick"] = {"MouseLeft"};     // å¦‚æœç¼ºå¤±åˆ™æ·»åŠ é»˜è®¤æ˜ å°„
    }
     if (actions_to_keyname_map_.find("MouseRightClick") == actions_to_keyname_map_.end()) {
         spdlog::debug("é…ç½®ä¸­æ²¡æœ‰å®šä¹‰ 'MouseRightClick' åŠ¨ä½œ,æ·»åŠ é»˜è®¤æ˜ å°„åˆ° 'MouseRight'.");
         actions_to_keyname_map_["MouseRightClick"] = {"MouseRight"};   // å¦‚æœç¼ºå¤±åˆ™æ·»åŠ é»˜è®¤æ˜ å°„
    }
    // éå† åŠ¨ä½œ -> æŒ‰é”®åç§° çš„æ˜ å°„
    for (const auto& [action_name, key_names] : actions_to_keyname_map_) {
        // æ¯ä¸ªåŠ¨ä½œå¯¹åº”ä¸€ä¸ªåŠ¨ä½œçŠ¶æ€ï¼Œåˆå§‹åŒ–ä¸º INACTIVE
        action_states_[action_name] = ActionState::INACTIVE;
        spdlog::trace("æ˜ å°„åŠ¨ä½œ: {}", action_name);
        // è®¾ç½® "æŒ‰é”® -> åŠ¨ä½œ" çš„æ˜ å°„
        for (const std::string& key_name : key_names) {
            SDL_Scancode scancode = scancodeFromString(key_name);       // å°è¯•æ ¹æ®æŒ‰é”®åç§°è·å–scancode
            Uint32 mouse_button = mouseButtonFromString(key_name);  // å°è¯•æ ¹æ®æŒ‰é”®åç§°è·å–é¼ æ ‡æŒ‰é’®
            // æœªæ¥å¯æ·»åŠ å…¶å®ƒè¾“å…¥ç±»å‹ ...

            if (scancode != SDL_SCANCODE_UNKNOWN) {      // å¦‚æœscancodeæœ‰æ•ˆ,åˆ™å°†actionæ·»åŠ åˆ°scancode_to_actions_map_ä¸­
                input_to_actions_map_[scancode].push_back(action_name);     
                spdlog::trace("  æ˜ å°„æŒ‰é”®: {} (Scancode: {}) åˆ°åŠ¨ä½œ: {}", key_name, static_cast<int>(scancode), action_name);
            } else if (mouse_button != 0) {             // å¦‚æœé¼ æ ‡æŒ‰é’®æœ‰æ•ˆ,åˆ™å°†actionæ·»åŠ åˆ°mouse_button_to_actions_map_ä¸­
                input_to_actions_map_[mouse_button].push_back(action_name); 
                spdlog::trace("  æ˜ å°„é¼ æ ‡æŒ‰é’®: {} (Button ID: {}) åˆ°åŠ¨ä½œ: {}", key_name, static_cast<int>(mouse_button), action_name);
                // else if: æœªæ¥å¯æ·»åŠ å…¶å®ƒè¾“å…¥ç±»å‹ ...
            } else {
                spdlog::warn("è¾“å…¥æ˜ å°„è­¦å‘Š: æœªçŸ¥é”®æˆ–æŒ‰é’®åç§° '{}' ç”¨äºåŠ¨ä½œ '{}'.", key_name, action_name);
            }
        }
    }
    spdlog::trace("è¾“å…¥æ˜ å°„åˆå§‹åŒ–å®Œæˆ.");
}
```

åœ¨ `initializeMappings` å’Œ `processEvent` ä¸­ï¼Œæ— è®ºæ˜¯é”®ç›˜çš„ scancode è¿˜æ˜¯é¼ æ ‡çš„ buttonï¼Œéƒ½å¯ä»¥ç›´æ¥ä½œä¸ºæ–°æ˜ å°„è¡¨ `input_to_actions_map_` çš„é”®æ¥ä½¿ç”¨ï¼Œ`std::variant` ä¼šè‡ªåŠ¨å¤„ç†åº•å±‚çš„ç±»å‹åŒ¹é…ã€‚ä»£ç é€»è¾‘å˜å¾—æ›´åŠ ç»Ÿä¸€å’Œç®€æ´ã€‚

---

## ğŸ¯ é‡æ„çš„ä¼˜åŠ¿

### å¯¹æ¯”æ€»ç»“

| ç‰¹æ€§ | æ—§ç‰ˆæœ¬ | é‡æ„ç‰ˆæœ¬ |
|------|--------|----------|
| **æ˜ å°„è¡¨æ•°é‡** | 2 ä¸ªï¼ˆé”®ç›˜ã€é¼ æ ‡å„ä¸€ä¸ªï¼‰ | 1 ä¸ªç»Ÿä¸€æ˜ å°„è¡¨ |
| **æ‰©å±•æ€§** | æ¯æ–°å¢è¾“å…¥è®¾å¤‡éœ€è¦æ–°å¢æ˜ å°„è¡¨ | åªéœ€åœ¨ variant ä¸­æ·»åŠ æ–°ç±»å‹ |
| **ä»£ç å¤æ‚åº¦** | éœ€è¦åˆ†åˆ«å¤„ç†ä¸åŒè¾“å…¥ç±»å‹ | ç»Ÿä¸€å¤„ç†é€»è¾‘ |
| **ç±»å‹å®‰å…¨** | ä¸€èˆ¬ | å¼ºç±»å‹å®‰å…¨ï¼ˆvariantï¼‰ |

### âœ¨ å…³é”®è¦ç‚¹

è¿™æ¬¡é‡æ„æ²¡æœ‰æ”¹å˜ `InputManager` çš„ä»»ä½•å¤–éƒ¨è¡Œä¸ºï¼Œä½†å…¶å†…éƒ¨ç»“æ„å˜å¾—æ›´åŠ ï¼š

- âœ… **ä¼˜é›…**ï¼šå•ä¸€æ˜ å°„è¡¨ï¼Œä»£ç æ›´ç®€æ´
- âœ… **å¥å£®**ï¼šç±»å‹å®‰å…¨çš„ variant
- âœ… **å¯æ‰©å±•**ï¼šä¸ºæœªæ¥æ”¯æŒæ›´å¤šè¾“å…¥è®¾å¤‡ï¼ˆæ‰‹æŸ„ã€è§¦æ‘¸å±ç­‰ï¼‰åšå¥½äº†å‡†å¤‡

> ğŸ’¡ è¿™æ­£æ˜¯ä¸€ä¸ªä¼˜ç§€ç³»ç»Ÿè®¾è®¡çš„ä½“ç°ï¼šåœ¨ä¸æ”¹å˜å¤–éƒ¨æ¥å£çš„æƒ…å†µä¸‹ï¼Œä¼˜åŒ–å†…éƒ¨å®ç°ã€‚

---

## ğŸ“š æ€»ç»“

é€šè¿‡æœ¬èŠ‚è¯¾ï¼Œæˆ‘ä»¬ä¸ºå¼•æ“æ„å»ºäº†ä¸€ä¸ªå¼ºå¤§çš„è¾“å…¥ç®¡ç†ç³»ç»Ÿï¼š

1. **æŠ½è±¡åŒ–è®¾è®¡**ï¼šå°†ç‰©ç†æŒ‰é”®æ˜ å°„åˆ°æ¸¸æˆåŠ¨ä½œï¼Œè§£è€¦è¾“å…¥å’Œé€»è¾‘
2. **ç²¾ç¡®çŠ¶æ€ç®¡ç†**ï¼šå®ç°äº†å®Œæ•´çš„æŒ‰é”®çŠ¶æ€æœº
3. **é…ç½®é©±åŠ¨**ï¼šæ‰€æœ‰æŒ‰é”®æ˜ å°„å¯é€šè¿‡ JSON é…ç½®
4. **ç°ä»£ C++ å®è·µ**ï¼šä½¿ç”¨ `std::variant` æå‡ä»£ç è´¨é‡

ç°åœ¨ï¼Œæˆ‘ä»¬çš„å¼•æ“ä¸ä»…èƒ½"çœ‹"ï¼ˆæ¸²æŸ“ï¼‰ï¼Œè¿˜èƒ½"æ„ŸçŸ¥"ï¼ˆè¾“å…¥ï¼‰äº†ï¼ğŸ®
