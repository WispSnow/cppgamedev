# 攀爬状态切换

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1PZ4RzjECT&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1PZ4RzjECT)

## 📌 问题背景

我们已经实现了敌人的AI系统，游戏的动态挑战性大大提升。但玩家的移动方式还比较单一，只能在水平平台上跳跃。真正立体的平台游戏需要垂直移动机制——攀爬系统。

### ⚠️ 当前的问题

```
单一的移动方式：
┌─────────────────────────┐
│   📍 高处的道具          │
│   🪜 梯子（无法使用）    │
│                          │
│   👤 玩家（只能跳跃）    │
│   🟫 平台                │
│                          │
│ ❌ 无法使用梯子          │
│ ❌ 无法到达高处          │
│ ❌ 关卡设计受限          │
│ ❌ 缺少垂直移动          │
└─────────────────────────┘
```

| 问题 | 说明 | 影响 |
|------|------|------|
| **无攀爬机制** | 玩家无法使用梯子 | 无法实现立体关卡 |
| **状态缺失** | 缺少攀爬状态 | 状态机不完整 |
| **边缘情况** | 梯子顶部处理困难 | 玩家会从顶部掉落 |
| **控制复杂** | 需要无缝状态切换 | 实现难度高 |

### 💡 解决方案：攀爬状态系统

**核心思想**：
1. 扩展瓦片系统支持梯子类型
2. 物理引擎检测梯子碰撞
3. 新增 ClimbState 攀爬状态
4. 实现无缝的状态切换
5. 处理梯子顶部的边缘情况

```
攀爬系统架构：
┌──────────────────┐
│   TileType       │ ← 瓦片类型
│   + LADDER       │   新增梯子类型
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ PhysicsEngine    │ ← 物理引擎
│ - 检测梯子碰撞   │   设置标志位
│ - 检测顶部位置   │
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ PlayerState      │ ← 状态系统
│ - ClimbState     │   新增攀爬状态
│ - 状态切换       │
└──────────────────┘
```

### 🎯 本课目标

| 目标 | 说明 |
|------|------|
| **引擎扩展** | 为瓦片系统和物理系统添加梯子支持 |
| **实现ClimbState** | 添加攀爬状态并实现独特的控制逻辑 |
| **无缝状态切换** | 实现从各状态进入和退出攀爬状态 |
| **解决边缘情况** | 处理梯子顶部的站立和向下爬逻辑 |

---

## 第一部分：基础攀爬逻辑

首先，我们要让引擎能"认识"梯子，并让玩家在接触梯子时能够通过按键进入一个新的攀爬状态。

<img src="https://theorhythm.top/gamedev/SL/SL.076.webp" alt="攀爬状态切换1" style="display: block; margin: auto; width: 700px;" />

---

## 1. 在Tiled中定义梯子

与之前的危险瓦片一样，我们通过 Tiled 中自定义属性来定义梯子。

### assets/maps/tileset.tsj（配置）

```json
{
 "id":257,
 "properties":[
        {
         "name":"ladder",
         "type":"bool",
         "value":true
        }]
}
```

### 梯子标记流程

```
Tiled 编辑器中：
    ↓
1. 选择梯子瓦片
    ↓
2. 添加自定义属性
    name: "ladder"
    type: bool
    value: true
    ↓
3. 保存 tileset.tsj
    ↓
引擎加载时识别
```

### 瓦片属性对比

| 瓦片类型 | 属性名 | 属性值 | 用途 |
|---------|--------|--------|------|
| **实体** | "collision" | true | 普通墙壁 |
| **单向平台** | "platform" | true | 可穿越平台 |
| **危险** | "hazard" | true | 尖刺伤害 |
| **梯子** | "ladder" | true | 攀爬区域 |

---

## 2. 引擎升级：识别与检测梯子

接下来，我们需要让引擎能够理解这个新属性。这需要三个步骤的升级。

### 第一步：添加 LADDER 瓦片类型

#### src/engine/component/tilelayer_component.h（更新）

```cpp
enum class TileType {
    //...
    HAZARD,     ///< @brief 危险瓦片（例如火焰、尖刺等）
    LADDER,     ///< @brief 梯子瓦片
};
```

### 瓦片类型总览

```
TileType 枚举扩展：
┌──────────────────┐
│ NORMAL           │ ← 普通背景瓦片
├──────────────────┤
│ SOLID            │ ← 实体墙壁
├──────────────────┤
│ UNISOLID         │ ← 单向平台
├──────────────────┤
│ SLOPE_*          │ ← 斜坡系列
├──────────────────┤
│ HAZARD           │ ← 危险区域
├──────────────────┤
│ LADDER           │ ← 梯子（新增）✨
└──────────────────┘
```

### 第二步：让 LevelLoader 识别梯子

#### src/engine/scene/level_loader.cpp（更新）

```cpp
// 在 getTileType 函数中
else if (property.contains("name") && property["name"] == "ladder") {
    auto is_ladder = property.value("value", false);
    return is_ladder ? engine::component::TileType::LADDER : engine::component::TileType::NORMAL;
}
```

### 加载流程

```
地图加载流程：
    ↓
1. LevelLoader 读取 tileset.tsj
    ↓
2. 遍历瓦片属性
    ↓
3. 发现 "ladder" 属性
    ↓
4. 返回 TileType::LADDER
    ↓
5. 瓦片被标记为梯子类型
```

### 第三步：让物理引擎检测梯子

梯子不同于危险瓦片，它不是一个触发一次性事件的物品，而是一个能 **持续影响** 玩家状态的区域。因此，我们不把它当作"触发器事件"，而是直接在物理引擎中检测，并设置一个状态标志。

#### src/engine/component/physics_component.h（更新）

```cpp
class PhysicsComponent final : public engine::component::Component {
private:
    //...
    bool collided_ladder_ = false;
public:
    //...
    void resetCollisionFlags() {
        //...
        collided_ladder_ = false;
    }
    void setCollidedLadder(bool collided) { collided_ladder_ = collided; }
    bool hasCollidedLadder() const { return collided_ladder_; }
};
```

#### src/engine/physics/physics_engine.cpp（更新）

```cpp
void PhysicsEngine::checkTileTriggers()
{
    // ... 遍历瓦片 ...
    for (int y = start_y; y < end_y; ++y) {
        auto tile_type = layer->getTileTypeAt({x, y});
        if (tile_type == engine::component::TileType::HAZARD) {
            triggers_set.insert(tile_type);
        }
        // 梯子类型不必记录到事件容器，物理引擎直接设置碰撞标志
        else if (tile_type == engine::component::TileType::LADDER) { 
            pc->setCollidedLadder(true);
        }
    }
    // ...
}
```

### 检测机制对比

```
危险瓦片 vs 梯子：
┌─────────────────────┐
│ HAZARD（危险瓦片）   │
├─────────────────────┤
│ • 触发事件          │
│ • 记录到事件列表     │
│ • 一次性处理        │
│ • GameScene 处理    │
└─────────────────────┘

┌─────────────────────┐
│ LADDER（梯子）       │
├─────────────────────┤
│ • 设置标志位        │
│ • 直接标记组件      │
│ • 持续状态          │
│ • PlayerState 处理  │
└─────────────────────┘
```

### 检测流程

```
梯子检测流程：
    ↓
PhysicsEngine::checkTileTriggers()
    ↓
遍历物体覆盖的所有瓦片
    ↓
发现 TileType::LADDER
    ↓
pc->setCollidedLadder(true)
    ↓
PlayerState 可以查询此标志
    ↓
决定是否切换到 ClimbState
```

| 检测方式 | HAZARD | LADDER |
|---------|--------|--------|
| **存储位置** | `tile_trigger_events_` | `collided_ladder_` |
| **存储类型** | 事件列表 | 布尔标志 |
| **处理时机** | 单次触发 | 持续检测 |
| **处理者** | GameScene | PlayerState |

---

## 3. 进入攀爬：修改现有状态

我们希望玩家在任何时候（站立、行走、空中）只要接触到梯子并按下"上"或"下"键，就能立刻进入攀爬状态。因此，我们需要修改所有相关的状态。

### src/game/component/state/idle_state.cpp（更新）

以及 `walk_state.cpp`, `jump_state.cpp`, `fall_state.cpp`

```cpp
std::unique_ptr<PlayerState> IdleState::handleInput(engine::core::Context& context)
{
    auto input_manager = context.getInputManager();
    auto physics_component = player_component_->getPhysicsComponent();

    // 如果按"move_up"键，且与梯子重合，则切换到 ClimbState
    if (physics_component->hasCollidedLadder() && input_manager.isActionDown("move_up")) {
        return std::make_unique<ClimbState>(player_component_);
    }
    // ... 其他逻辑
}
```

### 状态切换入口

```
进入攀爬的入口：
┌──────────────────┐
│   IdleState      │ → ClimbState
│   (站立状态)      │   按"上"键
├──────────────────┤
│   WalkState      │ → ClimbState
│   (行走状态)      │   按"上"键
├──────────────────┤
│   JumpState      │ → ClimbState
│   (跳跃状态)      │   按"上"键
├──────────────────┤
│   FallState      │ → ClimbState
│   (下落状态)      │   按"上"键
└──────────────────┘

条件：
✅ hasCollidedLadder() == true
✅ isActionDown("move_up") == true
```

### 统一的切换逻辑

| 状态 | 切换条件 | 代码位置 |
|------|---------|---------|
| **IdleState** | 接触梯子 + 按上键 | `idle_state.cpp::handleInput` |
| **WalkState** | 接触梯子 + 按上键 | `walk_state.cpp::handleInput` |
| **JumpState** | 接触梯子 + 按上键 | `jump_state.cpp::handleInput` |
| **FallState** | 接触梯子 + 按上键 | `fall_state.cpp::handleInput` |

### 💡 设计思想

```
为什么要在所有状态中添加？
┌─────────────────────┐
│ 场景1：站立时       │
│ 👤 在地面           │
│ 🪜 旁边有梯子       │
│ → 按上键开始爬      │
├─────────────────────┤
│ 场景2：空中时       │
│ 👤 正在下落         │
│ 🪜 接触到梯子       │
│ → 按上键抓住梯子    │
├─────────────────────┤
│ 场景3：跳跃时       │
│ 👤 正在跳跃         │
│ 🪜 碰到梯子         │
│ → 按上键立刻攀爬    │
└─────────────────────┘

灵活的状态切换，
提升游戏手感！
```

---

## 4. 核心实现：ClimbState

这是本课的核心，一个新的玩家状态，拥有完全不同的物理和控制逻辑。

### src/game/component/state/climb_state.h（新建文件）

```cpp
#pragma once
#include "player_state.h"

namespace game::component::state {

class ClimbState final : public PlayerState {
public:
    ClimbState(PlayerComponent* player_component) : PlayerState(player_component) {}
private:
    void enter() override;
    void exit() override;
    std::unique_ptr<PlayerState> handleInput(engine::core::Context&) override;
    std::unique_ptr<PlayerState> update(float delta_time, engine::core::Context&) override;
};
}
```

### src/game/component/state/climb_state.cpp（新建文件）

```cpp
#include "climb_state.h"
//... 其他头文件

namespace game::component::state {

void ClimbState::enter() {
    playAnimation("climb");
    if (auto* physics = player_component_->getPhysicsComponent(); physics) {
        physics->setUseGravity(false); // 关键：禁用重力
    }
}

void ClimbState::exit() {
    if (auto* physics = player_component_->getPhysicsComponent(); physics) {
        physics->setUseGravity(true); // 关键：重新启用重力
    }
}

std::unique_ptr<PlayerState> ClimbState::handleInput(engine::core::Context& context) {
    auto input = context.getInputManager();
    auto physics = player_component_->getPhysicsComponent();
    auto anim = player_component_->getAnimationComponent();
    auto speed = player_component_->getClimbSpeed();

    // 直接根据输入设置速度
    physics->velocity_.y = input.isActionDown("move_up") ? -speed :
                           input.isActionDown("move_down") ? speed : 0.0f;
    physics->velocity_.x = input.isActionDown("move_left") ? -speed :
                           input.isActionDown("move_right") ? speed : 0.0f;

    // 如果有移动输入，则播放动画，否则暂停
    (physics->velocity_.y != 0.0f || physics->velocity_.x != 0.0f)
        ? anim->resumeAnimation()
        : anim->stopAnimation();
    
    // 按跳跃键可以主动离开梯子
    if (input.isActionPressed("jump")) {
        return std::make_unique<JumpState>(player_component_);
    }
    return nullptr;
}

std::unique_ptr<PlayerState> ClimbState::update(float, engine::core::Context&) {
    auto physics = player_component_->getPhysicsComponent();
    // 如果接触到地面，切换到站立状态
    if (physics->hasCollidedBelow()) {
        return std::make_unique<IdleState>(player_component_);
    }
    // 如果不再接触梯子（比如从侧面爬出），切换到下落状态
    if (!physics->hasCollidedLadder()) {
        return std::make_unique<FallState>(player_component_);
    }
    return nullptr;
}
}
```

### ClimbState 的精髓

```
ClimbState 核心机制：
┌──────────────────────┐
│ enter()              │
│ • 禁用重力           │
│ • 播放攀爬动画       │
├──────────────────────┤
│ exit()               │
│ • 恢复重力           │
├──────────────────────┤
│ handleInput()        │
│ • 直接控制速度       │
│ • 动画跟随输入       │
│ • 跳跃键离开梯子     │
├──────────────────────┤
│ update()             │
│ • 到地面→IdleState   │
│ • 离开梯子→FallState │
└──────────────────────┘
```

### 💡 核心机制：重力控制

```cpp
// enter() 时
physics->setUseGravity(false);  // 关键！

// exit() 时
physics->setUseGravity(true);   // 关键！
```

**为什么要关闭重力？**

```
开启重力（❌）：
🪜 梯子
👤 玩家
 ↓ gravity
 ↓↓ 加速下落
 ↓↓↓ 无法悬停
  → 无法攀爬

关闭重力（✅）：
🪜 梯子
👤 玩家（悬浮）
 ↕ 完全控制
  → 可以攀爬
  → 可以停止
  → 精确移动
```

| 状态 | 重力 | 速度控制 | 效果 |
|------|------|---------|------|
| **Idle/Walk** | ✅ 开启 | 加速度 | 地面移动 |
| **Jump/Fall** | ✅ 开启 | 重力影响 | 抛物线运动 |
| **ClimbState** | ❌ 关闭 | 直接设置 | 精确攀爬 |

### 速度控制机制

```
直接速度控制 vs 加速度控制：
┌─────────────────────┐
│ 地面状态（加速度）： │
│ velocity += accel   │
│ • 有加速过程        │
│ • 有惯性            │
│ • 感觉真实          │
└─────────────────────┘

┌─────────────────────┐
│ 攀爬状态（直接）：   │
│ velocity = input    │
│ • 无加速过程        │
│ • 无惯性            │
│ • 精确响应          │
└─────────────────────┘
```

### 动画控制细节

```cpp
// 如果有移动输入，则播放动画，否则暂停
(physics->velocity_.y != 0.0f || physics->velocity_.x != 0.0f)
    ? anim->resumeAnimation()
    : anim->stopAnimation();
```

**效果**：
```
动画跟随输入：
按上/下/左/右 → 攀爬动画播放
不按键         → 攀爬动画暂停（悬停在梯子上）
```

### 退出攀爬的三种方式

```
退出 ClimbState 的三种方式：
┌──────────────────────┐
│ 1. 主动离开          │
│    按跳跃键          │
│    → JumpState       │
├──────────────────────┤
│ 2. 爬到地面          │
│    hasCollidedBelow()│
│    → IdleState       │
├──────────────────────┤
│ 3. 离开梯子区域      │
│    !hasCollidedLadder│
│    → FallState       │
└──────────────────────┘
```

### 状态转换图

```
ClimbState 状态转换：
        enter()
          ↓
    ┌─────────────┐
    │ ClimbState  │
    │ (攀爬中)     │
    └─────────────┘
          │
     ┌────┴────┬─────────┐
     │         │         │
     ↓         ↓         ↓
┌────────┐┌────────┐┌────────┐
│  Jump  ││  Idle  ││  Fall  │
│按跳跃键││到地面  ││离开梯子│
└────────┘└────────┘└────────┘
     │         │         │
     └────┬────┴─────────┘
          ↓
        exit()
    恢复重力
```

---

## 第二部分：边缘情况 - 梯子顶部

现在，玩家已经可以愉快地爬梯子了，但还有一个关键问题：当玩家从平台上走到梯子顶部时，会直接掉下去。我们希望梯子的最顶端能像一个普通的平台一样可以站立。

### 问题分析

```
梯子顶部的问题：
┌─────────────────────┐
│  🟫🟫🟫  平台        │
│      🪜 梯子顶部     │
│      🪜             │
│      🪜             │
│                     │
│ 问题1：从平台走过去  │
│  👤 → 🪜            │
│  直接掉下去 ❌       │
│                     │
│ 问题2：爬到顶部后    │
│      🪜             │
│      👤             │
│  无法站立 ❌         │
└─────────────────────┘
```

### 期望的行为

```
期望的行为：
┌─────────────────────┐
│  场景1：站在顶部     │
│  🟫🪜🟫 平台 + 梯子  │
│    👤 站住 ✅        │
├─────────────────────┤
│  场景2：从顶部向下爬 │
│  🟫🪜🟫             │
│    👤 按下键        │
│    🪜 进入攀爬 ✅   │
└─────────────────────┘
```

---

## 5. 物理引擎再升级：识别梯子顶部

<img src="https://theorhythm.top/gamedev/SL/SL.077.webp" alt="攀爬状态切换2" style="display: block; margin: auto; width: 700px;" />

我们需要物理引擎提供更多的信息：玩家当前是否正处在梯子的最顶端？

### src/engine/component/physics_component.h（更新）

```cpp
class PhysicsComponent final : public engine::component::Component {
private:
    //...
    bool is_on_top_ladder_ = false;   ///< @brief 是否在梯子顶层
public:
    void resetCollisionFlags() { /*...*/ is_on_top_ladder_ = false; }
    void setOnTopLadder(bool on_top) { is_on_top_ladder_ = on_top; }
    bool isOnTopLadder() const { return is_on_top_ladder_; }
};
```

### 标志位对比

| 标志位 | 含义 | 用途 |
|-------|------|------|
| **collided_ladder_** | 正在接触梯子 | 判断是否可以攀爬 |
| **is_on_top_ladder_** | 在梯子顶部 | 判断是否可以站立 |

### src/engine/physics/physics_engine.cpp（更新）

在 `resolveTileCollisions` 函数中

```cpp
// 在处理下方碰撞的逻辑块中
// ... (原有的 if (tile_type_left == SOLID || ...) ... )
// 如果两个角点都位于梯子上，则判断是不是处在梯子顶层
} else if (tile_type_left == LADDER && tile_type_right == LADDER) {
    auto tile_type_up_l = layer->getTileTypeAt({tile_x, tile_y - 1});
    auto tile_type_up_r = layer->getTileTypeAt({tile_x_right, tile_y - 1});
    // 如果脚下是梯子，但头顶不是梯子，证明处在梯子顶层
    if (tile_type_up_r != LADDER && tile_type_up_l != LADDER) {
        // 如果当前是正常物理状态（非攀爬）
        if (pc->isUseGravity()) {
            pc->setOnTopLadder(true);       // 设置在梯子顶层标志
            pc->setCollidedBelow(true);     // 伪造一个下方碰撞，让玩家站住
            // 将玩家位置对齐到梯子顶部
            new_obj_pos.y = tile_y * layer->getTileSize().y - obj_size.y;
            pc->velocity_.y = 0.0f;
        }
    }
} // ...
```

### 检测算法详解

```
梯子顶部检测算法：
    ↓
1. 检查玩家脚底两个角点
    left_bottom, right_bottom
    ↓
2. 两个角点都在梯子上？
    tile_type_left == LADDER
    tile_type_right == LADDER
    ↓
3. 检查脚底上方一格的瓦片
    tile_type_up_l = getTileTypeAt(tile_y - 1)
    tile_type_up_r = getTileTypeAt(tile_y - 1)
    ↓
4. 上方不是梯子？
    tile_type_up_l != LADDER
    tile_type_up_r != LADDER
    ↓
5. 玩家开启了重力？（非攀爬状态）
    pc->isUseGravity() == true
    ↓
6. 是梯子顶部！
    ✅ setOnTopLadder(true)
    ✅ setCollidedBelow(true)
    ✅ 对齐位置
    ✅ 清零垂直速度
```

### 可视化检测过程

```
检测场景：
    y-1层    y层
┌─────┬─────┬─────┐
│ 🟫  │ 🟫  │ 🟫  │ y-1: 非梯子 ✓
├─────┼─────┼─────┤
│ 🪜  │ 🪜  │ 🪜  │ y: 梯子 ✓
│  👤 │     │     │ 玩家脚底
└─────┴─────┴─────┘
  ↑     ↑
 left  right
 都在梯子上 ✓

检测结果：
• 脚下是梯子 ✓
• 上方不是梯子 ✓
• 开启重力 ✓
→ 这是梯子顶部！
```

### 💡 巧妙的设计

这段代码非常巧妙：

1. **双角点检测**：只在玩家的两个脚底都踩着梯子时触发
2. **向上检查**：检查玩家脚底上方一格的瓦片类型
3. **判断顶部**：上方不是梯子，就意味着正站在梯子的最顶端
4. **状态判断**：通过 `isUseGravity()` 判断玩家是否处于攀爬状态
5. **伪造碰撞**：设置 `setCollidedBelow(true)`，让梯子顶部表现得像实体平台

```
伪造碰撞的妙用：
┌─────────────────────┐
│ 梯子顶部本质上是：   │
│ • TileType::LADDER  │
│ • 不是 SOLID        │
│ • 正常情况会穿过     │
├─────────────────────┤
│ 通过伪造碰撞：       │
│ • setCollidedBelow()│
│ • 表现得像 SOLID    │
│ • 玩家可以站立      │
└─────────────────────┘

既是梯子，又是平台！
```

### 关键判断条件

| 条件 | 检查内容 | 目的 |
|------|---------|------|
| **tile_type_left == LADDER** | 左角点在梯子上 | 确保站在梯子上 |
| **tile_type_right == LADDER** | 右角点在梯子上 | 确保完全覆盖 |
| **tile_type_up != LADDER** | 上方不是梯子 | 确认是顶部 |
| **isUseGravity()** | 开启重力（非攀爬） | 区分站立/攀爬 |

---

## 6. 从顶部向下爬

现在玩家可以站在梯子顶上了，我们还需要提供一个方法让他能从这里开始向下爬。

### src/game/component/state/idle_state.cpp（更新）

以及 `walk_state.cpp`

```cpp
std::unique_ptr<PlayerState> IdleState::handleInput(engine::core::Context& context)
{
    // ... (原有的向上爬逻辑) ...

    // 如果按下"move_down"且在梯子顶层，则切换到 ClimbState
    if (physics_component->isOnTopLadder() && input_manager.isActionDown("move_down")) {
        // 需要向下移动一点，确保下一帧能与梯子碰撞（否则会切换回FallState）
        player_component_->getTransformComponent()->translate(glm::vec2(0, 2.0f));
        return std::make_unique<ClimbState>(player_component_);
    }
    // ...
}
```

### 向下爬的逻辑

```
从顶部向下爬的流程：
    ↓
1. 玩家站在梯子顶部
    isOnTopLadder() == true
    ↓
2. 按下"下"键
    isActionDown("move_down")
    ↓
3. 向下移动2像素
    translate(0, 2.0f)  ← 关键！
    ↓
4. 切换到 ClimbState
    make_unique<ClimbState>()
    ↓
5. 下一帧 hasCollidedLadder() 为 true
    不会立刻切回 FallState
    ↓
6. 成功进入攀爬状态
```

### 💡 2像素的秘密

```cpp
player_component_->getTransformComponent()->translate(glm::vec2(0, 2.0f));
```

**为什么需要这2像素？**

```
没有2像素偏移（❌）：
┌──────────────────┐
│ 🟫🪜🟫 顶部      │ y = 100
│    👤 玩家       │ y = 100
│    🪜            │ y = 116
│                  │
│ 切换到 ClimbState│
│ ↓ update()       │
│ hasCollidedLadder│
│ = false ❌       │
│ ↓                │
│ 立刻切回FallState│
└──────────────────┘

有2像素偏移（✅）：
┌──────────────────┐
│ 🟫🪜🟫 顶部      │ y = 100
│    👤 向下2px    │ y = 102
│    🪜 接触！     │ y = 116
│                  │
│ 切换到 ClimbState│
│ ↓ update()       │
│ hasCollidedLadder│
│ = true ✅        │
│ ↓                │
│ 保持攀爬状态     │
└──────────────────┘
```

### 边缘情况处理

| 情况 | 问题 | 解决方案 |
|------|------|---------|
| **从顶部向下爬** | 切换后立刻掉落 | 先向下移动2像素 |
| **在顶部站立** | 会穿过梯子 | 伪造 `collidedBelow` |
| **从侧面爬出** | 卡在空中 | 检测 `!hasCollidedLadder` |
| **跳跃离开梯子** | 无法主动离开 | 跳跃键切换到 JumpState |

### 完整的顶部交互

```
梯子顶部的三种交互：
┌──────────────────────┐
│ 1. 从平台走过去       │
│    🟫🪜🟫             │
│    👤 → 站住 ✅       │
│    （物理引擎处理）   │
├──────────────────────┤
│ 2. 爬到顶部           │
│       🪜             │
│       👤 ↑           │
│    到达顶部 → 站住 ✅ │
│    （update检测）     │
├──────────────────────┤
│ 3. 从顶部向下爬       │
│    🟫🪜🟫             │
│    👤 按下键 ↓        │
│    进入攀爬 ✅        │
│    （handleInput处理）│
└──────────────────────┘
```

---

## ✅ 编译与运行

编译并运行游戏，你会看到完整的攀爬系统：

```
运行效果：
┌─────────────────────────┐
│  基础攀爬：              │
│  👤 接触梯子             │
│  ⬆️ 按上键开始爬         │
│  ⬇️ 可以向下移动         │
│  ⬅️➡️ 可以左右移动       │
├─────────────────────────┤
│  动画控制：              │
│  👤 移动时动画播放       │
│  👤 停止时动画暂停       │
│  感觉自然流畅           │
├─────────────────────────┤
│  梯子顶部：              │
│  👤 可以站在顶部         │
│  👤 按下键开始向下爬     │
│  过渡自然               │
├─────────────────────────┤
│  退出攀爬：              │
│  👤 爬到地面自动站立     │
│  👤 离开梯子自动下落     │
│  👤 按跳跃键主动离开     │
└─────────────────────────┘
```

**你会看到：**
- ✅ 在任何状态接触梯子，按上键即可攀爬
- ✅ 攀爬时无重力，可以精确控制移动
- ✅ 停止移动时，动画暂停（悬停效果）
- ✅ 可以站在梯子顶部，不会掉落
- ✅ 从顶部按下键可以向下爬
- ✅ 爬到地面自动切换到站立状态
- ✅ 按跳跃键可以主动离开梯子
- ✅ 所有状态切换都非常流畅自然

---

## 🎯 系统架构总结

### 完整的攀爬系统架构

```
攀爬系统层次结构：
┌──────────────────────────┐
│      Tiled Editor        │ ← 资源层
│   (定义梯子瓦片)          │   "ladder": true
└────────┬─────────────────┘
         │
         ↓
┌──────────────────────────┐
│      LevelLoader         │ ← 加载层
│   (识别梯子类型)          │   TileType::LADDER
└────────┬─────────────────┘
         │
         ↓
┌──────────────────────────┐
│    PhysicsEngine         │ ← 物理层
│   (检测梯子碰撞)          │   collided_ladder_
│   (检测顶部位置)          │   is_on_top_ladder_
└────────┬─────────────────┘
         │
         ↓
┌──────────────────────────┐
│    PlayerState           │ ← 逻辑层
│   (ClimbState)           │   状态切换
│   (其他状态修改)          │   进入/退出攀爬
└──────────────────────────┘
```

### 核心成就

我们成功地：

1. ✅ **扩展了瓦片系统**：新增 LADDER 类型
2. ✅ **升级了物理引擎**：检测梯子和梯子顶部
3. ✅ **实现了 ClimbState**：独特的控制逻辑
4. ✅ **实现了无缝切换**：从任何状态进入攀爬
5. ✅ **解决了边缘情况**：梯子顶部的站立和向下爬
6. ✅ **优化了游戏手感**：动画跟随输入，精确控制

### 状态转换总览

```
完整的状态转换图：
        ┌─────────┐
        │  Idle   │
        └────┬────┘
             │
    ┌────────┼────────┐
    │        │        │
    ↓        ↓        ↓
┌────────┐┌────────┐┌────────┐
│  Walk  ││  Jump  ││  Fall  │
└────┬───┘└───┬────┘└───┬────┘
     │        │          │
     │   ┌────┴────┐     │
     └───→ Climb  ←─────┘
         │  (新增) │
         └─────────┘
            │  │
            ↓  ↓
         多种退出方式
```

### 关键技术点

| 技术点 | 实现方式 | 效果 |
|-------|---------|------|
| **梯子识别** | TileType::LADDER | 引擎支持新类型 |
| **碰撞检测** | collided_ladder_ | 持续检测梯子 |
| **重力控制** | setUseGravity(false) | 可以悬浮攀爬 |
| **直接速度** | velocity = input | 精确响应输入 |
| **顶部检测** | is_on_top_ladder_ | 识别梯子顶部 |
| **伪造碰撞** | setCollidedBelow() | 顶部可站立 |
| **2像素偏移** | translate(0, 2.0f) | 避免立刻掉落 |

### 设计模式应用

```
状态模式的威力：
┌──────────────────────┐
│ ClimbState 完全独立： │
├──────────────────────┤
│ • 独特的物理逻辑     │
│   （关闭重力）       │
│ • 独特的控制方式     │
│   （直接速度）       │
│ • 独特的动画处理     │
│   （暂停/继续）      │
│ • 独立的切换规则     │
│   （三种退出方式）   │
└──────────────────────┘

无需修改其他状态，
完美封装！
```

### 职责划分

```
清晰的职责分工：
┌──────────────────┐
│ PhysicsEngine    │ ← 检测者
│ "报告梯子信息"    │   提供数据
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ PlayerState      │ ← 决策者
│ "决定是否攀爬"    │   使用数据
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ ClimbState       │ ← 执行者
│ "执行攀爬逻辑"    │   实现行为
└──────────────────┘
```

---

## 📚 总结

恭喜！我们成功地为游戏添加了一个复杂且交互性极强的移动机制。通过本课的学习，我们再次体验了分层架构和状态模式的强大威力。

**关键要点：**
- 🪜 瓦片扩展：新增 LADDER 类型
- 🔍 碰撞检测：collided_ladder_ 和 is_on_top_ladder_
- 🧗 ClimbState：关闭重力 + 直接速度控制
- 🔄 无缝切换：从任意状态进入攀爬
- 🎯 边缘处理：梯子顶部的站立和向下爬
- 🎬 动画控制：跟随输入暂停/继续
- 💡 2像素技巧：避免立刻掉落的小细节

> 💡 **设计哲学**：引擎与游戏逻辑分离——引擎（PhysicsEngine）负责提供底层的、通用的信息（"你在梯子顶部"），而游戏逻辑层（PlayerState）则根据这些信息做出具体的行为决策（"站立"或"开始向下爬"）。状态的独立性——ClimbState 封装了所有与攀爬相关的独特逻辑（无重力、直接速度控制），与行走、跳跃等状态完全解耦，使得整个系统清晰且易于维护。

---

## 🚀 下一步展望

现在，我们的"阳光岛"拥有了更加立体和有趣的关卡设计潜力。但玩家的操控手感还可以进一步优化：

- ❓ 如何让玩家在离开平台边缘后仍有短暂跳跃机会？
- ❓ 如何实现受伤后的无敌时间？
- ❓ 如何通过视觉反馈让无敌状态更明显？

下一课，我们将引入两个非常重要的平台跳跃游戏概念：

- ⏱️ **土狼时间（Coyote Time）**：边缘宽恕机制
- ✨ **无敌闪烁**：受伤后的保护期
- 🎮 **更细腻的操作手感**：提升玩家体验

让游戏手感更上一层楼！🎮🌟