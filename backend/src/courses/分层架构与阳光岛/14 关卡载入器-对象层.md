# 关卡载入器-对象层

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1F4uFzMENz&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1F4uFzMENz)

## 📌 问题背景

我们已经成功加载了构成静态世界的图片层和瓦片层。现在，是时候将 **动态的生命** 注入我们的关卡了。本节课，我们将完成 `LevelLoader` 的最后一部分功能：解析并加载 **对象层（Object Layer）**。

### 🎯 对象层的作用

对象层在 Tiled 中用于放置独立的、**非网格对齐**的实体，例如：

| 对象类型 | 说明 | 示例 |
|---------|------|------|
| **玩家出生点** | 定义玩家开始位置 | `PlayerSpawn` |
| **敌人** | 各种敌对生物 | `Enemy`, `Boss` |
| **可收集物品** | 道具和奖励 | `Coin`, `Health`, `PowerUp` |
| **触发区域** | 不可见的交互区域 | `Checkpoint`, `Dialog Trigger` |
| **装饰对象** | 非瓦片的装饰物 | `Sign`, `Crate`, `Plant` |

### 对象层 vs 瓦片层

| 特性 | 瓦片层 | 对象层 |
|------|--------|--------|
| **对齐方式** | 严格网格对齐 | 自由位置 |
| **数据结构** | 二维数组 | 对象列表 |
| **用途** | 地形、平台 | 实体、触发器 |
| **GameObject** | 一个 GameObject（整个图层） | 每个对象一个 GameObject |

---

## 1. Tiled 对象层解析思路

对象层在 JSON 中的结构与前两者不同，它包含一个 **`objects` 数组**，每个元素都是一个独立的对象。

### JSON 结构示例

```json
{
    // ...
    "layers": [
        // ...
        {
            "draworder": "topdown",
            "id": 5,
            "name": "Objects",
            "objects": [
                {
                    "gid": 149,
                    "height": 29,
                    "id": 1,
                    "name": "player_spawn",
                    "rotation": 0,
                    "type": "PlayerSpawn",
                    "visible": true,
                    "width": 29,
                    "x": 48,
                    "y": 288
                },
                // ... more objects ...
            ],
            "opacity": 1,
            "type": "objectgroup",
            // ...
        }
    ]
}
```

### 📋 解析流程

```
Tiled 地图解析思路（完成）
    ↓
... (加载图块集和图片层) ...
    ↓
如果 type: "objectgroup"，载入对象层
    ↓
对象数据在 "objects" 字段中
    ↓
为每个对象创建一个 GameObject
```

### 🔑 关注要点

| 关注点 | 说明 |
|--------|------|
| **gid** | 通过 gid 查找源图片信息（和瓦片层一样） |
| **位置和尺寸** | 通过 `x`, `y`, `width`, `height`, `rotation` 确定 `TransformComponent` 的信息 |
| **自定义形状** | 如果没有 gid，则代表是策划在编辑器中直接绘制的形状（如矩形、圆形），这些通常用于碰撞盒、触发器等，我们未来再按需处理 |

---

## 2. 关键：坐标系转换

在解析对象层时，有一个 **非常关键且容易出错** 的细节：**Tiled 对象层的坐标系与我们引擎的坐标系不同！**

### ⚠️ 坐标系差异

| 坐标系 | Y 坐标含义 |
|--------|-----------|
| **Tiled** | 对象的 y 坐标指向其 **左下角** |
| **我们的引擎** | `TransformComponent` 的 position（以及渲染时）指向其 **左上角** |

### 📐 可视化说明

```
Tiled 坐标系:                引擎坐标系:
┌─────────┐                 ┌─────────┐
│         │                 │ (x, y)  │ ← 左上角
│  对象   │                 │         │
│         │                 │  对象   │
│ (x, y)  │ ← 左下角        │         │
└─────────┘                 └─────────┘
```

### 🔧 坐标转换公式

因此，在读取 Tiled 的 y 坐标后，我们必须进行转换：

```cpp
engine_y = tiled_y - object_height
```

**示例：**
- Tiled 中的坐标：`(48, 288)`，高度：`29`
- 引擎中的坐标：`(48, 288 - 29) = (48, 259)`

> 💡 **记忆技巧**：Tiled 的 y 坐标在底部，我们需要向上移动 height 的距离才能得到顶部坐标。

---

## 3. 升级 LevelLoader 以支持对象

现在我们来实现 `loadObjectLayer` 方法。

### engine/scene/level_loader.cpp（更新）

```cpp
#include "level_loader.h"
#include "../component/transform_component.h"
#include "../component/sprite_component.h"
#include "../object/game_object.h"
#include "../scene/scene.h"
#include "../core/context.h"
#include "../resource/resource_manager.h"
// ...

namespace engine::scene {

// ... loadLevel, loadTileLayer etc. ...

void LevelLoader::loadObjectLayer(const nlohmann::json& layer_json, Scene& scene)
{
    if (!layer_json.contains("objects") || !layer_json["objects"].is_array()) {
        spdlog::error("对象图层 '{}' 缺少 'objects' 属性。", layer_json.value("name", "Unnamed"));
        return;
    }
    
    const auto& objects = layer_json["objects"];
    for (const auto& object : objects) {
        auto gid = object.value("gid", 0);
        
        if (gid == 0) {
            // 如果gid为0，代表是自定义形状，如碰撞盒，我们以后再处理
            // TODO: Handle shapes
        } else {
            // 如果gid存在，则代表这是一个带图像的对象
            auto tile_info = getTileInfoByGid(gid);
            if (tile_info.sprite.getTextureId().empty()) {
                spdlog::error("gid为 {} 的瓦片没有图像纹理。", gid);
                continue;
            }

            // 1. 获取Transform信息
            auto position = glm::vec2(object.value("x", 0.0f), object.value("y", 0.0f));
            auto dst_size = glm::vec2(object.value("width", 0.0f), object.value("height", 0.0f));
            
            // !! 关键的坐标转换 !!
            position = glm::vec2(position.x, position.y - dst_size.y);
            
            auto rotation = object.value("rotation", 0.0f);
            
            // 2. 计算缩放
            auto src_size_opt = tile_info.sprite.getSourceRect();
            if (!src_size_opt) {
                spdlog::error("gid为 {} 的瓦片没有源矩形。", gid);
                continue;
            }
            auto src_size = glm::vec2(src_size_opt->w, src_size_opt->h);
            auto scale = dst_size / src_size;

            // 3. 获取对象名称
            const std::string& object_name = object.value("name", "Unnamed");

            // 4. 创建GameObject并添加组件
            auto game_object = std::make_unique<engine::object::GameObject>(object_name);
            game_object->addComponent<engine::component::TransformComponent>(position, scale, rotation);
            game_object->addComponent<engine::component::SpriteComponent>(std::move(tile_info.sprite), scene.getContext().getResourceManager());

            // 5. 添加到场景中
            scene.addGameObject(std::move(game_object));
            spdlog::info("加载对象: '{}' 完成", object_name);
        }
    }
}
}
```

### 代码解析

#### 执行流程

| 步骤 | 操作 | 说明 |
|------|------|------|
| **1. 遍历对象** | 遍历 `objects` 数组中的每一个 `object` | 处理每个独立对象 |
| **2. 检查 gid** | 如果它存在（不为0），调用 `getTileInfoByGid` | 获取对象对应的 Sprite 信息 |
| **3. 读取属性** | 从 object 的 JSON 数据中读取 `x`, `y`, `width`, `height`, `rotation` | 提取变换信息 |
| **4. 坐标转换** | `position.y = position.y - dst_size.y` | **关键步骤**：从 Tiled 坐标系转换到引擎坐标系 |
| **5. 计算缩放** | `scale = dst_size / src_size` | 通过比较设置的对象尺寸和原始图片尺寸计算缩放 |
| **6. 创建对象** | `std::make_unique<GameObject>` | 创建新的游戏对象 |
| **7. 添加组件** | 添加 `TransformComponent` 和 `SpriteComponent` | 赋予对象位置和外观 |
| **8. 添加到场景** | `scene.addGameObject(std::move(game_object))` | 将对象加入场景 |

#### 关键点说明

**1. gid 的两种情况：**

```cpp
if (gid == 0) {
    // 自定义形状（矩形、圆形等）
    // 通常用于碰撞盒、触发器
    // TODO: 未来处理
} else {
    // 带图像的对象
    // 从图块集中获取精灵信息
}
```

**2. 缩放计算：**

```
dst_size: Tiled 中设置的对象尺寸（策划调整后的大小）
src_size: 原始瓦片图片的尺寸
scale = dst_size / src_size: 计算缩放比例
```

**示例：**
- 原始图片：32x32 像素
- Tiled 中设置：64x64 像素
- 缩放：(64/32, 64/32) = (2.0, 2.0)

**3. 高效传递 Sprite：**

```cpp
// 使用 std::move 避免不必要的拷贝
game_object->addComponent<SpriteComponent>(
    std::move(tile_info.sprite),  // 右值引用
    scene.getContext().getResourceManager()
);
```

---

## 4. SpriteComponent 的小优化

为了能高效地将 `LevelLoader` 中创建的 `Sprite` 对象传递给 `SpriteComponent`，我们为其添加一个新的构造函数，它接收一个 **右值引用** 的 `Sprite`。

### engine/component/sprite_component.h（新增构造函数）

```cpp
// ...
class SpriteComponent final : public engine::component::Component {
public:
    // ... 原有构造函数 ...

    /**
     * @brief 构造函数 (通过移动Sprite)
     * @param sprite 精灵对象。
     * @param resource_manager 资源管理器指针。
     * @param alignment 初始对齐方式。
     */
    SpriteComponent(
        engine::render::Sprite&& sprite,
        engine::resource::ResourceManager& resource_manager,
        engine::utils::Alignment alignment = engine::utils::Alignment::NONE
    );
// ...
};
```

### engine/component/sprite_component.cpp（新增构造函数实现）

```cpp
#include "sprite_component.h"
// ...
namespace engine::component {

// ... 原有构造函数 ...

SpriteComponent::SpriteComponent(engine::render::Sprite&& sprite, engine::resource::ResourceManager& resource_manager, engine::utils::Alignment alignment)
    : resource_manager_(&resource_manager), sprite_(std::move(sprite)), alignment_(alignment)
{
    if (!resource_manager_) {
        spdlog::critical("创建 SpriteComponent 时 ResourceManager 为空！");
    }
    spdlog::trace("创建 SpriteComponent，纹理ID: {}", sprite_.getTextureId());
}
// ...
}
```

### 💡 设计优势

| 特性 | 说明 |
|------|------|
| **移动语义** | 使用 `std::move` 转移 Sprite 的所有权，避免深拷贝 |
| **性能优化** | 大量对象加载时性能提升明显 |
| **现代 C++** | 符合 C++11+ 的最佳实践 |

---

## 5. 最终效果

现在，我们的 `LevelLoader` 已经是一个 **功能完备的模块** 了，它可以加载：

### ✅ 完整功能列表

| 功能 | 对应课程 | 状态 |
|------|----------|------|
| 📁 **图片层** | 第 12 课 | ✅ 完成 |
| 🔲 **瓦片层** | 第 13 课 | ✅ 完成 |
| 🎮 **对象层** | 第 14 课 | ✅ 完成 |

### 🎨 运行效果

编译并运行游戏。你将看到：

```
游戏画面：
┌─────────────────────────────────┐
│  🌄 视差背景                    │
│     🏔️ 远山层                   │
│        🌲 中景层                │
│  ┌──┬──┬──┬──┬──┐              │
│  │▓▓│▓▓│▓▓│▓▓│▓▓│ ← 瓦片地形   │
│  └──┴──┴──┴──┴──┘              │
│    📦  🪧  🌳 ← 对象层装饰      │
│       👤 ← 玩家出生点           │
└─────────────────────────────────┘
```

**你将看到：**
- ✅ 背景和地面（图片层和瓦片层）
- ✅ Tiled 对象层里放置的道具、装饰（例如箱子、路牌）
- ✅ 按照你在编辑器里设置的位置、旋转和大小精确渲染
- ✅ 所有对象都是独立的 GameObject，可以动态交互

---

## 🎯 系统架构总结

### 完整的数据驱动流程

```
Tiled 编辑器
    ↓ 导出 JSON
关卡数据文件 (level.tmj)
    ↓ LevelLoader 解析
图片层 → ParallaxComponent
瓦片层 → TileMapComponent
对象层 → 多个 GameObject (Transform + Sprite)
    ↓
游戏场景
```

### 核心成就

我们已经完成了从 **数据到场景** 的完整构建流程：

1. ✅ **图片层加载**：视差背景系统
2. ✅ **瓦片层加载**：网格地形系统
3. ✅ **对象层加载**：独立实体系统
4. ✅ **坐标系转换**：正确处理 Tiled 坐标
5. ✅ **性能优化**：移动语义减少拷贝

### 设计亮点

| 亮点 | 实现 |
|------|------|
| **数据驱动** | 关卡内容完全由 Tiled 数据定义 |
| **灵活扩展** | 新增对象类型无需修改代码 |
| **类型安全** | 通过 gid 精确匹配图块 |
| **坐标转换** | 自动处理坐标系差异 |
| **高性能** | 使用移动语义和智能指针 |

---

## 📚 总结

至此，我们已经完成了从数据到场景的完整构建流程。我们的引擎现在可以动态地加载任何用 Tiled 设计的关卡。

**关键要点：**
- 📦 对象层用于放置独立的游戏实体
- 📐 Tiled 和引擎的坐标系不同，需要转换
- 🎯 每个对象创建一个独立的 GameObject
- 🔧 通过 gid 查找对应的图块信息
- 🚀 使用移动语义优化性能
- ✅ LevelLoader 现已功能完备

> 💡 **设计哲学**：数据驱动的设计让我们能够快速迭代关卡，而不需要重新编译代码。这是现代游戏开发的核心原则之一！

从下一课开始，我们将为这个静态的美丽世界注入物理规则，让它真正"动"起来！⚙️🎮
