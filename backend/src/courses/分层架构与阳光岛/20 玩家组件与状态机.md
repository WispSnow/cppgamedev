# ç©å®¶ç»„ä»¶ä¸çŠ¶æ€æœº

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- Bç«™åµŒå…¥ï¼šä½¿ç”¨ https æ˜ç¡®åè®®ï¼ˆé¿å… file:// æˆ– http å¯¼è‡´è¢«æµè§ˆå™¨æ‹¦æˆªï¼‰ -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1BTb1zjEsT&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[åœ¨ Bilibili ä¸Šè§‚çœ‹](https://www.bilibili.com/video/BV1BTb1zjEsT)

## ğŸ“Œ é—®é¢˜èƒŒæ™¯

ç›®å‰æˆ‘ä»¬æ‰€æœ‰çš„ç©å®¶è¾“å…¥æ§åˆ¶éƒ½å†™åœ¨ `GameScene::TestPlayer()` è¿™ä¸ªæµ‹è¯•å‡½æ•°é‡Œã€‚è¿™ç§å†™æ³•éšç€åŠŸèƒ½çš„å¢åŠ ï¼Œä¼šå˜å¾—è¶Šæ¥è¶Šéš¾ä»¥ç»´æŠ¤ã€‚

### âš ï¸ å½“å‰çš„é—®é¢˜

```cpp
// ä¹‹å‰çš„ä¸´æ—¶ä»£ç 
void GameScene::TestPlayer()
{
    if (!player_) return;
    auto& input_manager = context_.getInputManager();
    auto* pc = player_->getComponent<engine::component::PhysicsComponent>();
    if (!pc) return;
    // ... ä¸€å † if/else åˆ¤æ–­è¾“å…¥å’Œä¿®æ”¹é€Ÿåº¦ ...
    if (input_manager.isActionPressed("jump")) {
        pc->velocity_.y = -400.0f;
    }
}
```

| é—®é¢˜ | è¯´æ˜ | åæœ |
|------|------|------|
| **é€»è¾‘æ··ä¹±** | éšç€è¡Œä¸ºå¢åŠ å……æ–¥ç€å¤æ‚çš„ if-else åµŒå¥— | éš¾ä»¥é˜…è¯»å’Œç»´æŠ¤ |
| **çŠ¶æ€ä¸æ˜ç¡®** | åªèƒ½é€šè¿‡ `velocity.y` åˆ¤æ–­æ˜¯è·³è·ƒè¿˜æ˜¯ä¸‹è½ | éš¾ä»¥å®ç°å¤æ‚é€»è¾‘ |
| **è€¦åˆåº¦é«˜** | æ§åˆ¶é€»è¾‘ç¡¬ç¼–ç åœ¨ `GameScene` ä¸­ | æ— æ³•å¤ç”¨ï¼Œä¸ç¬¦åˆç»„ä»¶åŒ–è®¾è®¡ |

### ğŸ’¡ è§£å†³æ–¹æ¡ˆï¼šçŠ¶æ€è®¾è®¡æ¨¡å¼

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†å¯¹è±¡çš„æ¯ä¸€ç§è¡Œä¸ºçŠ¶æ€ï¼ˆç«™ç«‹ã€è¡Œèµ°ã€è·³è·ƒç­‰ï¼‰éƒ½å°è£…æˆä¸€ä¸ªç‹¬ç«‹çš„å¯¹è±¡ã€‚å¯¹è±¡æœ¬èº«ï¼ˆç©å®¶ï¼‰åªéœ€è¦æŒæœ‰ä¸€ä¸ªæŒ‡å‘å½“å‰çŠ¶æ€å¯¹è±¡çš„æŒ‡é’ˆï¼Œå¹¶å°†æ‰€æœ‰é€»è¾‘å¤„ç†å§”æ‰˜ç»™è¿™ä¸ªçŠ¶æ€å¯¹è±¡ã€‚

```
çŠ¶æ€æ¨¡å¼æ¶æ„ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PlayerComponent â”‚  æŒæœ‰
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚ current_state_
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PlayerState  â”‚  æŠ½è±¡åŸºç±»
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚ ç»§æ‰¿
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
    â†“         â†“        â†“      â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”
â”‚IdleStateâ”‚ â”‚Walkâ”‚ â”‚Jumpâ”‚ â”‚Fallâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜
```

### ğŸ¯ æœ¬è¯¾ç›®æ ‡

| ç›®æ ‡ | è¯´æ˜ |
|------|------|
| **ç†è§£çŠ¶æ€è®¾è®¡æ¨¡å¼** | å­¦ä¹ ä¸ºä»€ä¹ˆä»¥åŠå¦‚ä½•ä½¿ç”¨çŠ¶æ€æ¨¡å¼ç®¡ç†å¤æ‚å¯¹è±¡çš„è¡Œä¸º |
| **æ„å»ºç©å®¶çŠ¶æ€æœº** | åˆ›å»º Idleã€Walkã€Jumpã€Fall å››ç§åŸºæœ¬çŠ¶æ€ |
| **åˆ›å»º PlayerComponent** | ä¸“é—¨çš„ç»„ä»¶å°è£…ç©å®¶é€»è¾‘ï¼Œä¸ GameScene è§£è€¦ |
| **å¢å¼ºç‰©ç†å¼•æ“** | æ·»åŠ ç¢°æ’æ–¹å‘æ ‡å¿—ï¼Œä¸ºçŠ¶æ€åˆ¤æ–­æä¾›ä¾æ® |

---

## 1. ç‰©ç†å¼•æ“å‡çº§ï¼šæä¾›ç¢°æ’ä¿¡æ¯

çŠ¶æ€æœºéœ€è¦çŸ¥é“ **"ç©å®¶å½“å‰æ˜¯å¦åœ¨åœ°é¢ä¸Š"**ã€**"æ˜¯å¦æ’åˆ°äº†å¢™"** ç­‰ä¿¡æ¯æ¥å†³å®šå¦‚ä½•åˆ‡æ¢çŠ¶æ€ã€‚è¿™äº›ä¿¡æ¯æœ€åº”è¯¥ç”±ç‰©ç†å¼•æ“æä¾›ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆæ¥å‡çº§ `PhysicsComponent` å’Œ `PhysicsEngine`ã€‚

### ğŸ’¡ è®¾è®¡æ€æƒ³

```
ç¢°æ’ä¿¡æ¯æµè½¬ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PhysicsEngine    â”‚
â”‚ æ£€æµ‹åˆ°ç¢°æ’       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ è®¾ç½®æ ‡å¿—
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PhysicsComponent â”‚
â”‚ collided_below_  â”‚
â”‚ collided_above_  â”‚
â”‚ collided_left_   â”‚
â”‚ collided_right_  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ æŸ¥è¯¢
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PlayerState      â”‚
â”‚ æ ¹æ®æ ‡å¿—åˆ‡æ¢çŠ¶æ€ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.1 PhysicsComponent ä¸­æ·»åŠ ç¢°æ’æ ‡å¿—

æˆ‘ä»¬åœ¨ `PhysicsComponent` ä¸­æ·»åŠ å››ä¸ªå¸ƒå°”æ ‡å¿—ï¼Œç”¨äºè®°å½•æ¯ä¸€å¸§ä¸­ç‰©ä½“åœ¨å››ä¸ªæ–¹å‘ä¸Šçš„ç¢°æ’æƒ…å†µã€‚

#### src/engine/component/physics_component.hï¼ˆæ›´æ–°ï¼‰

```cpp
class PhysicsComponent final: public Component {
    // ...
    // --- ç¢°æ’çŠ¶æ€æ ‡å¿— ---
    bool collided_below_ = false;
    bool collided_above_ = false;
    bool collided_left_ = false;
    bool collided_right_ = false;
  public:
    // ...
    // --- ç¢°æ’çŠ¶æ€è®¿é—®ä¸ä¿®æ”¹ (ä¾› PhysicsEngine ä½¿ç”¨) ---
    /** @brief é‡ç½®æ‰€æœ‰ç¢°æ’æ ‡å¿— (åœ¨ç‰©ç†æ›´æ–°å¼€å§‹æ—¶è°ƒç”¨) */
    void resetCollisionFlags() {
        collided_below_ = false;
        collided_above_ = false;
        collided_left_ = false;
        collided_right_ = false;
    }

    void setCollidedBelow(bool collided) { collided_below_ = collided; }    ///< @brief è®¾ç½®ä¸‹æ–¹ç¢°æ’æ ‡å¿—
    void setCollidedAbove(bool collided) { collided_above_ = collided; }    ///< @brief è®¾ç½®ä¸Šæ–¹ç¢°æ’æ ‡å¿—
    void setCollidedLeft(bool collided) { collided_left_ = collided; }      ///< @brief è®¾ç½®å·¦æ–¹ç¢°æ’æ ‡å¿—
    void setCollidedRight(bool collided) { collided_right_ = collided; }    ///< @brief è®¾ç½®å³æ–¹ç¢°æ’æ ‡å¿—

    bool hasCollidedBelow() const { return collided_below_; }       ///< @brief æ£€æŸ¥æ˜¯å¦ä¸ä¸‹æ–¹å‘ç”Ÿç¢°æ’
    bool hasCollidedAbove() const { return collided_above_; }       ///< @brief æ£€æŸ¥æ˜¯å¦ä¸ä¸Šæ–¹å‘ç”Ÿç¢°æ’
    bool hasCollidedLeft() const { return collided_left_; }         ///< @brief æ£€æŸ¥æ˜¯å¦ä¸å·¦æ–¹å‘ç”Ÿç¢°æ’
    bool hasCollidedRight() const { return collided_right_; }       ///< @brief æ£€æŸ¥æ˜¯å¦ä¸å³æ–¹å‘ç”Ÿç¢°æ’

private:
    // ...
}
```

### æ ‡å¿—è¯´æ˜

| æ ‡å¿— | å«ä¹‰ | ç”¨é€” |
|------|------|------|
| `collided_below_` | ä¸‹æ–¹æ˜¯å¦ç¢°æ’ | åˆ¤æ–­æ˜¯å¦åœ¨åœ°é¢ä¸Š |
| `collided_above_` | ä¸Šæ–¹æ˜¯å¦ç¢°æ’ | åˆ¤æ–­æ˜¯å¦æ’åˆ°å¤©èŠ±æ¿ |
| `collided_left_` | å·¦ä¾§æ˜¯å¦ç¢°æ’ | åˆ¤æ–­æ˜¯å¦æ’åˆ°å·¦å¢™ |
| `collided_right_` | å³ä¾§æ˜¯å¦ç¢°æ’ | åˆ¤æ–­æ˜¯å¦æ’åˆ°å³å¢™ |

### âš ï¸ é‡è¦ç»†èŠ‚

**`resetCollisionFlags()`** å‡½æ•°å°†åœ¨æ¯å¸§ç‰©ç†æ›´æ–°å¼€å§‹æ—¶è¢«è°ƒç”¨ï¼Œä»¥ç¡®ä¿ç¢°æ’ä¿¡æ¯ä¸ä¼šä»å‰ä¸€å¸§æ®‹ç•™ä¸‹æ¥ã€‚

---

### 1.2 PhysicsEngine è®°å½•ç¢°æ’ä¿¡æ¯

æ¥ä¸‹æ¥ï¼Œåœ¨ `PhysicsEngine` çš„ç¢°æ’è§£æå‡½æ•°ä¸­ï¼Œå½“æ£€æµ‹åˆ°å¹¶å¤„ç†ç¢°æ’æ—¶ï¼Œæˆ‘ä»¬å°±è°ƒç”¨ä¸Šé¢å®šä¹‰çš„ setter å‡½æ•°æ¥è®¾ç½®å¯¹åº”çš„æ ‡å¿—ã€‚

#### src/engine/physics/physics_engine.cppï¼ˆæ›´æ–°ï¼‰

```cpp
void PhysicsEngine::update(float delta_time) {
    // æ¯å¸§å¼€å§‹æ—¶å…ˆæ¸…ç©ºç¢°æ’å¯¹åˆ—è¡¨
    collision_pairs_.clear();

    // éå†æ‰€æœ‰æ³¨å†Œçš„ç‰©ç†ç»„ä»¶
    for (auto* pc : components_) {
        if (!pc || !pc->isEnabled()) { // æ£€æŸ¥ç»„ä»¶æ˜¯å¦æœ‰æ•ˆå’Œå¯ç”¨
            continue;
        }

        pc->resetCollisionFlags();  // é‡ç½®ç¢°æ’æ ‡å¿—

        // åº”ç”¨é‡åŠ› ...
}

void PhysicsEngine::resolveTileCollisions(engine::component::PhysicsComponent* pc, float delta_time) {
    // ...
    // éå†æ‰€æœ‰æ³¨å†Œçš„ç¢°æ’ç“¦ç‰‡å±‚
    for (auto* layer : collision_tile_layers_) {
        if (!layer) continue;
        auto tile_size = layer->getTileSize();
        // è½´åˆ†ç¦»ç¢°æ’æ£€æµ‹ï¼šå…ˆæ£€æŸ¥Xæ–¹å‘æ˜¯å¦æœ‰ç¢°æ’ (yæ–¹å‘ä½¿ç”¨åˆå§‹å€¼obj_pos.y)
        if (ds.x > 0.0f) {
            // æ£€æŸ¥å³ä¾§ç¢°æ’
            // ...
            if (tile_type_top == engine::component::TileType::SOLID || tile_type_bottom == engine::component::TileType::SOLID) {
                // æ’å¢™äº†ï¼é€Ÿåº¦å½’é›¶ï¼Œxæ–¹å‘ç§»åŠ¨åˆ°è´´ç€å¢™çš„ä½ç½®
                new_obj_pos.x = tile_x * layer->getTileSize().x - obj_size.x;
                pc->velocity_.x = 0.0f;
                pc->setCollidedRight(true);
            } else {
                // æ£€æµ‹å³ä¸‹è§’æ–œå¡ç“¦ç‰‡
                // ...
                    // å¦‚æœæœ‰ç¢°æ’ï¼ˆè§’ç‚¹çš„ä¸–ç•Œyåæ ‡ > æ–œå¡åœ°é¢çš„ä¸–ç•Œyåæ ‡ï¼‰, å°±è®©ç‰©ä½“è´´ç€æ–œå¡è¡¨é¢
                    if (new_obj_pos.y > (tile_y_bottom + 1) * layer->getTileSize().y - obj_size.y - height_right) {
                        new_obj_pos.y = (tile_y_bottom + 1) * layer->getTileSize().y - obj_size.y - height_right;
                        pc->setCollidedBelow(true);
                    }
                }
            }
        }
        else if (ds.x < 0.0f) {
            // æ£€æŸ¥å·¦ä¾§ç¢°æ’
            // ...
            if (tile_type_top == engine::component::TileType::SOLID || tile_type_bottom == engine::component::TileType::SOLID) {
                // æ’å¢™äº†ï¼é€Ÿåº¦å½’é›¶ï¼Œxæ–¹å‘ç§»åŠ¨åˆ°è´´ç€å¢™çš„ä½ç½®
                new_obj_pos.x = (tile_x + 1) * layer->getTileSize().x;
                pc->velocity_.x = 0.0f;
                pc->setCollidedLeft(true);
            } else {
                // æ£€æµ‹å·¦ä¸‹è§’æ–œå¡ç“¦ç‰‡
                // ...
                if (height_left > 0.0f) {
                    if (new_obj_pos.y > (tile_y_bottom + 1) * layer->getTileSize().y - obj_size.y - height_left) {
                        new_obj_pos.y = (tile_y_bottom + 1) * layer->getTileSize().y - obj_size.y - height_left;
                        pc->setCollidedBelow(true);
                    }
                }
            }
        }
        // è½´åˆ†ç¦»ç¢°æ’æ£€æµ‹ï¼šå†æ£€æŸ¥Yæ–¹å‘æ˜¯å¦æœ‰ç¢°æ’ (xæ–¹å‘ä½¿ç”¨åˆå§‹å€¼obj_pos.x)
        if (ds.y > 0.0f) {
            // æ£€æŸ¥åº•éƒ¨ç¢°æ’
            // ...
            if (tile_type_left == engine::component::TileType::SOLID || tile_type_right == engine::component::TileType::SOLID ||
                tile_type_left == engine::component::TileType::UNISOLID || tile_type_right == engine::component::TileType::UNISOLID) {
                // åˆ°è¾¾åœ°é¢ï¼é€Ÿåº¦å½’é›¶ï¼Œyæ–¹å‘ç§»åŠ¨åˆ°è´´ç€åœ°é¢çš„ä½ç½®
                new_obj_pos.y = tile_y * layer->getTileSize().y - obj_size.y;
                pc->velocity_.y = 0.0f;
                pc->setCollidedBelow(true);
            } else {
                // æ£€æµ‹æ–œå¡ç“¦ç‰‡
                // ...
                if (height > 0.0f) {    // è¯´æ˜è‡³å°‘æœ‰ä¸€ä¸ªè§’ç‚¹å¤„äºæ–œå¡ç“¦ç‰‡
                    if (new_obj_pos.y > (tile_y + 1) * layer->getTileSize().y - obj_size.y - height) {
                        new_obj_pos.y = (tile_y + 1) * layer->getTileSize().y - obj_size.y - height;
                        pc->velocity_.y = 0.0f;     // åªæœ‰å‘ä¸‹è¿åŠ¨æ—¶æ‰éœ€è¦è®© y é€Ÿåº¦å½’é›¶
                        pc->setCollidedBelow(true);
                    }
                }
            }
        }
        else if (ds.y < 0.0f) {
            // æ£€æŸ¥é¡¶éƒ¨ç¢°æ’
            // ...
            if (tile_type_left == engine::component::TileType::SOLID || tile_type_right == engine::component::TileType::SOLID) {
                // æ’åˆ°å¤©èŠ±æ¿ï¼é€Ÿåº¦å½’é›¶ï¼Œyæ–¹å‘ç§»åŠ¨åˆ°è´´ç€å¤©èŠ±æ¿çš„ä½ç½®
                new_obj_pos.y = (tile_y + 1) * layer->getTileSize().y;
                pc->velocity_.y = 0.0f;
                pc->setCollidedAbove(true);
            }
        }
    }
    // æ›´æ–°ç‰©ä½“ä½ç½®...
}
```

### æ›´æ–°è¦ç‚¹

| ä½ç½® | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| **update() å¼€å¤´** | `resetCollisionFlags()` | æ¸…é™¤ä¸Šä¸€å¸§çš„ç¢°æ’ä¿¡æ¯ |
| **æ£€æµ‹åˆ°ç¢°æ’** | è°ƒç”¨å¯¹åº”çš„ setter | è®°å½•ç¢°æ’æ–¹å‘ |
| **æ‰€æœ‰ç¢°æ’åœºæ™¯** | ç“¦ç‰‡ã€å¯¹è±¡ã€ä¸–ç•Œè¾¹ç•Œ | å…¨é¢è®°å½•ç¢°æ’ä¿¡æ¯ |

---

## 2. æ„å»ºçŠ¶æ€æœºæ¡†æ¶

ç°åœ¨ï¼Œæˆ‘ä»¬æ¥æ­å»ºçŠ¶æ€æœºæœ¬èº«ã€‚å®ƒä¸»è¦ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼š

<img src="https://theorhythm.top/gamedev/SL/SL.065.webp" alt="ç©å®¶ç»„ä»¶ä¸çŠ¶æ€æœºç±»å›¾å…³ç³»" style="display: block; margin: auto; width: 700px;" />

### æ¶æ„ç»„æˆ

| ç»„ä»¶ | è§’è‰² | èŒè´£ |
|------|------|------|
| **PlayerState** | æŠ½è±¡åŸºç±» | å®šä¹‰æ‰€æœ‰å…·ä½“çŠ¶æ€å¿…é¡»å®ç°çš„æ¥å£ |
| **PlayerComponent** | ä¸Šä¸‹æ–‡ï¼ˆContextï¼‰ | æŒæœ‰å½“å‰çŠ¶æ€å¯¹è±¡ï¼Œè´Ÿè´£çŠ¶æ€åˆ‡æ¢ |
| **å…·ä½“ State ç±»** | çŠ¶æ€å®ç° | IdleStateã€WalkState ç­‰ï¼Œå®ç°å…·ä½“é€»è¾‘ |

---

### 2.1 çŠ¶æ€åŸºç±»ï¼šPlayerState

æˆ‘ä»¬åœ¨ `src/game/component/` ç›®å½•ä¸‹æ–°å»ºä¸€ä¸ª `state` æ–‡ä»¶å¤¹ï¼Œç”¨äºå­˜æ”¾æ‰€æœ‰ä¸ç©å®¶çŠ¶æ€ç›¸å…³çš„ä»£ç ã€‚é¦–å…ˆåˆ›å»ºçŠ¶æ€åŸºç±»ã€‚

#### src/game/component/state/player_state.hï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#pragma once
#include <memory>
#include <string>

namespace engine::core {
    class Context;
}

namespace game::component {
    class PlayerComponent;
}

namespace game::component::state {

/**
 * @brief ç©å®¶çŠ¶æ€æœºçš„æŠ½è±¡åŸºç±»ã€‚
 */
class PlayerState {
    friend class game::component::PlayerComponent;
protected:
    PlayerComponent* player_component_ = nullptr;   ///< @brief æŒ‡å‘æ‹¥æœ‰æ­¤çŠ¶æ€çš„ç©å®¶ç»„ä»¶

public:
    PlayerState(PlayerComponent* player_component) : player_component_(player_component) {}
    virtual ~PlayerState() = default;

    // ç¦æ­¢æ‹·è´å’Œç§»åŠ¨
    PlayerState(const PlayerState&) = delete;
    PlayerState& operator=(const PlayerState&) = delete;
    PlayerState(PlayerState&&) = delete;
    PlayerState& operator=(PlayerState&&) = delete;

protected:
    // æ ¸å¿ƒçŠ¶æ€æ–¹æ³•
    virtual void enter() = 0;   ///< @brief è¿›å…¥
    virtual void exit() = 0;    ///< @brief ç¦»å¼€
    virtual std::unique_ptr<PlayerState> handleInput(engine::core::Context&) = 0;   ///< @brief å¤„ç†è¾“å…¥
    virtual std::unique_ptr<PlayerState> update(float, engine::core::Context&) = 0; ///< @brief æ›´æ–°
    /* handleInput å’Œ update è¿”å›å€¼ä¸ºä¸‹ä¸€ä¸ªçŠ¶æ€ï¼Œå¦‚æœä¸éœ€è¦åˆ‡æ¢çŠ¶æ€ï¼Œåˆ™è¿”å› nullptr */

};

} // namespace game::component::state
```

### çŠ¶æ€æ¥å£è¯¦è§£

| æ–¹æ³• | è°ƒç”¨æ—¶æœº | è¿”å›å€¼ | è¯´æ˜ |
|------|---------|--------|------|
| `enter()` | è¿›å…¥çŠ¶æ€æ—¶ | void | åˆå§‹åŒ–å·¥ä½œï¼ˆå¦‚æ’­æ”¾éŸ³æ•ˆï¼‰ |
| `exit()` | é€€å‡ºçŠ¶æ€æ—¶ | void | æ¸…ç†å·¥ä½œ |
| `handleInput()` | è¾“å…¥å¤„ç†é˜¶æ®µ | `unique_ptr<PlayerState>` | æ ¹æ®è¾“å…¥å†³å®šæ˜¯å¦åˆ‡æ¢çŠ¶æ€ |
| `update()` | æ›´æ–°é˜¶æ®µ | `unique_ptr<PlayerState>` | æ ¹æ®ç‰©ç†çŠ¶æ€å†³å®šæ˜¯å¦åˆ‡æ¢ |

### ğŸ’¡ æ ¸å¿ƒè®¾è®¡

**è¿”å›å€¼æœºåˆ¶**ï¼š`handleInput` å’Œ `update` çš„è¿”å›å€¼æ˜¯ `std::unique_ptr<PlayerState>`ã€‚

| è¿”å›å€¼ | å«ä¹‰ | æ“ä½œ |
|--------|------|------|
| `nullptr` | çŠ¶æ€ä¸æ”¹å˜ | ä¿æŒå½“å‰çŠ¶æ€ |
| `std::make_unique<NewState>()` | åˆ‡æ¢åˆ°æ–°çŠ¶æ€ | PlayerComponent æ‰§è¡ŒçŠ¶æ€åˆ‡æ¢ |

è¿™ä¸ªè®¾è®¡éå¸¸ä¼˜é›…ï¼Œå°† **çŠ¶æ€åˆ‡æ¢çš„å†³ç­–æƒ** å®Œå…¨äº¤ç»™äº†çŠ¶æ€è‡ªèº«ã€‚

---

### 2.2 ä¸Šä¸‹æ–‡ï¼šPlayerComponent

`PlayerComponent` æ˜¯çŠ¶æ€æœºçš„ç®¡ç†è€…ã€‚å®ƒç»§æ‰¿è‡ªå¼•æ“çš„ `Component`ï¼Œå°†è¢«æ·»åŠ åˆ°ç©å®¶ `GameObject` ä¸Šã€‚

#### src/game/component/player_component.hï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#pragma once
#include "../../engine/component/component.h"
#include "state/player_state.h"
#include <memory>

namespace engine::input {
    class InputManager;
}
namespace engine::component {
    class TransformComponent;
    class PhysicsComponent;
    class SpriteComponent;
}

namespace game::component::state {
    class PlayerState;
}

namespace game::component {

/**
 * @brief å¤„ç†ç©å®¶è¾“å…¥ã€çŠ¶æ€å’Œæ§åˆ¶ GameObject ç§»åŠ¨çš„ç»„ä»¶ã€‚
 * ä½¿ç”¨çŠ¶æ€æ¨¡å¼ç®¡ç† Idle, Walk, Jump, Fall ç­‰çŠ¶æ€ã€‚
 */
class PlayerComponent final : public engine::component::Component {
    friend class engine::object::GameObject;
private:
    engine::component::TransformComponent* transform_component_ = nullptr; // æŒ‡å‘ TransformComponent çš„éæ‹¥æœ‰æŒ‡é’ˆ
    engine::component::SpriteComponent* sprite_component_ = nullptr;
    engine::component::PhysicsComponent* physics_component_ = nullptr;

    std::unique_ptr<state::PlayerState> current_state_;
    bool is_dead_ = false;

    // --- ç§»åŠ¨ç›¸å…³å‚æ•°
    float move_force_ = 200.0f;       ///< @brief æ°´å¹³ç§»åŠ¨åŠ›
    float max_speed_ = 120.0f;        ///< @brief æœ€å¤§ç§»åŠ¨é€Ÿåº¦ (åƒç´ /ç§’)
    float friction_factor_ = 0.85f;   ///< @brief æ‘©æ“¦ç³»æ•° (Idleæ—¶ç¼“å†²æ•ˆæœï¼Œæ¯å¸§ä¹˜ä»¥æ­¤ç³»æ•°)
    float jump_force_ = 350.0f;       ///< @brief è·³è·ƒåŠ› (æŒ‰ä¸‹"jump"é”®ç»™çš„ç¬é—´å‘ä¸Šçš„åŠ›)

public:
    PlayerComponent() = default;
    ~PlayerComponent() override = default;

    // ç¦æ­¢æ‹·è´å’Œç§»åŠ¨
    PlayerComponent(const PlayerComponent&) = delete;
    PlayerComponent& operator=(const PlayerComponent&) = delete;
    PlayerComponent(PlayerComponent&&) = delete;
    PlayerComponent& operator=(PlayerComponent&&) = delete;

    // setters and getters
    engine::component::TransformComponent* getTransformComponent() const { return transform_component_; }
    engine::component::SpriteComponent* getSpriteComponent() const { return sprite_component_; }
    engine::component::PhysicsComponent* getPhysicsComponent() const { return physics_component_; }

    void setIsDead(bool is_dead) { is_dead_ = is_dead; }           ///< @brief è®¾ç½®ç©å®¶æ˜¯å¦æ­»äº¡
    bool isDead() const { return is_dead_; }                       ///< @brief è·å–ç©å®¶æ˜¯å¦æ­»äº¡    
    void setMoveForce(float move_force) { move_force_ = move_force; }   ///< @brief è®¾ç½®æ°´å¹³ç§»åŠ¨åŠ›
    float getMoveForce() const { return move_force_; }             ///< @brief è·å–æ°´å¹³ç§»åŠ¨åŠ›  
    void setMaxSpeed(float max_speed) { max_speed_ = max_speed; }       ///< @brief è®¾ç½®æœ€å¤§ç§»åŠ¨é€Ÿåº¦
    float getMaxSpeed() const { return max_speed_; }               ///< @brief è·å–æœ€å¤§ç§»åŠ¨é€Ÿåº¦
    void setFrictionFactor(float friction_factor) { friction_factor_ = friction_factor; }   ///< @brief è®¾ç½®æ‘©æ“¦ç³»æ•°
    float getFrictionFactor() const { return friction_factor_; }       ///< @brief è·å–æ‘©æ“¦ç³»æ•°
    void setJumpForce(float jump_force) { jump_force_ = jump_force; }   ///< @brief è®¾ç½®è·³è·ƒåŠ›
    float getJumpForce() const { return jump_force_; }

    void setState(std::unique_ptr<state::PlayerState> new_state);       ///< @brief åˆ‡æ¢ç©å®¶çŠ¶æ€
    
private:
    // æ ¸å¿ƒå¾ªç¯å‡½æ•°
    void init() override;
    void handleInput(engine::core::Context& context) override;
    void update(float delta_time, engine::core::Context& context) override;
    
};

} // namespace game::component
```

#### src/game/component/player_component.cppï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#include "player_component.h"
#include "state/idle_state.h"
#include "../../engine/component/transform_component.h"
#include "../../engine/component/physics_component.h"
#include "../../engine/component/sprite_component.h"
#include "../../engine/object/game_object.h"
#include "../../engine/input/input_manager.h"
#include <utility>
#include <typeinfo>
#include <spdlog/spdlog.h>

namespace game::component {

void PlayerComponent::init() {
    if (!owner_) {
        spdlog::error("PlayerComponent æ²¡æœ‰æ‰€å±æ¸¸æˆå¯¹è±¡!");
        return;
    }

    // è·å–å¿…è¦çš„ç»„ä»¶
    transform_component_ = owner_->getComponent<engine::component::TransformComponent>();
    physics_component_ = owner_->getComponent<engine::component::PhysicsComponent>();
    sprite_component_ = owner_->getComponent<engine::component::SpriteComponent>();

    // æ£€æŸ¥å¿…è¦ç»„ä»¶æ˜¯å¦å­˜åœ¨
    if (!transform_component_ || !physics_component_ || !sprite_component_) {
        spdlog::error("Player å¯¹è±¡ç¼ºå°‘å¿…è¦ç»„ä»¶ï¼");
    }

    // åˆå§‹åŒ–çŠ¶æ€æœº
    current_state_ = std::make_unique<state::IdleState>(this);
    if (current_state_) {
        setState(std::move(current_state_));
    } else {
        spdlog::error("åˆå§‹åŒ–ç©å®¶çŠ¶æ€å¤±è´¥ï¼ˆmake_unique è¿”å›ç©ºæŒ‡é’ˆï¼‰ï¼");
    }
    spdlog::debug("PlayerComponent åˆå§‹åŒ–å®Œæˆã€‚");
}

void PlayerComponent::setState(std::unique_ptr<state::PlayerState> new_state) {
    if (!new_state) {
        spdlog::warn("å°è¯•è®¾ç½®ç©ºçš„ç©å®¶çŠ¶æ€ï¼");
        return;
    }
    if (current_state_) {
        current_state_->exit();
    }

    current_state_ = std::move(new_state);
    spdlog::debug("ç©å®¶ç»„ä»¶æ­£åœ¨åˆ‡æ¢åˆ°çŠ¶æ€: {}", typeid(*current_state_).name());
    current_state_->enter();

}

void PlayerComponent::handleInput(engine::core::Context& context) {
    if (!current_state_) return;

    auto next_state = current_state_->handleInput(context);
    if (next_state) {
        setState(std::move(next_state));
    }
}

void PlayerComponent::update(float delta_time, engine::core::Context& context) {
    if (!current_state_) return;

    auto next_state = current_state_->update(delta_time, context);
    if (next_state) {
        setState(std::move(next_state));
    }
}

} // namespace game::component
```

### PlayerComponent é€»è¾‘è¯¦è§£

| æˆå‘˜ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| **ç»„ä»¶ç¼“å­˜** | `Transform*`, `Physics*`, `Sprite*` | é¿å…æ¯æ¬¡è°ƒç”¨ `getComponent` |
| **ç§»åŠ¨å‚æ•°** | `move_force_`, `max_speed_` ç­‰ | ç©å®¶ä¸“å±çš„ç‰©ç†å‚æ•° |
| **å½“å‰çŠ¶æ€** | `unique_ptr<PlayerState>` | æŒæœ‰å½“å‰çŠ¶æ€å¯¹è±¡ |

### å…³é”®æ–¹æ³•

```
PlayerComponent æ–¹æ³•æµç¨‹ï¼š
    â†“
init()
    â†’ è·å–ç»„ä»¶æŒ‡é’ˆ
    â†’ è®¾ç½®åˆå§‹çŠ¶æ€ä¸º IdleState
    â†“
handleInput() / update()
    â†’ å§”æ‰˜ç»™ current_state_
    â†’ æ£€æŸ¥è¿”å›å€¼
    â†’ å¦‚æœéç©ºï¼Œè°ƒç”¨ setState()
    â†“
setState()
    â†’ è°ƒç”¨æ—§çŠ¶æ€çš„ exit()
    â†’ è½¬ç§»æ–°çŠ¶æ€çš„æ‰€æœ‰æƒ
    â†’ è°ƒç”¨æ–°çŠ¶æ€çš„ enter()
```

### å§”æ‰˜æ¨¡å¼

| æ–¹æ³• | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| `handleInput()` | å§”æ‰˜ç»™ `current_state_->handleInput()` | ä¸åšå…·ä½“é€»è¾‘ |
| `update()` | å§”æ‰˜ç»™ `current_state_->update()` | åªè´Ÿè´£çŠ¶æ€åˆ‡æ¢ |

---

## 3. å®ç°å…·ä½“çŠ¶æ€

æ¡†æ¶å·²ç»æ­å¥½ï¼Œç°åœ¨æˆ‘ä»¬æ¥å¡«å……å„ä¸ªå…·ä½“çš„çŠ¶æ€ã€‚

<img src="https://theorhythm.top/gamedev/SL/SL.066.webp" alt="çŠ¶æ€å˜åŒ–å…³ç³»" style="display: block; margin: auto; width: 700px;" />

### çŠ¶æ€è½¬æ¢è¡¨

| å½“å‰çŠ¶æ€ | è§¦å‘æ¡ä»¶ | ç›®æ ‡çŠ¶æ€ |
|---------|---------|---------|
| **Idle** | æŒ‰ä¸‹ç§»åŠ¨é”® | Walk |
| **Idle** | æŒ‰ä¸‹è·³è·ƒé”® | Jump |
| **Idle** | è„šä¸‹æ— åœ°é¢ | Fall |
| **Walk** | æ¾å¼€ç§»åŠ¨é”® | Idle |
| **Walk** | æŒ‰ä¸‹è·³è·ƒé”® | Jump |
| **Walk** | è„šä¸‹æ— åœ°é¢ | Fall |
| **Jump** | é€Ÿåº¦å‘ä¸‹ | Fall |
| **Fall** | ç€åœ° + æ— é€Ÿåº¦ | Idle |
| **Fall** | ç€åœ° + æœ‰é€Ÿåº¦ | Walk |

---

### 3.1 ç«™ç«‹çŠ¶æ€ IdleState

#### src/game/component/state/idle_state.hï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#pragma once
#include "player_state.h"

namespace game::component::state {

class IdleState final : public PlayerState {
    friend class game::component::PlayerComponent;
public:
    IdleState(PlayerComponent* player_component) : PlayerState(player_component) {}
    ~IdleState() override = default;

private:
    void enter() override;
    void exit() override;
    std::unique_ptr<PlayerState> handleInput(engine::core::Context&) override;
    std::unique_ptr<PlayerState> update(float delta_time, engine::core::Context&) override;
};

} // namespace game::component::state
```

#### src/game/component/state/idle_state.cppï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#include "idle_state.h"
#include "fall_state.h"
#include "jump_state.h"
#include "walk_state.h"
#include "../player_component.h"
#include "../../../engine/core/context.h"
#include "../../../engine/input/input_manager.h"
#include "../../../engine/component/physics_component.h"
#include <spdlog/spdlog.h>

namespace game::component::state {

void IdleState::enter() {

}

void IdleState::exit() {

}

std::unique_ptr<PlayerState> IdleState::handleInput(engine::core::Context& context)
{
    auto input_manager = context.getInputManager();
    // å¦‚æœæŒ‰ä¸‹äº†å·¦å³ç§»åŠ¨é”®ï¼Œåˆ™åˆ‡æ¢åˆ° WalkState
    if (input_manager.isActionDown("move_left") || input_manager.isActionDown("move_right")) {
        return std::make_unique<WalkState>(player_component_);
    }

    // å¦‚æœæŒ‰ä¸‹"jump"åˆ™åˆ‡æ¢åˆ° JumpState
    if (input_manager.isActionPressed("jump")) {
        return std::make_unique<JumpState>(player_component_);
    }
    return nullptr;
}

std::unique_ptr<PlayerState> IdleState::update(float, engine::core::Context&)
{
    // åº”ç”¨æ‘©æ“¦åŠ›(æ°´å¹³æ–¹å‘)
    auto physics_component = player_component_->getPhysicsComponent();
    auto friction_factor = player_component_->getFrictionFactor();
    physics_component->velocity_.x *= friction_factor;

    // å¦‚æœä¸‹æ–¹æ²¡æœ‰ç¢°æ’ï¼Œåˆ™åˆ‡æ¢åˆ° FallState
    if (!physics_component->hasCollidedBelow()) {
        return std::make_unique<FallState>(player_component_);
    }
    return nullptr;
}

} // namespace game::component::state
```

### IdleState é€»è¾‘

| é˜¶æ®µ | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| **handleInput** | æ£€æŸ¥ç§»åŠ¨é”® | æŒ‰ä¸‹ â†’ è¿”å› `WalkState` |
| | æ£€æŸ¥è·³è·ƒé”® | æŒ‰ä¸‹ â†’ è¿”å› `JumpState` |
| **update** | åº”ç”¨æ‘©æ“¦åŠ› | `velocity.x *= friction_factor` |
| | æ£€æŸ¥åœ°é¢ | æ— åœ°é¢ â†’ è¿”å› `FallState` |

### æ‘©æ“¦åŠ›æ•ˆæœ

```
æ‘©æ“¦åŠ›æ¨¡æ‹Ÿï¼š
å¸§1: velocity.x = 100
å¸§2: velocity.x = 100 * 0.85 = 85
å¸§3: velocity.x = 85 * 0.85 = 72.25
...
â†’ å¹³æ»‘åœæ­¢
```

---

### 3.2 è¡Œèµ°çŠ¶æ€ WalkState

#### src/game/component/state/walk_state.hï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#pragma once
#include "player_state.h"

namespace game::component::state {

class WalkState final : public PlayerState {
    friend class game::component::PlayerComponent;
public:
    WalkState(PlayerComponent* player_component) : PlayerState(player_component) {}
    ~WalkState() override = default;

private:
    void enter() override;
    void exit() override;
    std::unique_ptr<PlayerState> handleInput(engine::core::Context&) override;
    std::unique_ptr<PlayerState> update(float delta_time, engine::core::Context&) override;
};

} // namespace game::component::state
```

#### src/game/component/state/walk_state.cppï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#include "walk_state.h"
#include "jump_state.h"
#include "fall_state.h"
#include "idle_state.h"
#include "../player_component.h"
#include "../../../engine/core/context.h"
#include "../../../engine/input/input_manager.h"
#include "../../../engine/object/game_object.h"
#include "../../../engine/component/physics_component.h"
#include "../../../engine/component/sprite_component.h"
#include <glm/common.hpp>


namespace game::component::state {

void WalkState::enter() {

}

void WalkState::exit() {

}

std::unique_ptr<PlayerState> WalkState::handleInput(engine::core::Context& context)
{
    auto input_manager = context.getInputManager();
    auto physics_component = player_component_->getPhysicsComponent();
    auto sprite_component = player_component_->getSpriteComponent();

    // å¦‚æœæŒ‰ä¸‹"jump"åˆ™åˆ‡æ¢åˆ° JumpState
    if (input_manager.isActionPressed("jump")) {
        return std::make_unique<JumpState>(player_component_);
    }
    
    // æ­¥è¡ŒçŠ¶æ€å¯ä»¥å·¦å³ç§»åŠ¨
    if (input_manager.isActionDown("move_left")) {
        if (physics_component->velocity_.x > 0.0f) {
            physics_component->velocity_.x = 0.0f;  // å¦‚æœå½“å‰é€Ÿåº¦æ˜¯å‘å³çš„ï¼Œåˆ™å…ˆå‡é€Ÿåˆ°0 (å¢å¼ºæ“æ§æ‰‹æ„Ÿ)
        }
        // æ·»åŠ å‘å·¦çš„æ°´å¹³åŠ›
        physics_component->addForce({-player_component_->getMoveForce(), 0.0f});
        sprite_component->setFlipped(true);       // å‘å·¦ç§»åŠ¨æ—¶ç¿»è½¬
    } else if (input_manager.isActionDown("move_right")) {
        if (physics_component->velocity_.x < 0.0f) {
            physics_component->velocity_.x = 0.0f;  // å¦‚æœå½“å‰é€Ÿåº¦æ˜¯å‘å·¦çš„ï¼Œåˆ™å…ˆå‡é€Ÿåˆ°0
        }
        // æ·»åŠ å‘å³çš„æ°´å¹³åŠ›
        physics_component->addForce({player_component_->getMoveForce(), 0.0f});
        sprite_component->setFlipped(false);       // å‘å³ç§»åŠ¨æ—¶ä¸ç¿»è½¬
    } else {
        // å¦‚æœæ²¡æœ‰æŒ‰ä¸‹å·¦å³ç§»åŠ¨é”®ï¼Œåˆ™åˆ‡æ¢åˆ° IdleState
        return std::make_unique<IdleState>(player_component_);
    }
    return nullptr;
}

std::unique_ptr<PlayerState> WalkState::update(float, engine::core::Context&)
{
    // é™åˆ¶æœ€å¤§é€Ÿåº¦
    auto physics_component = player_component_->getPhysicsComponent();
    auto max_speed = player_component_->getMaxSpeed();
    physics_component->velocity_.x = glm::clamp(physics_component->velocity_.x, -max_speed, max_speed);

    // å¦‚æœä¸‹æ–¹æ²¡æœ‰ç¢°æ’ï¼Œåˆ™åˆ‡æ¢åˆ° FallState
    if (!physics_component->hasCollidedBelow()) {
        return std::make_unique<FallState>(player_component_);
    }
    
    return nullptr;
}

} // namespace game::component::state
```

### WalkState é€»è¾‘

| é˜¶æ®µ | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| **handleInput** | ä¼˜å…ˆæ£€æµ‹è·³è·ƒ | æŒ‰ä¸‹ â†’ è¿”å› `JumpState` |
| | æ£€æµ‹å·¦ç§»åŠ¨é”® | æ–½åŠ å‘å·¦çš„åŠ› + ç¿»è½¬ç²¾çµ |
| | æ£€æµ‹å³ç§»åŠ¨é”® | æ–½åŠ å‘å³çš„åŠ› + å–æ¶ˆç¿»è½¬ |
| | æ— ç§»åŠ¨é”® | è¿”å› `IdleState` |
| **update** | é™åˆ¶æœ€å¤§é€Ÿåº¦ | `glm::clamp()` |
| | æ£€æŸ¥åœ°é¢ | æ— åœ°é¢ â†’ è¿”å› `FallState` |

### ğŸ’¡ æ“æ§ä¼˜åŒ–æŠ€å·§

```cpp
if (physics_component->velocity_.x > 0.0f) {
    physics_component->velocity_.x = 0.0f;  // æ”¹å˜æ–¹å‘æ—¶å…ˆæ¸…é›¶
}
```

**æ•ˆæœ**ï¼šè®©ç©å®¶è½¬å‘æ›´çµæ•ï¼Œæå‡æ“æ§æ‰‹æ„Ÿã€‚

---

### 3.3 è·³è·ƒçŠ¶æ€ JumpState

#### src/game/component/state/jump_state.hï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#pragma once
#include "player_state.h"

namespace game::component::state {

class JumpState final : public PlayerState {
    friend class game::component::PlayerComponent;
public:
    JumpState(PlayerComponent* player_component) : PlayerState(player_component) {}
    ~JumpState() override = default;

private:
    void enter() override;
    void exit() override;
    std::unique_ptr<PlayerState> handleInput(engine::core::Context&) override;
    std::unique_ptr<PlayerState> update(float delta_time, engine::core::Context&) override;
};

} // namespace game::component::state
```

#### src/game/component/state/jump_state.cppï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#include "jump_state.h"
#include "idle_state.h"
#include "walk_state.h"
#include "fall_state.h"
#include "../player_component.h"
#include "../../../engine/core/context.h"
#include "../../../engine/input/input_manager.h"
#include "../../../engine/component/physics_component.h"
#include "../../../engine/component/sprite_component.h"
#include <glm/common.hpp>
#include <spdlog/spdlog.h>

namespace game::component::state {

void JumpState::enter() {
    auto physics_component = player_component_->getPhysicsComponent();
    physics_component->velocity_.y = -player_component_->getJumpForce(); // å‘ä¸Šè·³è·ƒ
    spdlog::debug("PlayerComponent è¿›å…¥ JumpStateï¼Œè®¾ç½®åˆå§‹å‚ç›´é€Ÿåº¦ä¸º: {}", physics_component->velocity_.y);
}

void JumpState::exit() {

}

std::unique_ptr<PlayerState> JumpState::handleInput(engine::core::Context& context)
{
    auto input_manager = context.getInputManager();
    auto physics_component = player_component_->getPhysicsComponent();
    auto sprite_component = player_component_->getSpriteComponent();

    // è·³è·ƒçŠ¶æ€ä¸‹å¯ä»¥å·¦å³ç§»åŠ¨
    if (input_manager.isActionDown("move_left")) {
        if (physics_component->velocity_.x > 0.0f) physics_component->velocity_.x = 0.0f;
        physics_component->addForce({-player_component_->getMoveForce(), 0.0f});
        sprite_component->setFlipped(true);
    } else if (input_manager.isActionDown("move_right")) {
        if (physics_component->velocity_.x < 0.0f) physics_component->velocity_.x = 0.0f;
        physics_component->addForce({player_component_->getMoveForce(), 0.0f});
        sprite_component->setFlipped(false);
    }
    return nullptr;
}

std::unique_ptr<PlayerState> JumpState::update(float, engine::core::Context&)
{
    // é™åˆ¶æœ€å¤§é€Ÿåº¦(æ°´å¹³æ–¹å‘)
    auto physics_component = player_component_->getPhysicsComponent();
    auto max_speed = player_component_->getMaxSpeed();
    physics_component->velocity_.x = glm::clamp(physics_component->velocity_.x, -max_speed, max_speed);

    // å¦‚æœé€Ÿåº¦ä¸ºæ­£ï¼Œåˆ‡æ¢åˆ° FallState
    if (physics_component->velocity_.y > 0.0f) {
        return std::make_unique<FallState>(player_component_);
    }

    return nullptr;
}

} // namespace game::component::state
```

### JumpState é€»è¾‘

| é˜¶æ®µ | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| **enter()** | **è®¾ç½®å‘ä¸Šé€Ÿåº¦** | `velocity.y = -jump_force_` |
| | | **è¿™æ˜¯è·³è·ƒçš„æ ¸å¿ƒå®ç°ï¼** |
| **handleInput** | å…è®¸ç©ºä¸­å·¦å³ç§»åŠ¨ | ç©ºä¸­æ§åˆ¶ |
| **update** | é™åˆ¶æ°´å¹³é€Ÿåº¦ | `glm::clamp()` |
| | æ£€æŸ¥å‚ç›´é€Ÿåº¦ | `velocity.y > 0` â†’ è¿”å› `FallState` |

### ğŸ’¡ è·³è·ƒå®ç°åŸç†

```
è·³è·ƒè¿‡ç¨‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ enter() è¢«è°ƒç”¨      â”‚
â”‚ velocity.y = -350  â”‚ â† ç¬æ—¶å‘ä¸Šé€Ÿåº¦
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â†“ é‡åŠ›æ¯å¸§ä½œç”¨
    velocity.y é€æ¸å¢å¤§
         â”‚
         â†“ velocity.y ä»è´Ÿæ•°å˜ä¸ºæ­£æ•°
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ update() æ£€æµ‹åˆ°     â”‚
â”‚ velocity.y > 0     â”‚ â†’ åˆ‡æ¢åˆ° FallState
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 3.4 ä¸‹è½çŠ¶æ€ FallState

#### src/game/component/state/fall_state.hï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#pragma once
#include "player_state.h"

namespace game::component::state {

class FallState final : public PlayerState {
    friend class game::component::PlayerComponent;
public:
    FallState(PlayerComponent* player_component) : PlayerState(player_component) {}
    ~FallState() override = default;

private:
    void enter() override;
    void exit() override;
    std::unique_ptr<PlayerState> handleInput(engine::core::Context&) override;
    std::unique_ptr<PlayerState> update(float delta_time, engine::core::Context&) override;
};

} // namespace game::component::state
```

#### src/game/component/state/fall_state.cppï¼ˆæ–°å»ºæ–‡ä»¶ï¼‰

```cpp
#include "fall_state.h"
#include "idle_state.h"
#include "walk_state.h"
#include "../player_component.h"
#include "../../../engine/core/context.h"
#include "../../../engine/input/input_manager.h"
#include "../../../engine/component/physics_component.h"
#include "../../../engine/component/sprite_component.h"
#include <glm/common.hpp>

namespace game::component::state {

void FallState::enter() {

}

void FallState::exit() {

}

std::unique_ptr<PlayerState> FallState::handleInput(engine::core::Context& context)
{
    auto input_manager = context.getInputManager();
    auto physics_component = player_component_->getPhysicsComponent();
    auto sprite_component = player_component_->getSpriteComponent();

    // ä¸‹è½çŠ¶æ€ä¸‹å¯ä»¥å·¦å³ç§»åŠ¨
    if (input_manager.isActionDown("move_left")) {
        if (physics_component->velocity_.x > 0.0f) physics_component->velocity_.x = 0.0f;
        physics_component->addForce({-player_component_->getMoveForce(), 0.0f});
        sprite_component->setFlipped(true);
    } else if (input_manager.isActionDown("move_right")) {
        if (physics_component->velocity_.x < 0.0f) physics_component->velocity_.x = 0.0f;
        physics_component->addForce({player_component_->getMoveForce(), 0.0f});
        sprite_component->setFlipped(false);
    }
    return nullptr;
}

std::unique_ptr<PlayerState> FallState::update(float, engine::core::Context&)
{
    // é™åˆ¶æœ€å¤§é€Ÿåº¦(æ°´å¹³æ–¹å‘)
    auto physics_component = player_component_->getPhysicsComponent();
    auto max_speed = player_component_->getMaxSpeed();
    physics_component->velocity_.x = glm::clamp(physics_component->velocity_.x, -max_speed, max_speed);

    // å¦‚æœä¸‹æ–¹æœ‰ç¢°æ’ï¼Œåˆ™æ ¹æ®æ°´å¹³é€Ÿåº¦æ¥å†³å®š åˆ‡æ¢åˆ° IdleState æˆ– WalkState
    if (physics_component->hasCollidedBelow()) {
        if (glm::abs(physics_component->velocity_.x) < 1.0f) {
            return std::make_unique<IdleState>(player_component_);
        } else {
            return std::make_unique<WalkState>(player_component_);
        }
    }
    return nullptr;
}

} // namespace game::component::state
```

### FallState é€»è¾‘

| é˜¶æ®µ | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| **handleInput** | å…è®¸ç©ºä¸­å·¦å³ç§»åŠ¨ | ä¸ JumpState ç›¸åŒ |
| **update** | é™åˆ¶æ°´å¹³é€Ÿåº¦ | `glm::clamp()` |
| | æ£€æŸ¥æ˜¯å¦ç€åœ° | `hasCollidedBelow()` |
| | ç€åœ°ååˆ¤æ–­ | é€Ÿåº¦å° â†’ `IdleState` |
| | | é€Ÿåº¦å¤§ â†’ `WalkState` |

### ğŸ’¡ ç€åœ°é€»è¾‘ä¼˜åŒ–

```cpp
if (glm::abs(physics_component->velocity_.x) < 1.0f) {
    return std::make_unique<IdleState>(player_component_);
} else {
    return std::make_unique<WalkState>(player_component_);
}
```

**æ•ˆæœ**ï¼šè½åœ°åå¦‚æœæœ‰æ°´å¹³é€Ÿåº¦ï¼Œä¼šç»§ç»­è¡Œèµ°ï¼Œæ„Ÿè§‰æ›´è‡ªç„¶ã€‚

---

## 4. é›†æˆåˆ° GameScene

ç°åœ¨ï¼Œä¸‡äº‹ä¿±å¤‡ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨ `GameScene` ä¸­ä½¿ç”¨æ–°çš„ `PlayerComponent`ï¼Œå¹¶ç§»é™¤æ—§çš„æµ‹è¯•ä»£ç ã€‚

### src/game/scene/game_scene.hï¼ˆæ›´æ–°ï¼‰

```cpp
class GameScene final: public engine::scene::Scene {
    // ...
private:
    [[nodiscard]] bool initLevel();               ///< @brief åˆå§‹åŒ–å…³å¡
    [[nodiscard]] bool initPlayer();              ///< @brief åˆå§‹åŒ–ç©å®¶
}
```

### src/game/scene/game_scene.cppï¼ˆæ›´æ–°ï¼‰

```cpp
void GameScene::init() {
    if (is_initialized_) {
        spdlog::warn("GameScene å·²ç»åˆå§‹åŒ–è¿‡äº†ï¼Œé‡å¤è°ƒç”¨ init()ã€‚");
        return;
    }
    spdlog::trace("GameScene åˆå§‹åŒ–å¼€å§‹...");

    if (!initLevel()) {
        spdlog::error("å…³å¡åˆå§‹åŒ–å¤±è´¥ï¼Œæ— æ³•ç»§ç»­ã€‚");
        context_.getInputManager().setShouldQuit(true);
        return;
    }
    if (!initPlayer()) {
        spdlog::error("ç©å®¶åˆå§‹åŒ–å¤±è´¥ï¼Œæ— æ³•ç»§ç»­ã€‚");
        context_.getInputManager().setShouldQuit(true);
        return;
    }

    Scene::init();
    spdlog::trace("GameScene åˆå§‹åŒ–å®Œæˆã€‚");
}

bool GameScene::initLevel()
{
    // åŠ è½½å…³å¡ï¼ˆlevel_loaderé€šå¸¸åŠ è½½å®Œæˆåå³å¯é”€æ¯ï¼Œå› æ­¤ä¸å­˜ä¸ºæˆå‘˜å˜é‡ï¼‰
    engine::scene::LevelLoader level_loader;
    if (!level_loader.loadLevel("assets/maps/level1.tmj", *this)){
        spdlog::error("å…³å¡åŠ è½½å¤±è´¥");
        return false;
    }

    // æ³¨å†Œ"main"å±‚åˆ°ç‰©ç†å¼•æ“
    auto* main_layer = findGameObjectByName("main");
    if (!main_layer) {
        spdlog::error("æœªæ‰¾åˆ°\"main\"å±‚");
        return false;
    }
    auto* tile_layer = main_layer->getComponent<engine::component::TileLayerComponent>();
    if (!tile_layer) {
        spdlog::error("\"main\"å±‚æ²¡æœ‰ TileLayerComponent ç»„ä»¶");
        return false;
    }
    context_.getPhysicsEngine().registerCollisionLayer(tile_layer);
    spdlog::info("æ³¨å†Œ\"main\"å±‚åˆ°ç‰©ç†å¼•æ“");
    
    // è®¾ç½®ç›¸æœºè¾¹ç•Œ
    auto world_size = main_layer->getComponent<engine::component::TileLayerComponent>()->getWorldSize();
    context_.getCamera().setLimitBounds(engine::utils::Rect(glm::vec2(0.0f), world_size));

    // è®¾ç½®ä¸–ç•Œè¾¹ç•Œ
    context_.getPhysicsEngine().setWorldBounds(engine::utils::Rect(glm::vec2(0.0f), world_size));

    spdlog::trace("å…³å¡åˆå§‹åŒ–å®Œæˆã€‚");
    return true;
}

bool GameScene::initPlayer()
{
    // è·å–ç©å®¶å¯¹è±¡
    player_ = findGameObjectByName("player");
    if (!player_) {
        spdlog::error("æœªæ‰¾åˆ°ç©å®¶å¯¹è±¡");
        return false;
    }

    // æ·»åŠ PlayerComponentåˆ°ç©å®¶å¯¹è±¡
    auto* player_component = player_->addComponent<game::component::PlayerComponent>();
    if (!player_component) {
        spdlog::error("æ— æ³•æ·»åŠ  PlayerComponent åˆ°ç©å®¶å¯¹è±¡");
        return false;
    }

    // ç›¸æœºè·Ÿéšç©å®¶
    auto* player_transform = player_->getComponent<engine::component::TransformComponent>();
    if (!player_transform) {
        spdlog::error("ç©å®¶å¯¹è±¡æ²¡æœ‰ TransformComponent ç»„ä»¶, æ— æ³•è®¾ç½®ç›¸æœºç›®æ ‡");
        return false;
    }
    context_.getCamera().setTarget(player_transform);
    spdlog::trace("Playeråˆå§‹åŒ–å®Œæˆã€‚");
    return true;
}
```

### é‡æ„è¦ç‚¹

| æ“ä½œ | è¯´æ˜ | ä¼˜åŠ¿ |
|------|------|------|
| **ç§»é™¤æµ‹è¯•å‡½æ•°** | åˆ é™¤ `TestPlayer` ç­‰ | ä»£ç æ›´ç®€æ´ |
| **æ‹†åˆ† init** | `initLevel()` + `initPlayer()` | èŒè´£æ›´å•ä¸€ |
| **æ·»åŠ  PlayerComponent** | `addComponent<PlayerComponent>()` | **çŠ¶æ€æœºè‡ªåŠ¨è¿è½¬** |
| **ç®€åŒ–å¾ªç¯** | åªè°ƒç”¨åŸºç±»æ–¹æ³• | å¼•æ“è‡ªåŠ¨å¤„ç† |

### é›†æˆæµç¨‹

```
GameScene åˆå§‹åŒ–ï¼š
    â†“
initLevel()
    â†’ åŠ è½½åœ°å›¾
    â†’ æ³¨å†Œç¢°æ’å±‚
    â†’ è®¾ç½®è¾¹ç•Œ
    â†“
initPlayer()
    â†’ æŸ¥æ‰¾ç©å®¶å¯¹è±¡
    â†’ æ·»åŠ  PlayerComponent â† æ ¸å¿ƒï¼
    â†’ è®¾ç½®ç›¸æœºç›®æ ‡
    â†“
Scene::init()
    â†’ åˆå§‹åŒ–æ‰€æœ‰ GameObject
    â†’ åˆå§‹åŒ–æ‰€æœ‰ Component
    â†“
æ¸¸æˆå¾ªç¯ï¼š
    handleInput()
        â†’ PlayerComponent::handleInput()
        â†’ çŠ¶æ€æœºå¤„ç†è¾“å…¥
    update()
        â†’ PlayerComponent::update()
        â†’ çŠ¶æ€æœºæ›´æ–°é€»è¾‘
```

---

## 5. ç¼–è¯‘ä¸è°ƒè¯•

æœ€åï¼Œå°†æ–°åˆ›å»ºçš„æ‰€æœ‰ `.cpp` æ–‡ä»¶æ·»åŠ åˆ° `CMakeLists.txt` ä¸­ï¼Œå¹¶æ‰“å¼€ `main.cpp` ä¸­çš„ debug æ—¥å¿—ï¼Œæ–¹ä¾¿æˆ‘ä»¬è§‚å¯Ÿã€‚

### src/main.cppï¼ˆæ›´æ–°ï¼‰

```cpp
int main(int /* argc */, char* /* argv */[]) {
    spdlog::set_level(spdlog::level::debug);
    // ...
}
```

### è°ƒè¯•æŠ€å·§

| æ“ä½œ | è¯´æ˜ | æ•ˆæœ |
|------|------|------|
| **å¼€å¯ debug æ—¥å¿—** | `spdlog::set_level(debug)` | æ˜¾ç¤ºçŠ¶æ€åˆ‡æ¢ä¿¡æ¯ |
| **è§‚å¯Ÿæ§åˆ¶å°** | æŸ¥çœ‹çŠ¶æ€è½¬æ¢æ—¥å¿— | ç†è§£çŠ¶æ€æœºè¿è¡Œ |
| **typeid è¾“å‡º** | `typeid(*current_state_).name()` | æ˜¾ç¤ºå½“å‰çŠ¶æ€ç±»å‹ |

### é¢„æœŸè¾“å‡º

```
æ§åˆ¶å°æ—¥å¿—ç¤ºä¾‹ï¼š
[debug] PlayerComponent åˆå§‹åŒ–å®Œæˆã€‚
[debug] ç©å®¶ç»„ä»¶æ­£åœ¨åˆ‡æ¢åˆ°çŠ¶æ€: IdleState
[debug] ç©å®¶ç»„ä»¶æ­£åœ¨åˆ‡æ¢åˆ°çŠ¶æ€: WalkState
[debug] ç©å®¶ç»„ä»¶æ­£åœ¨åˆ‡æ¢åˆ°çŠ¶æ€: JumpState
[debug] PlayerComponent è¿›å…¥ JumpStateï¼Œè®¾ç½®åˆå§‹å‚ç›´é€Ÿåº¦ä¸º: -350
[debug] ç©å®¶ç»„ä»¶æ­£åœ¨åˆ‡æ¢åˆ°çŠ¶æ€: FallState
[debug] ç©å®¶ç»„ä»¶æ­£åœ¨åˆ‡æ¢åˆ°çŠ¶æ€: IdleState
```

---

## âœ… ç¼–è¯‘ä¸è¿è¡Œ

é‡æ–°ç¼–è¯‘å¹¶è¿è¡Œé¡¹ç›®ã€‚ä½ ä¼šå‘ç°ï¼š

```
è¿è¡Œæ•ˆæœï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ‘¤ â† Idle              â”‚
â”‚  â”â”â”â”â”â”â”â”â”             â”‚
â”‚                          â”‚
â”‚  ğŸƒ â† Walk              â”‚
â”‚  â”â”â”â”â”â”â”â”â”             â”‚
â”‚                          â”‚
â”‚    â†‘                     â”‚
â”‚   ğŸ‘¤ â† Jump             â”‚
â”‚  â”â”â”â”â”â”â”â”â”             â”‚
â”‚                          â”‚
â”‚   ğŸ‘¤                     â”‚
â”‚    â†“ â† Fall             â”‚
â”‚  â”â”â”â”â”â”â”â”â”             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä½ ä¼šçœ‹åˆ°ï¼š**
- âœ… ç©å®¶è¡Œä¸ºä¸ä¹‹å‰ç±»ä¼¼ï¼Œä½†ç”±çŠ¶æ€æœºé©±åŠ¨
- âœ… æ§åˆ¶å°æ¸…æ™°æ˜¾ç¤ºçŠ¶æ€åˆ‡æ¢è¿‡ç¨‹
- âœ… ä»£ç ç»“æ„äº•äº•æœ‰æ¡ï¼Œæ˜“äºæ‰©å±•
- âœ… å®Œå…¨è§£è€¦çš„ç©å®¶é€»è¾‘

---

## ğŸ¯ ç³»ç»Ÿæ¶æ„æ€»ç»“

### å®Œæ•´çš„çŠ¶æ€æœºæµç¨‹

```
1. PlayerComponent åˆå§‹åŒ–
   â†“ åˆ›å»º IdleState
2. æ¸¸æˆå¾ªç¯
   â†“ handleInput()
3. å½“å‰çŠ¶æ€å¤„ç†è¾“å…¥
   â†“ è¿”å›æ–°çŠ¶æ€æˆ– nullptr
4. PlayerComponent æ£€æŸ¥è¿”å›å€¼
   â†“ å¦‚æœéç©ºï¼Œè°ƒç”¨ setState()
5. setState() æ‰§è¡Œåˆ‡æ¢
   â†“ old_state->exit()
   â†“ new_state->enter()
6. ä¸‹ä¸€å¸§ç»§ç»­å¾ªç¯
```

### æ ¸å¿ƒæˆå°±

æˆ‘ä»¬æˆåŠŸåœ°ï¼š

1. âœ… **çŠ¶æ€è®¾è®¡æ¨¡å¼**ï¼šä¼˜é›…çš„çŠ¶æ€ç®¡ç†æ¶æ„
2. âœ… **å››ç§åŸºæœ¬çŠ¶æ€**ï¼šIdleã€Walkã€Jumpã€Fall
3. âœ… **ç¢°æ’ä¿¡æ¯ç³»ç»Ÿ**ï¼šç‰©ç†å¼•æ“æä¾›çŠ¶æ€åˆ¤æ–­ä¾æ®
4. âœ… **ç»„ä»¶åŒ–è®¾è®¡**ï¼šPlayerComponent å®Œå…¨è§£è€¦
5. âœ… **è‡ªåŠ¨çŠ¶æ€åˆ‡æ¢**ï¼šåŸºäºè¾“å…¥å’Œç‰©ç†çŠ¶æ€
6. âœ… **æ˜“äºæ‰©å±•**ï¼šè½»æ¾æ·»åŠ æ–°çŠ¶æ€

### çŠ¶æ€æ¨¡å¼çš„ä¼˜åŠ¿

| å¯¹æ¯”é¡¹ | ä¼ ç»Ÿ if-else | çŠ¶æ€æ¨¡å¼ |
|--------|-------------|---------|
| **å¯è¯»æ€§** | âŒ åµŒå¥—å¤æ‚ | âœ… æ¸…æ™°æ˜äº† |
| **å¯ç»´æŠ¤æ€§** | âŒ éš¾ä»¥ä¿®æ”¹ | âœ… ç‹¬ç«‹ä¿®æ”¹ |
| **å¯æ‰©å±•æ€§** | âŒ éœ€è¦ä¿®æ”¹å¤šå¤„ | âœ… åªéœ€æ·»åŠ æ–°ç±» |
| **çŠ¶æ€æ˜ç¡®** | âŒ éš¾ä»¥åˆ¤æ–­å½“å‰çŠ¶æ€ | âœ… ä¸€ç›®äº†ç„¶ |
| **é€»è¾‘åˆ†æ•£** | âŒ é›†ä¸­åœ¨ä¸€ä¸ªå‡½æ•° | âœ… æ¯ä¸ªçŠ¶æ€ç‹¬ç«‹ |

### æ¶æ„ä¼˜åŠ¿

```
ç»„ä»¶åŒ–è®¾è®¡ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GameObject   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Transform    â”‚
â”‚ Physics      â”‚
â”‚ Sprite       â”‚
â”‚ Player â†æ–°å¢ â”‚ â† ä¸“é—¨çš„ç©å®¶é€»è¾‘ç»„ä»¶
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
å®Œå…¨è§£è€¦ï¼Œå¯å¤ç”¨
```

---

## ğŸ“š æ€»ç»“

æˆ‘ä»¬å®Œæˆäº†ä¸€æ¬¡ **æ„ä¹‰é‡å¤§çš„é‡æ„**ï¼

**å…³é”®è¦ç‚¹ï¼š**
- ğŸ¯ çŠ¶æ€è®¾è®¡æ¨¡å¼å°†è¡Œä¸ºå°è£…æˆç‹¬ç«‹å¯¹è±¡
- ğŸ”„ PlayerComponent ä½œä¸ºä¸Šä¸‹æ–‡ç®¡ç†çŠ¶æ€
- ğŸ“Š ç‰©ç†å¼•æ“æä¾›ç¢°æ’ä¿¡æ¯ä¾›çŠ¶æ€åˆ¤æ–­
- ğŸ® å››ç§åŸºæœ¬çŠ¶æ€è¦†ç›–å¸¸è§ç©å®¶è¡Œä¸º
- ğŸ§© æ¯ä¸ªçŠ¶æ€ç‹¬ç«‹å®ç°ï¼Œæ˜“äºç»´æŠ¤
- âš¡ è‡ªåŠ¨å§”æ‰˜æœºåˆ¶è®©ä»£ç æ¸…æ™°ç®€æ´

> ğŸ’¡ **è®¾è®¡å“²å­¦**ï¼šçŠ¶æ€æ¨¡å¼æ˜¯é¢å‘å¯¹è±¡è®¾è®¡çš„ç»å…¸æ¨¡å¼ä¹‹ä¸€ã€‚å®ƒé€šè¿‡å°†æ¯ç§è¡Œä¸ºå°è£…æˆç‹¬ç«‹çš„ç±»ï¼Œé¿å…äº†å¤æ‚çš„ if-else åµŒå¥—ï¼Œè®©ä»£ç ç»“æ„å¼‚å¸¸æ¸…æ™°ã€‚è¿™ä¸ä»…è®©å½“å‰çš„é€»è¾‘æ›´æ˜“ç»´æŠ¤ï¼Œä¹Ÿä¸ºæœªæ¥æ·»åŠ æ›´å¤æ‚çš„è¡Œä¸ºï¼ˆå¦‚æ”»å‡»ã€æ”€çˆ¬ã€å—ä¼¤ï¼‰æ‰“ä¸‹äº†åšå®çš„åŸºç¡€ã€‚è¿™æ˜¯ä»"èƒ½è¿è¡Œ"åˆ°"å¥½ç»´æŠ¤"çš„å…³é”®ä¸€æ­¥ï¼

---

## ğŸš€ ä¸‹ä¸€æ­¥å±•æœ›

ç°åœ¨æˆ‘ä»¬æœ‰äº†å¼ºå¤§çš„çŠ¶æ€æœºç³»ç»Ÿï¼ä½†ç©å®¶çœ‹èµ·æ¥è¿˜æ˜¯é™æ€çš„ï¼š

- â“ å¦‚ä½•ä¸ºæ¯ä¸ªçŠ¶æ€æ·»åŠ åŠ¨ç”»ï¼Ÿ
- â“ å¦‚ä½•ç®¡ç†å’Œæ’­æ”¾åŠ¨ç”»åºåˆ—ï¼Ÿ
- â“ å¦‚ä½•è®©åŠ¨ç”»ä¸çŠ¶æ€è‡ªåŠ¨åŒæ­¥ï¼Ÿ

ä¸‹ä¸€è¯¾ï¼Œæˆ‘ä»¬å°†å®ç° **åŠ¨ç”»ç»„ä»¶ä¸åŠ¨ç”»è½½å…¥**ï¼š

- ğŸ¬ åŠ¨ç”»ç³»ç»Ÿæ¶æ„
- ğŸ“½ï¸ åºåˆ—å¸§åŠ¨ç”»æ’­æ”¾
- ğŸ”— çŠ¶æ€ä¸åŠ¨ç”»è”åŠ¨

è®©ç©å®¶çœŸæ­£åœ°"æ´»"èµ·æ¥ï¼ğŸ®ğŸŒŸ