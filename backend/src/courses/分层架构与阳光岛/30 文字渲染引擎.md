# 文字渲染引擎

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1Z9bszWEuY&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1Z9bszWEuY)

## 📌 问题背景

欢迎来到《C++游戏开发之旅》的第30课！到目前为止，我们的"阳光岛"在视觉、听觉和交互方面已经相当完善，但它还缺少一个至关重要的元素——**文字**。没有文字，我们无法向玩家展示他们的得分、剩余生命，更无法构建菜单和对话系统。

### ⚠️ 当前的问题

```
无文字的游戏：
┌─────────────────────────┐
│   👤 玩家               │
│   💎 得分: ???          │
│   ❤️ 生命: ???          │
│   🎮 UI: ???            │
│                          │
│ ❌ 无法显示得分          │
│ ❌ 无法显示生命值        │
│ ❌ 无法构建菜单          │
│ ❌ 无法显示对话          │
└─────────────────────────┘
```

| 问题 | 说明 | 影响 |
|------|------|------|
| **无文字渲染** | 无法显示任何文本信息 | 玩家不知道游戏状态 |
| **无UI反馈** | 缺少界面元素 | 用户体验差 |
| **无菜单系统** | 无法构建游戏菜单 | 功能不完整 |
| **无对话系统** | 无法显示剧情文本 | 缺少叙事能力 |

### 💡 解决方案：文字渲染引擎

<img src="https://theorhythm.top/gamedev/SL/SL.087.webp" alt="文字渲染引擎" style="display: block; margin: auto; width: 700px;" />

**核心思想**：
1. 使用 SDL_ttf 库渲染文字
2. 创建通用的 TextRenderer 类
3. 区分UI文本和世界文本
4. 集成到引擎核心

```
文字渲染系统架构：
┌──────────────────┐
│   SDL_ttf        │ ← 底层库
│   TTF_TextEngine │   字体渲染
└────────┬─────────┘
         │ 封装
         ↓
┌──────────────────┐
│  TextRenderer    │ ← 引擎层
│ • drawUIText     │   统一接口
│ • drawText       │
└────────┬─────────┘
         │
    ┌────┴────┐
    │         │
    ↓         ↓
┌────────┐┌────────┐
│UI Text ││World   │ ← 应用层
│固定位置││Text    │   两种文本
└────────┘│跟随相机│
          └────────┘
```

### 🎯 本课目标

| 目标 | 说明 |
|------|------|
| **了解 SDL_ttf** | 学习 SDL 的字体渲染库 |
| **创建 TextRenderer** | 封装字体加载和绘制逻辑 |
| **区分UI与世界文本** | 两种坐标系统的文本渲染 |
| **集成到引擎** | 作为核心服务添加到 Context |

---

## 第一部分：SDL_ttf 基础

### 💡 我们的新工具：SDL_ttf 与 TTF_TextEngine

要让SDL渲染文字，最官方、最常用的方法就是使用 **SDL_ttf** 库。它负责加载TrueType字体文件（.ttf），并将文本字符串转换为可以被SDL渲染的表面（Surface）或纹理（Texture）。

### SDL_ttf 的演进

```
SDL_ttf 版本对比：
┌──────────────────────┐
│ SDL2 时代（旧）：    │
│ 每次渲染文本：       │
│ 1. 创建纹理          │
│ 2. 渲染              │
│ 3. 销毁纹理          │
│ → 性能开销大 ❌      │
├──────────────────────┤
│ SDL3 时代（新）：    │
│ TTF_TextEngine       │
│ 1. 创建引擎实例      │
│ 2. 高效绘制文本      │
│ → 性能优化 ✅        │
└──────────────────────┘
```

**在最新的SDL3中，SDL_ttf 引入了一个强大的新特性：TTF_TextEngine**。与以往每次渲染文本都需要"创建纹理 → 渲染 → 销毁纹理"的低效流程不同，TTF_TextEngine 允许我们创建一个引擎实例，然后高效地绘制文本对象，极大地优化了性能。

### 性能对比

| 方式 | 创建/销毁 | 性能 | SDL版本 |
|------|----------|------|---------|
| **传统方式** | 每帧创建销毁纹理 | 较慢 | SDL2 |
| **TextEngine** | 复用引擎实例 | 快速 | SDL3 ✅ |

```
性能提升：
┌──────────────────────┐
│ 传统方式：           │
│ 每帧显示10个文本     │
│ = 10次创建+10次销毁  │
│ = 20次操作           │
├──────────────────────┤
│ TextEngine 方式：    │
│ 每帧显示10个文本     │
│ = 10次绘制调用       │
│ = 10次操作           │
│ → 性能提升2倍！      │
└──────────────────────┘
```

---

## 第二部分：TextRenderer 设计与实现

与 Renderer、AudioPlayer 一样，TextRenderer 也应该是一个位于引擎层的、可复用的模块。

---

## 1. TextRenderer 的设计

### src/engine/render/text_renderer.h（新建文件）

```cpp
#pragma once
#include <SDL3/SDL_render.h>
#include <string>
#include <glm/vec2.hpp>

struct TTF_TextEngine;

namespace engine::resource {
    class ResourceManager;
}

namespace engine::render {
    class Camera;

class TextRenderer final {
private:
    SDL_Renderer* sdl_renderer_ = nullptr;
    engine::resource::ResourceManager* resource_manager_ = nullptr;
    TTF_TextEngine* text_engine_ = nullptr;

public:
    TextRenderer(SDL_Renderer* sdl_renderer, engine::resource::ResourceManager* resource_manager);
    ~TextRenderer();
    void close();

    // 绘制UI上的字符串 (屏幕坐标)
    void drawUIText(const std::string& text, const std::string& font_id, int font_size, 
                  const glm::vec2& position, const SDL_FColor& color = {1.0f, 1.0f, 1.0f, 1.0f});

    // 绘制地图上的字符串 (世界坐标)
    void drawText(const Camera& camera, const std::string& text, const std::string& font_id, int font_size, 
                  const glm::vec2& position, const SDL_FColor& color = {1.0f, 1.0f, 1.0f, 1.0f});

    glm::vec2 getTextSize(const std::string& text, const std::string& font_id, int font_size);
    
    // ... 禁用拷贝和移动 ...
};
}
```

### 💡 设计解析

```
TextRenderer 职责：
┌──────────────────────┐
│ 1. 字体管理          │
│    依赖ResourceManager│
├──────────────────────┤
│ 2. 文本渲染          │
│    drawUIText        │
│    drawText          │
├──────────────────────┤
│ 3. 尺寸计算          │
│    getTextSize       │
└──────────────────────┘
```

### 💡 坐标系分离

**drawUIText 和 drawText 是关键**：

```
两种坐标系统：
┌──────────────────────┐
│ UI 坐标系：          │
│ drawUIText()         │
│ • 屏幕坐标           │
│ • 固定位置           │
│ • 不受相机影响       │
│                      │
│ (10,10)              │
│   ↓                  │
│ 💖 生命值            │ ← 始终在左上角
│ 🏆 得分              │
└──────────────────────┘

┌──────────────────────┐
│ 世界坐标系：         │
│ drawText()           │
│ • 世界坐标           │
│ • 跟随相机           │
│ • 受相机影响         │
│                      │
│     💬 "Hello"       │ ← 在游戏世界中
│     👤               │   跟随地图滚动
└──────────────────────┘
```

| 方法 | 坐标系 | 用途 | 示例 |
|------|-------|------|------|
| **drawUIText** | 屏幕坐标 | HUD、菜单等固定UI | 生命值、得分 |
| **drawText** | 世界坐标 | 游戏世界中的文字 | NPC对话、路标 |

### 工具函数

```cpp
glm::vec2 getTextSize(const std::string& text, const std::string& font_id, int font_size);
```

**getTextSize 是一个非常实用的辅助函数**，可以帮助我们计算渲染一段文本需要多大的空间，这对于UI布局至关重要。

```
getTextSize 用途：
┌──────────────────────┐
│ UI 居中对齐：        │
│ size = getTextSize() │
│ x = (width - size.x)/2│
├──────────────────────┤
│ 文本框大小：         │
│ size = getTextSize() │
│ box_width = size.x+10│
├──────────────────────┤
│ 自动换行：           │
│ size = getTextSize() │
│ if(size.x > max_width)│
│   换行               │
└──────────────────────┘
```

---

## 2. TextRenderer 实现

### src/engine/render/text_renderer.cpp（新建文件）

```cpp
#include "text_renderer.h"
#include "camera.h"
#include "../resource/resource_manager.h"
#include <SDL3_ttf/SDL_ttf.h>
#include <spdlog/spdlog.h>

namespace engine::render {

TextRenderer::TextRenderer(SDL_Renderer* sdl_renderer, engine::resource::ResourceManager* resource_manager)
    : sdl_renderer_(sdl_renderer), resource_manager_(resource_manager) {
    // ... 省略空指针检查 ...
    // 初始化 SDL_ttf
    if (!TTF_WasInit() && TTF_Init() == false) {
         throw std::runtime_error("初始化 SDL_ttf 失败: " + std::string(SDL_GetError()));
    }

    text_engine_ = TTF_CreateRendererTextEngine(sdl_renderer_);
    if (!text_engine_) {
        throw std::runtime_error("创建 TTF_TextEngine 失败。");
    }
}

void TextRenderer::drawUIText(const std::string &text, const std::string &font_id, int font_size,
                              const glm::vec2 &position, const SDL_FColor &color) {
    TTF_Font* font = resource_manager_->getFont(font_id, font_size);
    if (!font) { /* ... 错误处理 ... */ return; }

    // 创建临时 TTF_Text 对象
    TTF_Text* temp_text_object = TTF_CreateText(text_engine_, font, text.c_str(), 0);
    if (!temp_text_object) { /* ... 错误处理 ... */ return; }

    // 先渲染一次黑色文字模拟阴影
    TTF_SetTextColorFloat(temp_text_object, 0.0f, 0.0f, 0.0f, 1.0f);
    TTF_DrawRendererText(temp_text_object, position.x + 2, position.y + 2);

    // 然后正常绘制
    TTF_SetTextColorFloat(temp_text_object, color.r, color.g, color.b, color.a);
    TTF_DrawRendererText(temp_text_object, position.x, position.y);

    // 销毁临时 TTF_Text 对象
    TTF_DestroyText(temp_text_object);
}

void TextRenderer::drawText(const Camera &camera, const std::string &text, const std::string &font_id, int font_size, 
                            const glm::vec2 &position, const SDL_FColor &color) {
    // 应用相机变换
    glm::vec2 position_screen = camera.worldToScreen(position);
    // 用新坐标调用drawUIText即可
    drawUIText(text, font_id, font_size, position_screen, color);
}

// ... 其他函数实现 ...
}
```

### 初始化流程

```
TextRenderer 初始化：
    ↓
1. 检查 SDL_ttf 是否已初始化
    TTF_WasInit()
    ↓
2. 如果未初始化，则初始化
    TTF_Init()
    ↓
3. 创建 TextEngine
    TTF_CreateRendererTextEngine()
    ↓
4. 检查创建是否成功
    if (!text_engine_) throw
    ↓
完成！可以渲染文字
```

### 💡 实现亮点

#### 1. 阴影效果

```cpp
// 先渲染一次黑色文字模拟阴影
TTF_SetTextColorFloat(temp_text_object, 0.0f, 0.0f, 0.0f, 1.0f);
TTF_DrawRendererText(temp_text_object, position.x + 2, position.y + 2);

// 然后正常绘制
TTF_SetTextColorFloat(temp_text_object, color.r, color.g, color.b, color.a);
TTF_DrawRendererText(temp_text_object, position.x, position.y);
```

**阴影/描边效果**：

```
文字阴影原理：
┌──────────────────────┐
│ 第1次绘制：          │
│ (x+2, y+2) 黑色      │
│        ███           │ ← 阴影
│        ███           │
├──────────────────────┤
│ 第2次绘制：          │
│ (x, y) 彩色          │
│      ███             │ ← 文字
│      ███             │
├──────────────────────┤
│ 叠加效果：           │
│      ███             │
│      ███             │
│        ███           │ ← 有立体感
└──────────────────────┘
```

**轻松实现了一个简单的描边/阴影效果，让文字更具可读性**。

#### 2. 代码复用

```cpp
void TextRenderer::drawText(const Camera &camera, const std::string &text, /*...*/) {
    // 应用相机变换
    glm::vec2 position_screen = camera.worldToScreen(position);
    // 用新坐标调用drawUIText即可
    drawUIText(text, font_id, font_size, position_screen, color);
}
```

**drawText 的实现非常优雅**：

```
代码复用设计：
┌──────────────────────┐
│ drawText()           │
│ 世界坐标 → 屏幕坐标  │
│    ↓                 │
│ worldToScreen()      │
│    ↓                 │
│ drawUIText()         │
│ 实际绘制             │
└──────────────────────┘

优势：
✅ 避免代码重复
✅ 逻辑清晰
✅ 易于维护
```

### drawUIText 工作流程

```
drawUIText 渲染流程：
    ↓
1. 获取字体资源
    getFont(font_id, font_size)
    ↓
2. 创建文本对象
    TTF_CreateText(engine, font, text)
    ↓
3. 绘制阴影（黑色，偏移+2）
    SetTextColorFloat(0,0,0,1)
    DrawRendererText(x+2, y+2)
    ↓
4. 绘制文本（彩色，正常位置）
    SetTextColorFloat(r,g,b,a)
    DrawRendererText(x, y)
    ↓
5. 销毁临时对象
    TTF_DestroyText()
    ↓
完成！
```

---

## 第三部分：引擎集成

和我们之前添加的所有核心模块一样，TextRenderer 也需要被 GameApp 创建和管理，并通过 Context 提供给游戏的其他部分。

---

## 3. 引擎集成

### 在 GameApp 中添加 TextRenderer

#### src/engine/core/game_app.h（更新）

```cpp
class GameApp {
    // ...
    std::unique_ptr<engine::render::Camera> camera_;
    std::unique_ptr<engine::render::TextRenderer> text_renderer_;
    // ...
private:
    // ...
    [[nodiscard]] bool initRenderer();
    [[nodiscard]] bool initTextRenderer();
    [[nodiscard]] bool initCamera();
    // ...
};
```

### 将 TextRenderer 添加到 Context

#### src/engine/core/context.h（更新）

```cpp
class Context {
private:
    // ...
    engine::render::Camera& camera_;
    engine::render::TextRenderer& text_renderer_;
    engine::resource::ResourceManager& resource_manager_;
    // ...
public:
    Context(/*...*/, engine::render::TextRenderer& text_renderer, /*...*/);
    // ...
    engine::render::TextRenderer& getTextRenderer() const { return text_renderer_; }
};
```

### 引擎核心服务总览

```
引擎核心服务：
┌──────────────────────┐
│      GameApp         │
├──────────────────────┤
│ • ResourceManager    │ ← 资源管理
│ • Renderer           │ ← 图形渲染
│ • PhysicsEngine      │ ← 物理引擎
│ • AudioPlayer        │ ← 音频播放
│ • TextRenderer       │ ← 文字渲染（新增）✨
└────────┬─────────────┘
         │
         ↓
┌──────────────────────┐
│      Context         │
│  (全局访问接口)      │
└──────────────────────┘
```

**这个过程现在对我们来说应该已经非常熟悉了**。这种一致的架构模式让添加新的引擎功能变得清晰而直接。

### 集成步骤总结

```
集成流程：
    ↓
1. 在 GameApp 中创建实例
    unique_ptr<TextRenderer>
    ↓
2. 初始化 TextRenderer
    initTextRenderer()
    ↓
3. 添加到 Context
    Context(..., text_renderer, ...)
    ↓
4. 提供 Getter
    getTextRenderer()
    ↓
全局可访问！
```

---

## 第四部分：测试验证

现在，我们的引擎已经具备了渲染文字的能力。让我们在 GameScene 中编写一个简单的测试函数来验证一下。

---

## 4. 测试文字渲染

### src/game/scene/game_scene.h（更新）

```cpp
class GameScene final: public engine::scene::Scene {
    // ...
private:
    // ...
    // 测试函数
    void testTextRenderer();
};
```

### src/game/scene/game_scene.cpp（实现）

```cpp
void GameScene::render() {
    Scene::render();
    testTextRenderer(); // 在渲染循环中调用
}

void GameScene::testTextRenderer()
{
    auto& text_renderer = context_.getTextRenderer();
    const auto& camera = context_.getCamera();
    
    // 1. 渲染UI文本 (绿色)
    text_renderer.drawUIText("UI Text", "assets/fonts/VonwaonBitmap-16px.ttf", 32, glm::vec2(100.0f), {0, 1.0f, 0, 1.0f});
    
    // 2. 渲染世界文本 (默认白色)
    text_renderer.drawText(camera, "Map Text", "assets/fonts/VonwaonBitmap-16px.ttf", 32, glm::vec2(200.0f));
}
```

### 测试说明

| 测试项 | 代码 | 效果 |
|-------|------|------|
| **UI文本** | `drawUIText(..., {0,1,0,1})` | 绿色，固定位置 |
| **世界文本** | `drawText(camera, ...)` | 白色，跟随相机 |

### 预期效果

```
测试效果可视化：
┌─────────────────────────┐
│ UI Text (绿色)          │ ← 固定在屏幕 (100, 100)
│                          │   不随相机移动
│                          │
│         👤              │
│                          │
│    Map Text (白色)       │ ← 世界坐标 (200, 200)
│                          │   跟随相机移动
└─────────────────────────┘

玩家移动后：
┌─────────────────────────┐
│ UI Text (绿色)          │ ← 仍在 (100, 100)
│                          │   位置不变 ✅
│                          │
│                     👤  │
│                          │
│              Map Text   │ ← 随地图滚动
│              (白色)      │   相对位置不变 ✅
└─────────────────────────┘
```

**现在运行游戏，你应该能看到**：

- ✅ 屏幕上有一个固定的绿色文字 "UI Text"，无论你如何移动玩家，它的位置都不会改变
- ✅ 游戏世界中，坐标 (200, 200) 的位置有一个白色的文字 "Map Text"。当你移动玩家时，这个文字会随着地图一起滚动

**这个简单的测试完美地展示了 drawUIText 和 drawText 的区别和用途**。

---

## ✅ 编译与运行

编译并运行游戏，你会看到文字渲染系统正常工作：

```
运行效果：
┌─────────────────────────┐
│  UI文本测试：           │
│  UI Text                │ ← 绿色，固定位置
│  • 位置固定             │
│  • 不受相机影响         │
├─────────────────────────┤
│  世界文本测试：         │
│  Map Text               │ ← 白色，世界坐标
│  • 跟随地图滚动         │
│  • 受相机影响           │
├─────────────────────────┤
│  阴影效果：             │
│  所有文字都有阴影       │
│  提升可读性 ✅          │
└─────────────────────────┘
```

---

## 🎯 系统架构总结

### 完整的文字渲染系统

```
文字渲染系统架构：
┌──────────────────────────┐
│      SDL_ttf             │ ← 底层库
│   • TTF_TextEngine       │   字体渲染
│   • TTF_Font             │
└────────┬─────────────────┘
         │ 封装
         ↓
┌──────────────────────────┐
│   ResourceManager        │ ← 资源层
│   • 加载字体             │   缓存管理
│   • getFont()            │
└────────┬─────────────────┘
         │ 提供字体
         ↓
┌──────────────────────────┐
│    TextRenderer          │ ← 渲染层
│   • drawUIText()         │   统一接口
│   • drawText()           │
│   • getTextSize()        │
└────────┬─────────────────┘
         │
    ┌────┴────┬─────────┐
    │         │         │
    ↓         ↓         ↓
┌────────┐┌────────┐┌────────┐
│UI元素  ││世界    ││工具    │ ← 应用层
│HUD/菜单││对话/   ││布局    │   多种用途
│        ││路标    ││计算    │
└────────┘└────────┘└────────┘
```

### 核心成就

我们成功地：

1. ✅ **构建了文字渲染模块**：TextRenderer 类
2. ✅ **利用了SDL3新特性**：TTF_TextEngine 提升性能
3. ✅ **区分了两种坐标系**：UI坐标和世界坐标
4. ✅ **实现了视觉增强**：阴影效果提升可读性
5. ✅ **集成到引擎核心**：通过 Context 全局访问
6. ✅ **代码优雅复用**：drawText 调用 drawUIText

### 两种文本模式对比

| 特性 | drawUIText | drawText |
|------|-----------|----------|
| **坐标系** | 屏幕坐标 | 世界坐标 |
| **相机影响** | 不受影响 | 受相机影响 |
| **位置固定** | 固定 | 跟随地图 |
| **用途** | HUD、菜单 | NPC对话、路标 |
| **示例** | 生命值、得分 | "Welcome" 标语 |

### 关键技术点

| 技术点 | 实现方式 | 效果 |
|-------|---------|------|
| **TextEngine** | SDL3 新特性 | 性能优化 |
| **坐标转换** | worldToScreen() | 世界文本支持 |
| **阴影效果** | 双重绘制 | 提升可读性 |
| **代码复用** | drawText → drawUIText | 避免重复 |
| **尺寸计算** | getTextSize() | 支持UI布局 |

### 设计模式应用

```
封装模式：
┌──────────────────────┐
│ SDL_ttf（复杂）：    │
│ • TTF_Init()         │
│ • TTF_CreateText()   │
│ • TTF_SetColor()     │
│ • TTF_Draw()         │
│ • TTF_Destroy()      │
│ → 5个步骤            │
├──────────────────────┤
│ TextRenderer（简单）：│
│ drawUIText(          │
│   text, font, pos)   │
│ → 1个调用            │
└──────────────────────┘

简化接口，易于使用！
```

### 职责划分

```
清晰的职责分工：
┌──────────────────┐
│ SDL_ttf          │ ← 底层渲染者
│ "渲染字体"        │   C API
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ ResourceManager  │ ← 资源管理者
│ "加载字体"        │   缓存字体
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ TextRenderer     │ ← 接口封装者
│ "提供简单接口"    │   C++ 封装
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ GameScene        │ ← 业务使用者
│ "显示文字"        │   渲染UI/文本
└──────────────────┘
```

---

## 📚 总结

恭喜！我们为引擎增添了一项至关重要的功能。**通过创建一个独立的 TextRenderer 类，我们不仅封装了 SDL_ttf 的复杂性，还提供了一套清晰、强大且符合我们引擎架构的API**。

**关键要点：**
- 📝 SDL_ttf：SDL的官方字体渲染库
- ⚡ TTF_TextEngine：SDL3的性能优化特性
- 🎨 TextRenderer：统一的文字渲染接口
- 📍 两种坐标系：UI坐标和世界坐标
- 🌑 阴影效果：提升文字可读性
- 🔄 代码复用：优雅的设计模式
- 🎯 引擎集成：通过Context全局访问

> 💡 **设计哲学**：在本节课中，我们构建了一个通用的文字渲染模块 TextRenderer。利用了SDL3的新特性 TTF_TextEngine 来提升性能。区分了UI坐标和世界坐标，为后续构建复杂的UI系统打下了坚实的基础。将新模块无缝集成到现有的 GameApp 和 Context 架构中。这种一致的架构模式让我们能够快速、稳定地扩展引擎功能。

**文字渲染的重要性**：

```
游戏完整性：
┌─────────────────────┐
│ 无文字（70分）：     │
│ • 画面精美          │
│ • 交互完善          │
│ • 音效丰富          │
│ → 但缺少信息传达   │
├─────────────────────┤
│ 有文字（100分）：    │
│ + UI反馈            │
│ + 游戏状态显示      │
│ + 菜单系统          │
│ + 对话剧情          │
│ → 体验完整！        │
└─────────────────────┘

文字让游戏会"说话"！
```

---

## 🚀 下一步展望

现在，我们已经拥有了在屏幕上绘制任何文字的能力。但仅有渲染能力还不够，我们需要一个完整的UI系统来管理界面元素。

- ❓ 如何显示玩家生命值？
- ❓ 如何显示实时得分？
- ❓ 如何构建UI管理器？
- ❓ 如何创建按钮等交互元素？

下一课，我们将以此为基础，开始搭建真正的UI系统：

- 🎮 **UI管理器**：统一管理界面元素
- 💖 **生命图标**：显示玩家生命值
- 🏆 **得分显示**：实时显示游戏得分
- 🎨 **UI组件库**：可复用的UI元素
- 🖱️ **交互系统**：按钮和可点击元素

准备好让你的游戏"开口说话"吧，我们下节课见！🎮🌟