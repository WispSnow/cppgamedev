# æ¸²æŸ“å™¨ã€ç›¸æœºä¸ç²¾çµ

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- Bç«™åµŒå…¥ï¼šä½¿ç”¨ https æ˜ç¡®åè®®ï¼ˆé¿å… file:// æˆ– http å¯¼è‡´è¢«æµè§ˆå™¨æ‹¦æˆªï¼‰ -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1N6KDzSEKs&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[åœ¨ Bilibili ä¸Šè§‚çœ‹](https://www.bilibili.com/video/BV1N6KDzSEKs)

## ğŸ“– æ¦‚è¿°

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çš„æ¸¸æˆå¼•æ“å·²ç»æ‹¥æœ‰äº†å¿ƒè·³ï¼ˆä¸»å¾ªç¯ï¼‰ã€èŠ‚æ‹å™¨ï¼ˆæ—¶é—´æ§åˆ¶ï¼‰å’Œè¡€æ¶²å¾ªç¯ç³»ç»Ÿï¼ˆèµ„æºç®¡ç†ï¼‰ã€‚ç°åœ¨ï¼Œæ˜¯æ—¶å€™ä¸ºå®ƒè£…ä¸Šâ€œçœ¼ç›â€å’Œâ€œç”»ç¬”â€äº†ã€‚æœ¬èŠ‚ç›®æ ‡æ˜¯å»ºç«‹ä¸€ä¸ªå®Œæ•´çš„ 2D æ¸²æŸ“ç®¡çº¿ï¼Œå°†æ¸¸æˆä¸–ç•Œä¸­çš„å¯¹è±¡ç»˜åˆ¶åˆ°å±å¹•ä¸Šã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

æœ¬ç« å¼•å…¥ä¸‰ä¸ªæ ¸å¿ƒæ¦‚å¿µä¸å¯¹åº”ç±»ï¼š

- ğŸ–¼ï¸ **ç²¾çµï¼ˆSpriteï¼‰** - æè¿°"ç”»ä»€ä¹ˆ"ï¼Œä¾‹å¦‚ä½¿ç”¨å“ªå¼ çº¹ç†ã€çº¹ç†çš„å“ªä¸€éƒ¨åˆ†
- ğŸ“¹ **ç›¸æœºï¼ˆCameraï¼‰** - ä»£è¡¨ç©å®¶çš„"è§†çª—"ï¼Œå†³å®š"å“ªé‡Œèƒ½è¢«çœ‹è§"ï¼Œè´Ÿè´£åæ ‡è½¬æ¢ä¸è§†å›¾æ»šåŠ¨
- ğŸ¨ **æ¸²æŸ“å™¨ï¼ˆRendererï¼‰** - å°è£…åº•å±‚ç»˜åˆ¶ APIï¼Œæ¥æ”¶ç²¾çµä¸ç›¸æœºä¿¡æ¯ï¼Œæ‰§è¡ŒçœŸæ­£çš„ç»˜åˆ¶ç²¾çµ

<img src="https://theorhythm.top/gamedev/SL/SL.030.webp" alt="æ¸²æŸ“ç›¸å…³è®¾è®¡" style="display: block; margin: auto; width: 700px;" />

## ğŸ” 1. é€»è¾‘åˆ†è¾¨ç‡ï¼šåƒç´ æ¸¸æˆçš„å…³é”®

å¯¹äºåƒç´ é£æ ¼çš„æ¸¸æˆï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ä¸åŒç‰©ç†åˆ†è¾¨ç‡ï¼ˆ1080p/2K/4Kï¼‰ä¸‹ï¼Œç”»é¢åƒç´ å—ä¿æŒåŒæ ·è§‚æ„Ÿï¼Œé¿å…è¢«æ‹‰ä¼¸å˜å½¢ã€‚SDL3 æä¾›äº†é€»è¾‘åˆ†è¾¨ç‡æ–¹æ¡ˆã€‚

### ğŸ’» å®ç°æ–¹æ³•

åœ¨ `GameApp::initSDL()` ä¸­æ·»åŠ ï¼š

```cpp
SDL_SetRenderLogicalPresentation(sdl_renderer_, 640, 360, SDL_LOGICAL_PRESENTATION_LETTERBOX);
```

### ğŸ“‹ è®¾ç½®å«ä¹‰

- ğŸ¯ **é€»è¾‘ç”»å¸ƒå›ºå®š** - ä¸º `640x360`
- ğŸ“ **è‡ªåŠ¨ç¼©æ”¾** - SDL ä¼šå°†é€»è¾‘ç”»å¸ƒç­‰æ¯”ç¼©æ”¾ä»¥é€‚é…å®é™…çª—å£å¤§å°
- ğŸ–¥ï¸ **é»‘è¾¹å¡«å……** - å½“çª—å£å®½é«˜æ¯”ä¸ä¸º `16:9` æ—¶ï¼ŒLETTERBOX æ¨¡å¼è‡ªåŠ¨å¡«å……é»‘è¾¹ï¼Œé¿å…ç”»é¢æ‹‰ä¼¸

è‡ªæ­¤ï¼Œæ‰€æœ‰æ¸¸æˆé€»è¾‘ä¸åæ ‡è®¡ç®—å‡åœ¨ `640x360` çš„é€»è¾‘åˆ†è¾¨ç‡ä¸‹è¿›è¡Œï¼Œå¤§å¹…ç®€åŒ–å¼€å‘ä¸é€‚é…éš¾åº¦ã€‚

## ğŸ“ 2. æ–°çš„é¡¹ç›®ç»“æ„

å°†æ¸²æŸ“ç›¸å…³ç±»æ”¾å…¥ `render/` ç›®å½•ï¼Œå°†é€šç”¨å·¥å…·æ”¾å…¥ `utils/` ç›®å½•ï¼š

```
â””â”€â”€ src/
    â””â”€â”€ engine/
        â”œâ”€â”€ core/
        â”œâ”€â”€ resource/
        â”œâ”€â”€ render/
        â”‚   â”œâ”€â”€ renderer.h/.cpp
        â”‚   â”œâ”€â”€ camera.h/.cpp
        â”‚   â””â”€â”€ sprite.h
        â””â”€â”€ utils/
            â””â”€â”€ math.h
```

## ğŸ–¼ï¸ 3. Sprite ç±»ï¼šç”»ä»€ä¹ˆï¼Ÿ

`Sprite` æ˜¯ä¸€ä¸ªè½»é‡çº§æ•°æ®ç±»ï¼Œç”¨æ¥æè¿°ä¸€ä¸ª"å¾…ç»˜åˆ¶"çš„è§†è§‰å…ƒç´ ï¼Œä¸åŒ…å«å¤æ‚é€»è¾‘

```cpp
// sprite.h
#pragma once
#include <SDL3/SDL_rect.h>   // ç”¨äº SDL_FRect
#include <optional>          // ç”¨äº std::optional è¡¨ç¤ºå¯é€‰çš„æºçŸ©å½¢
#include <string>

namespace engine::render {

/**
 * @brief è¡¨ç¤ºè¦ç»˜åˆ¶çš„è§†è§‰ç²¾çµçš„æ•°æ®ã€‚
 *
 * åŒ…å«çº¹ç†æ ‡è¯†ç¬¦ã€è¦ç»˜åˆ¶çš„çº¹ç†éƒ¨åˆ†ï¼ˆæºçŸ©å½¢ï¼‰ä»¥åŠç¿»è½¬çŠ¶æ€ã€‚
 * ä½ç½®ã€ç¼©æ”¾å’Œæ—‹è½¬ç”±å¤–éƒ¨ï¼ˆä¾‹å¦‚ SpriteComponentï¼‰æ ‡è¯†ã€‚
 * æ¸²æŸ“å·¥ä½œç”± Renderer ç±»å®Œæˆã€‚ï¼ˆä¼ å…¥Spriteä½œä¸ºå‚æ•°ï¼‰
 */
class Sprite final{
private:
    std::string texture_id_;                      ///< @brief çº¹ç†èµ„æºçš„æ ‡è¯†ç¬¦
    std::optional<SDL_FRect> source_rect_;        ///< @brief å¯é€‰ï¼šè¦ç»˜åˆ¶çš„çº¹ç†éƒ¨åˆ†
    bool is_flipped_ = false;                     ///< @brief æ˜¯å¦æ°´å¹³ç¿»è½¬

public:
    /**
     * @brief æ„é€ ä¸€ä¸ªç²¾çµ
     *
     * @param texture_id çº¹ç†èµ„æºçš„æ ‡è¯†ç¬¦ã€‚ä¸åº”ä¸ºç©ºã€‚
     * @param source_rect å¯é€‰çš„æºçŸ©å½¢ï¼ˆSDL_FRectï¼‰ï¼Œå®šä¹‰è¦ä½¿ç”¨çš„çº¹ç†éƒ¨åˆ†ã€‚å¦‚æœä¸º std::nulloptï¼Œåˆ™ä½¿ç”¨æ•´ä¸ªçº¹ç†ã€‚
     * @param is_flipped æ˜¯å¦æ°´å¹³ç¿»è½¬
     */
    Sprite(const std::string& texture_id, const std::optional<SDL_FRect>& source_rect = std::nullopt, bool is_flipped = false)
        : texture_id_(texture_id),
          source_rect_(source_rect),
          is_flipped_(is_flipped)
    {}

    // --- getters and setters ---
    const std::string& getTextureId() const { return texture_id_; }                                     ///< @brief è·å–çº¹ç† ID
    const std::optional<SDL_FRect>& getSourceRect() const { return source_rect_; }                      ///< @brief è·å–æºçŸ©å½¢ (å¦‚æœä½¿ç”¨æ•´ä¸ªçº¹ç†åˆ™ä¸º std::nullopt)
    bool isFlipped() const { return is_flipped_; }                                                      ///< @brief è·å–æ˜¯å¦æ°´å¹³ç¿»è½¬

    void setTextureId(const std::string& texture_id) { texture_id_ = texture_id; }                      ///< @brief è®¾ç½®çº¹ç† ID
    void setSourceRect(const std::optional<SDL_FRect>& source_rect) { source_rect_ = source_rect; }     ///< @brief è®¾ç½®æºçŸ©å½¢ (å¦‚æœä½¿ç”¨æ•´ä¸ªçº¹ç†åˆ™ä¸º std::nullopt)
    void setFlipped(bool flipped) { is_flipped_ = flipped; }                                            ///< @brief è®¾ç½®æ˜¯å¦æ°´å¹³ç¿»è½¬

};

} // namespace engine::render

```

### ğŸ“Š æ ¸å¿ƒå±æ€§

- ğŸ¨ **`texture_id_`** - è¦ä½¿ç”¨çš„çº¹ç†æ ‡è¯†
- âœ‚ï¸ **`source_rect_`** - å¯é€‰çš„ `SDL_FRect`ï¼Œç”¨äºä»é›ªç¢§å›¾ä¸­æˆªå–å­åŒºåŸŸï¼›ä¸ºç©ºåˆ™ä½¿ç”¨æ•´å¼ çº¹ç†
- ğŸ”„ **`is_flipped_`** - æ˜¯å¦æ°´å¹³ç¿»è½¬èµ„æºç®¡ç†ï¼‰ã€‚ç°åœ¨ï¼Œæ˜¯æ—¶å€™ä¸ºå®ƒè£…ä¸Š"çœ¼ç›"å’Œ"ç”»ç¬”"äº†ã€‚æœ¬èŠ‚ç›®æ ‡æ˜¯å»ºç«‹ä¸€ä¸ªå®Œæ•´çš„ **2D æ¸²æŸ“ç®¡çº¿**ï¼Œå°†æ¸¸æˆä¸–ç•Œä¸­çš„å¯¹è±¡ç»˜åˆ¶åˆ°å±å¹•ä¸Šã€‚

## ğŸ“¹ 4. Camera ç±»ï¼šä»å“ªé‡Œçœ‹ï¼Ÿ

`Camera` æ¨¡æ‹Ÿæ‘„åƒæœºï¼Œå®šä¹‰åœ¨å¹¿é˜”ä¸–ç•Œä¸­å¯è§çš„åŒºåŸŸï¼Œæ ¸å¿ƒèŒè´£æ˜¯åæ ‡å˜æ¢ä¸è§†å›¾æ§åˆ¶ï¼š

```cpp
// camera.h
#pragma once
#include "../utils/math.h"
#include <optional>

namespace engine::render {

/**
 * @brief ç›¸æœºç±»è´Ÿè´£ç®¡ç†ç›¸æœºä½ç½®å’Œè§†å£å¤§å°ï¼Œå¹¶æä¾›åæ ‡è½¬æ¢åŠŸèƒ½ã€‚
 * å®ƒè¿˜åŒ…å«é™åˆ¶ç›¸æœºç§»åŠ¨èŒƒå›´çš„è¾¹ç•Œã€‚
 */
class Camera final {
private:
    glm::vec2 viewport_size_;                                                ///< @brief è§†å£å¤§å°ï¼ˆå±å¹•å¤§å°ï¼‰
    glm::vec2 position_;                                                     ///< @brief ç›¸æœºå·¦ä¸Šè§’çš„ä¸–ç•Œåæ ‡
    std::optional<engine::utils::Rect> limit_bounds_;                        ///< @brief é™åˆ¶ç›¸æœºçš„ç§»åŠ¨èŒƒå›´ï¼Œç©ºå€¼è¡¨ç¤ºä¸é™åˆ¶
    
public:

    Camera(const glm::vec2& viewport_size, const glm::vec2& position = glm::vec2(0.0f, 0.0f), const std::optional<engine::utils::Rect> limit_bounds = std::nullopt);
    
    void update(float delta_time);                                          ///< @brief æ›´æ–°ç›¸æœºä½ç½®
    void move(const glm::vec2& offset);                                     ///< @brief ç§»åŠ¨ç›¸æœº

    glm::vec2 worldToScreen(const glm::vec2& world_pos) const;              ///< @brief ä¸–ç•Œåæ ‡è½¬å±å¹•åæ ‡
    glm::vec2 worldToScreenWithParallax(const glm::vec2& world_pos, const glm::vec2& scroll_factor) const; ///< @brief ä¸–ç•Œåæ ‡è½¬å±å¹•åæ ‡ï¼Œè€ƒè™‘è§†å·®æ»šåŠ¨
    glm::vec2 screenToWorld(const glm::vec2& screen_pos) const;             ///< @brief å±å¹•åæ ‡è½¬ä¸–ç•Œåæ ‡

    void setPosition(const glm::vec2& position);                            ///< @brief è®¾ç½®ç›¸æœºä½ç½®
    void setLimitBounds(const engine::utils::Rect& bounds);                 ///< @brief è®¾ç½®é™åˆ¶ç›¸æœºçš„ç§»åŠ¨èŒƒå›´

    const glm::vec2& getPosition() const;                                   ///< @brief è·å–ç›¸æœºä½ç½®
    std::optional<engine::utils::Rect> getLimitBounds() const;              ///< @brief è·å–é™åˆ¶ç›¸æœºçš„ç§»åŠ¨èŒƒå›´
    glm::vec2 getViewportSize() const;                                      ///< @brief è·å–è§†å£å¤§å°

    // ç¦ç”¨æ‹·è´å’Œç§»åŠ¨è¯­ä¹‰
    Camera(const Camera&) = delete;
    Camera& operator=(const Camera&) = delete;
    Camera(Camera&&) = delete;
    Camera& operator=(Camera&&) = delete;

private:
    void clampPosition();                                                   ///< @brief é™åˆ¶ç›¸æœºä½ç½®åœ¨è¾¹ç•Œå†…
};

} // namespace engine::render

// camera.cpp
#include "camera.h"
#include "../utils/math.h"
#include <spdlog/spdlog.h>

namespace engine::render {

Camera::Camera(const glm::vec2& viewport_size, const glm::vec2& position, const std::optional<engine::utils::Rect> limit_bounds)
    : viewport_size_(viewport_size), position_(position), limit_bounds_(limit_bounds) {
    spdlog::trace("Camera åˆå§‹åŒ–æˆåŠŸï¼Œä½ç½®: {},{}", position_.x, position_.y);
}

void Camera::setPosition(const glm::vec2& position) {
    position_ = position;
    clampPosition();
}

void Camera::update(float /* delta_time */)
{
    // TODO è‡ªåŠ¨è·Ÿéšç›®æ ‡
}

void Camera::move(const glm::vec2 &offset)
{
    position_ += offset;
    clampPosition();
}

void Camera::setLimitBounds(const engine::utils::Rect& bounds)
{
    limit_bounds_ = bounds;
    clampPosition(); // è®¾ç½®è¾¹ç•Œåï¼Œç«‹å³åº”ç”¨é™åˆ¶
}

const glm::vec2& Camera::getPosition() const {
    return position_;
}

void Camera::clampPosition()
{
    // è¾¹ç•Œæ£€æŸ¥éœ€è¦ç¡®ä¿ç›¸æœºè§†å›¾ï¼ˆposition åˆ° position + viewport_sizeï¼‰åœ¨ limit_bounds å†…
    if (limit_bounds_.has_value() && limit_bounds_->size.x > 0 && limit_bounds_->size.y > 0) {
        // è®¡ç®—å…è®¸çš„ç›¸æœºä½ç½®èŒƒå›´
        glm::vec2 min_cam_pos = limit_bounds_->position;
        glm::vec2 max_cam_pos = limit_bounds_->position + limit_bounds_->size - viewport_size_;

        // ç¡®ä¿ max_cam_pos ä¸å°äº min_cam_pos (è§†å£å¯èƒ½æ¯”ä¸–ç•Œè¿˜å¤§)
        max_cam_pos.x = std::max(min_cam_pos.x, max_cam_pos.x);
        max_cam_pos.y = std::max(min_cam_pos.y, max_cam_pos.y);

        position_ = glm::clamp(position_, min_cam_pos, max_cam_pos);
    }
    // å¦‚æœ limit_bounds æ— æ•ˆåˆ™ä¸è¿›è¡Œé™åˆ¶
}

glm::vec2 Camera::worldToScreen(const glm::vec2& world_pos) const {
    // å°†ä¸–ç•Œåæ ‡å‡å»ç›¸æœºå·¦ä¸Šè§’ä½ç½®
    return world_pos - position_;
}

glm::vec2 Camera::worldToScreenWithParallax(const glm::vec2 &world_pos, const glm::vec2 &scroll_factor) const
{
    // ç›¸æœºä½ç½®åº”ç”¨æ»šåŠ¨å› å­
    return world_pos - position_ * scroll_factor;
}

glm::vec2 Camera::screenToWorld(const glm::vec2 &screen_pos) const
{
    // å°†å±å¹•åæ ‡åŠ ä¸Šç›¸æœºå·¦ä¸Šè§’ä½ç½®
    return screen_pos + position_;
}

glm::vec2 Camera::getViewportSize() const {
    return viewport_size_;
}

std::optional<engine::utils::Rect> Camera::getLimitBounds() const {
    return limit_bounds_;
}

} // namespace engine::render 
```

### ğŸŒ åæ ‡ç³»ç»Ÿ

- **ä¸–ç•Œåæ ‡ vs. å±å¹•åæ ‡** - åœ¨"ä¸–ç•Œåæ ‡"ï¼ˆå…³å¡ä¸­çš„ç»å¯¹ä½ç½®ï¼‰ä¸"å±å¹•åæ ‡"ï¼ˆ`640x360` ç”»å¸ƒä¸Šçš„ç»˜åˆ¶ä½ç½®ï¼‰ä¹‹é—´è½¬æ¢

### ğŸ”„ æ ¸å¿ƒæ–¹æ³•

- ğŸ¯ **`worldToScreen()`** - å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡ï¼Œæ ¸å¿ƒä¸º `screen_pos = world_pos - camera_pos`

### ğŸ­ è§†å·®æ»šåŠ¨ï¼ˆParallaxï¼‰

`worldToScreenWithParallax(scroll_factor)` æŒ‰æ»šåŠ¨å› å­è¿›è¡Œç›¸å¯¹ç§»åŠ¨ï¼š

- ğŸ¯ **`scroll_factor = 1`** - ä¸ç›¸æœºåŒæ­¥ç§»åŠ¨
- ğŸ  **`scroll_factor = 0`** - é™æ­¢ï¼ˆå…¸å‹ç”¨äº UIï¼‰
- ğŸŒ„ **`0 < scroll_factor < 1`** - äº§ç”Ÿæ™¯æ·±æ•ˆæœçš„è§†å·®æ»šåŠ¨

### ğŸš§ ç§»åŠ¨è¾¹ç•Œ

`setLimitBounds()` é™åˆ¶ç›¸æœºç§»åŠ¨èŒƒå›´ï¼Œé˜²æ­¢è¶Šç•Œå…³å¡ã€‚

### è‡ªå®šä¹‰Rect

ç›¸æœºä¸­ç”¨åˆ°çš„ `engine::utils::Rect` å®šä¹‰åœ¨ `src/engine/utils/math.h` ä¸­ï¼š

```cpp
// math.h
#pragma once
#include <glm/glm.hpp>

namespace engine::utils {

struct Rect
{
    glm::vec2 position;
    glm::vec2 size;
};

} // namespace engine::utils
```

## ğŸ¨ 5. Renderer ç±»ï¼šè°æ¥ç”»ï¼Ÿ

`Renderer` æ˜¯æ¸²æŸ“ä¸­æ¢ï¼Œå°è£… SDL åº•å±‚ç»˜åˆ¶ APIï¼Œå¹¶æä¾›æ›´é«˜å±‚ã€æ˜“ç”¨çš„ç»˜åˆ¶æ¥å£ï¼š

```cpp
// renderer.h
#pragma once
#include "sprite.h"
#include <string>
#include <optional> // For std::optional
#include <glm/glm.hpp>

struct SDL_Renderer;
struct SDL_FRect;

namespace engine::resource {
    class ResourceManager;
}

namespace engine::render {
class Camera;

/**
 * @brief å°è£… SDL3 æ¸²æŸ“æ“ä½œ
 *
 * åŒ…è£… SDL_Renderer å¹¶æä¾›æ¸…é™¤å±å¹•ã€ç»˜åˆ¶ç²¾çµå’Œå‘ˆç°æœ€ç»ˆå›¾åƒçš„æ–¹æ³•ã€‚
 * åœ¨æ„é€ æ—¶åˆå§‹åŒ–ã€‚ä¾èµ–äºä¸€ä¸ªæœ‰æ•ˆçš„ SDL_Renderer å’Œ ResourceManagerã€‚
 * æ„é€ å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
 */
class Renderer final{
private:
    SDL_Renderer* renderer_ = nullptr;                              ///< @brief æŒ‡å‘ SDL_Renderer çš„éæ‹¥æœ‰æŒ‡é’ˆ
    engine::resource::ResourceManager* resource_manager_ = nullptr; ///< @brief æŒ‡å‘ ResourceManager çš„éæ‹¥æœ‰æŒ‡é’ˆ
    
public:
    /**
     * @brief æ„é€ å‡½æ•°
     *
     * @param sdl_renderer æŒ‡å‘æœ‰æ•ˆçš„ SDL_Renderer çš„æŒ‡é’ˆã€‚ä¸èƒ½ä¸ºç©ºã€‚
     * @param resource_manager æŒ‡å‘æœ‰æ•ˆçš„ ResourceManager çš„æŒ‡é’ˆã€‚ä¸èƒ½ä¸ºç©ºã€‚
     * @throws std::runtime_error å¦‚æœä»»ä¸€æŒ‡é’ˆä¸º nullptrã€‚
     */
    Renderer(SDL_Renderer* sdl_renderer, engine::resource::ResourceManager* resource_manager);

    /**
     * @brief ç»˜åˆ¶ä¸€ä¸ªç²¾çµ
     * 
     * @param sprite åŒ…å«çº¹ç†IDã€æºçŸ©å½¢å’Œç¿»è½¬çŠ¶æ€çš„ Sprite å¯¹è±¡ã€‚
     * @param position ä¸–ç•Œåæ ‡ä¸­çš„å·¦ä¸Šè§’ä½ç½®ã€‚
     * @param scale ç¼©æ”¾å› å­ã€‚
     * @param angle æ—‹è½¬è§’åº¦ï¼ˆåº¦ï¼‰ã€‚
     */
    void drawSprite(const Camera& camera, const Sprite& sprite, const glm::vec2& position, 
                    const glm::vec2& scale = {1.0f, 1.0f}, double angle = 0.0f);

    /**
     * @brief ç»˜åˆ¶è§†å·®æ»šåŠ¨èƒŒæ™¯
     * 
     * @param sprite åŒ…å«çº¹ç†IDã€æºçŸ©å½¢å’Œç¿»è½¬çŠ¶æ€çš„ Sprite å¯¹è±¡ã€‚
     * @param position ä¸–ç•Œåæ ‡ã€‚
     * @param scroll_factor æ»šåŠ¨å› å­ã€‚
     * @param scale ç¼©æ”¾å› å­ã€‚
     */
    void drawParallax(const Camera& camera, const Sprite& sprite, const glm::vec2& position, 
                      const glm::vec2& scroll_factor, const glm::bvec2& repeat = {true, true}, const glm::vec2& scale = {1.0f, 1.0f});

    /**
     * @brief åœ¨å±å¹•åæ ‡ä¸­ç›´æ¥æ¸²æŸ“ä¸€ä¸ªç”¨äºUIçš„Spriteå¯¹è±¡ã€‚
     *
     * @param sprite åŒ…å«çº¹ç†IDã€æºçŸ©å½¢å’Œç¿»è½¬çŠ¶æ€çš„Spriteå¯¹è±¡ã€‚
     * @param position å±å¹•åæ ‡ä¸­çš„å·¦ä¸Šè§’ä½ç½®ã€‚
     * @param size å¯é€‰ï¼šç›®æ ‡çŸ©å½¢çš„å¤§å°ã€‚å¦‚æœä¸º std::nulloptï¼Œåˆ™ä½¿ç”¨Spriteçš„åŸå§‹å¤§å°ã€‚
     */
    void drawUISprite(const Sprite& sprite, const glm::vec2& position, const std::optional<glm::vec2>& size = std::nullopt);


    void present();                                                     ///< @brief æ›´æ–°å±å¹•ï¼ŒåŒ…è£… SDL_RenderPresent å‡½æ•°
    void clearScreen();                                                 ///< @brief æ¸…å±ï¼ŒåŒ…è£… SDL_RenderClear å‡½æ•°

    void setDrawColor(Uint8 r, Uint8 g, Uint8 b, Uint8 a = 255);        ///< @brief è®¾ç½®ç»˜åˆ¶é¢œè‰²ï¼ŒåŒ…è£… SDL_SetRenderDrawColor å‡½æ•°ï¼Œä½¿ç”¨ Uint8 ç±»å‹
    void setDrawColorFloat(float r, float g, float b, float a = 1.0f);  ///< @brief è®¾ç½®ç»˜åˆ¶é¢œè‰²ï¼ŒåŒ…è£… SDL_SetRenderDrawColorFloat å‡½æ•°ï¼Œä½¿ç”¨ float ç±»å‹

    SDL_Renderer* getSDLRenderer() const { return renderer_; }          ///< @brief è·å–åº•å±‚çš„ SDL_Renderer æŒ‡é’ˆ

    // ç¦ç”¨æ‹·è´å’Œç§»åŠ¨è¯­ä¹‰
    Renderer(const Renderer&) = delete;
    Renderer& operator=(const Renderer&) = delete;
    Renderer(Renderer&&) = delete;
    Renderer& operator=(Renderer&&) = delete;

private:
    std::optional<SDL_FRect> getSpriteSrcRect(const Sprite& sprite);     ///< @brief è·å–ç²¾çµçš„æºçŸ©å½¢ï¼Œç”¨äºå…·ä½“ç»˜åˆ¶ã€‚å‡ºç°é”™è¯¯åˆ™è¿”å›std::nulloptå¹¶è·³è¿‡ç»˜åˆ¶
    bool isRectInViewport(const Camera& camera, const SDL_FRect& rect);  ///< @brief åˆ¤æ–­çŸ©å½¢æ˜¯å¦åœ¨è§†å£ä¸­ï¼Œç”¨äºè§†å£è£å‰ª

};

} // namespace engine::render

// renderer.cpp
#include "renderer.h"
#include "../resource/resource_manager.h"
#include "camera.h"
#include "sprite.h"
#include <SDL3/SDL.h>
#include <stdexcept> // For std::runtime_error
#include <spdlog/spdlog.h>

namespace engine::render {

// æ„é€ å‡½æ•°: æ‰§è¡Œåˆå§‹åŒ–ï¼Œå¢åŠ  ResourceManager
Renderer::Renderer(SDL_Renderer* sdl_renderer, engine::resource::ResourceManager* resource_manager)
    : renderer_(sdl_renderer), resource_manager_(resource_manager) 
{
    spdlog::trace("æ„é€  Renderer...");
    if (!renderer_) {
        throw std::runtime_error("Renderer æ„é€ å¤±è´¥: æä¾›çš„ SDL_Renderer æŒ‡é’ˆä¸ºç©ºã€‚");
    }
    if (!resource_manager_) {
        // ResourceManager æ˜¯ drawSprite æ‰€å¿…éœ€çš„
        throw std::runtime_error("Renderer æ„é€ å¤±è´¥: æä¾›çš„ ResourceManager æŒ‡é’ˆä¸ºç©ºã€‚");
    }
    setDrawColor(0, 0, 0, 255);
    spdlog::trace("Renderer æ„é€ æˆåŠŸã€‚");
}

void Renderer::drawSprite(const Camera& camera, const Sprite& sprite, const glm::vec2& position, const glm::vec2& scale, double angle) {
    auto texture = resource_manager_->getTexture(sprite.getTextureId());
    if (!texture) {
        spdlog::error("æ— æ³•ä¸º ID {} è·å–çº¹ç†ã€‚", sprite.getTextureId());
        return;
    }

    auto src_rect = getSpriteSrcRect(sprite);
    if (!src_rect.has_value()) {
        spdlog::error("æ— æ³•è·å–ç²¾çµçš„æºçŸ©å½¢ï¼ŒID: {}", sprite.getTextureId());
        return;
    }

    // åº”ç”¨ç›¸æœºå˜æ¢
    glm::vec2 position_screen = camera.worldToScreen(position);

    // è®¡ç®—ç›®æ ‡çŸ©å½¢ï¼Œæ³¨æ„ position æ˜¯ç²¾çµçš„å·¦ä¸Šè§’åæ ‡
    float scaled_w = src_rect.value().w * scale.x;
    float scaled_h = src_rect.value().h * scale.y;
    SDL_FRect dest_rect = {
        position_screen.x, 
        position_screen.y, 
        scaled_w,
        scaled_h
    };

    if (!isRectInViewport(camera, dest_rect)) { // è§†å£è£å‰ªï¼šå¦‚æœç²¾çµè¶…å‡ºè§†å£ï¼Œåˆ™ä¸ç»˜åˆ¶
        // spdlog::info("ç²¾çµè¶…å‡ºè§†å£èŒƒå›´ï¼ŒID: {}", sprite.getTextureId());
        return;
    }

    // æ‰§è¡Œç»˜åˆ¶(é»˜è®¤æ—‹è½¬ä¸­å¿ƒä¸ºç²¾çµçš„ä¸­å¿ƒç‚¹)
    if (!SDL_RenderTextureRotated(renderer_, texture, &src_rect.value(), &dest_rect, angle, NULL, sprite.isFlipped() ? SDL_FLIP_HORIZONTAL : SDL_FLIP_NONE)) {
        spdlog::error("æ¸²æŸ“æ—‹è½¬çº¹ç†å¤±è´¥ï¼ˆID: {}ï¼‰ï¼š{}", sprite.getTextureId(), SDL_GetError());
    }   
}

void Renderer::drawParallax(const Camera &camera, const Sprite &sprite, const glm::vec2 &position, const glm::vec2 &scroll_factor, const glm::bvec2 &repeat, const glm::vec2 &scale)
{
    auto texture = resource_manager_->getTexture(sprite.getTextureId());
    if (!texture) {
        spdlog::error("æ— æ³•ä¸º ID {} è·å–çº¹ç†ã€‚", sprite.getTextureId());
        return;
    }

    auto src_rect = getSpriteSrcRect(sprite);
    if (!src_rect.has_value()) {
        spdlog::error("æ— æ³•è·å–ç²¾çµçš„æºçŸ©å½¢ï¼ŒID: {}", sprite.getTextureId());
        return;
    }

    // åº”ç”¨ç›¸æœºå˜æ¢
    glm::vec2 position_screen = camera.worldToScreenWithParallax(position, scroll_factor);

    // è®¡ç®—ç¼©æ”¾åçš„çº¹ç†å°ºå¯¸ 
    float scaled_tex_w = src_rect.value().w * scale.x;
    float scaled_tex_h = src_rect.value().h * scale.y;

    glm::vec2 start, stop;
    glm::vec2 viewport_size = camera.getViewportSize();

    if (repeat.x) {
        // ä½¿ç”¨ glm::mod è¿›è¡Œæµ®ç‚¹æ•°å–æ¨¡
        start.x = glm::mod(position_screen.x, scaled_tex_w) - scaled_tex_w;
        stop.x = viewport_size.x;
    } else {
        start.x = position_screen.x;
        stop.x = glm::min(position_screen.x + scaled_tex_w, viewport_size.x); // ç»“æŸç‚¹æ˜¯ä¸€ä¸ªçº¹ç†å®½åº¦ä¹‹åï¼Œä½†ä¸è¶…è¿‡è§†å£å®½åº¦
    }
    if (repeat.y) {
        start.y = glm::mod(position_screen.y, scaled_tex_h) - scaled_tex_h;
        stop.y = viewport_size.y;
    } else {
        start.y = position_screen.y;
        stop.y = glm::min(position_screen.y + scaled_tex_h, viewport_size.y); // ç»“æŸç‚¹æ˜¯ä¸€ä¸ªçº¹ç†é«˜åº¦ä¹‹åï¼Œä½†ä¸è¶…è¿‡è§†å£é«˜åº¦
    }

    for (float y = start.y; y < stop.y; y += scaled_tex_h) {
        for (float x = start.x; x < stop.x; x += scaled_tex_w) {
            SDL_FRect dest_rect = {x, y, scaled_tex_w, scaled_tex_h};
            if (!SDL_RenderTexture(renderer_, texture, nullptr, &dest_rect)) {
                spdlog::error("æ¸²æŸ“è§†å·®çº¹ç†å¤±è´¥ï¼ˆID: {}ï¼‰ï¼š{}", sprite.getTextureId(), SDL_GetError());
                return;
            }
        }
    }
}

void Renderer::drawUISprite(const Sprite& sprite, const glm::vec2& position, const std::optional<glm::vec2>& size) {
    auto texture = resource_manager_->getTexture(sprite.getTextureId());
    if (!texture) {
        spdlog::error("æ— æ³•ä¸º ID {} è·å–çº¹ç†ã€‚", sprite.getTextureId());
        return;
    }

    auto src_rect = getSpriteSrcRect(sprite);
    if (!src_rect.has_value()) {
        spdlog::error("æ— æ³•è·å–ç²¾çµçš„æºçŸ©å½¢ï¼ŒID: {}", sprite.getTextureId());
        return;
    }

    SDL_FRect dest_rect = {position.x, position.y, 0, 0};   // é¦–å…ˆç¡®å®šç›®æ ‡çŸ©å½¢çš„å·¦ä¸Šè§’åæ ‡
    if (size.has_value()) {                                 // å¦‚æœæä¾›äº†å°ºå¯¸ï¼Œåˆ™ä½¿ç”¨æä¾›çš„å°ºå¯¸
        dest_rect.w = size.value().x;
        dest_rect.h = size.value().y;
    } else {                                                // å¦‚æœæœªæä¾›å°ºå¯¸ï¼Œåˆ™ä½¿ç”¨çº¹ç†çš„åŸå§‹å°ºå¯¸
        dest_rect.w = src_rect.value().w;
        dest_rect.h = src_rect.value().h;
    }

    // æ‰§è¡Œç»˜åˆ¶(æœªè€ƒè™‘UIæ—‹è½¬)
    if (!SDL_RenderTextureRotated(renderer_, texture, &src_rect.value(), &dest_rect, 0.0, nullptr, sprite.isFlipped() ? SDL_FLIP_HORIZONTAL : SDL_FLIP_NONE)) {
        spdlog::error("æ¸²æŸ“ UI Sprite å¤±è´¥ (ID: {}): {}", sprite.getTextureId(), SDL_GetError());
    }
}

void Renderer::setDrawColor(Uint8 r, Uint8 g, Uint8 b, Uint8 a) {
    if (!SDL_SetRenderDrawColor(renderer_, r, g, b, a)) {
        spdlog::error("è®¾ç½®æ¸²æŸ“ç»˜åˆ¶é¢œè‰²å¤±è´¥ï¼š{}", SDL_GetError());
    }
}

void Renderer::setDrawColorFloat(float r, float g, float b, float a)
{
    if (!SDL_SetRenderDrawColorFloat(renderer_, r, g, b, a)) {
        spdlog::error("è®¾ç½®æ¸²æŸ“ç»˜åˆ¶é¢œè‰²å¤±è´¥ï¼š{}", SDL_GetError());
    }
}

void Renderer::clearScreen() {
    if (!SDL_RenderClear(renderer_)) {
        spdlog::error("æ¸…é™¤æ¸²æŸ“å™¨å¤±è´¥ï¼š{}", SDL_GetError());
    }
}

void Renderer::present()
{
    SDL_RenderPresent(renderer_);
}

std::optional<SDL_FRect> Renderer::getSpriteSrcRect(const Sprite &sprite)
{
    SDL_Texture* texture = resource_manager_->getTexture(sprite.getTextureId());
    if (!texture) {
        spdlog::error("æ— æ³•ä¸º ID {} è·å–çº¹ç†ã€‚", sprite.getTextureId());
        return std::nullopt;
    }

    auto src_rect = sprite.getSourceRect();
    if (src_rect.has_value()) {     // å¦‚æœSpriteä¸­å­˜åœ¨æŒ‡å®šrectï¼Œåˆ™åˆ¤æ–­å°ºå¯¸æ˜¯å¦æœ‰æ•ˆ
        if (src_rect.value().w <= 0 || src_rect.value().h <= 0) {
            spdlog::error("æºçŸ©å½¢å°ºå¯¸æ— æ•ˆï¼ŒID: {}", sprite.getTextureId());
            return std::nullopt;
        }
        return src_rect;
    } else {                        // å¦åˆ™è·å–çº¹ç†å°ºå¯¸å¹¶è¿”å›æ•´ä¸ªçº¹ç†å¤§å°
        SDL_FRect result = {0, 0, 0, 0};
        if (!SDL_GetTextureSize(texture, &result.w, &result.h)) {
            spdlog::error("æ— æ³•è·å–çº¹ç†å°ºå¯¸ï¼ŒID: {}", sprite.getTextureId());
            return std::nullopt;
        }
        return result;
    }
}

bool Renderer::isRectInViewport(const Camera& camera, const SDL_FRect &rect)
{
    glm::vec2 viewport_size = camera.getViewportSize();
    return rect.x + rect.w >= 0 && rect.x <= viewport_size.x &&     // ç›¸å½“äº AABBç¢°æ’æ£€æµ‹
           rect.y + rect.h >= 0 && rect.y <= viewport_size.y;
}

} // namespace engine::render

```

### ğŸ”— ä¾èµ–å…³ç³»

æ„é€ æ—¶æ¥æ”¶ `SDL_Renderer*` ä¸ `ResourceManager*`ï¼Œä»¥ä¾¿ç›´æ¥è°ƒç”¨ SDL å¹¶å‘èµ„æºç®¡ç†å™¨è¯·æ±‚çº¹ç†ã€‚

### ğŸ› ï¸ ä¸»è¦æ–¹æ³•

- ğŸŒ **`drawSprite()`** - ç»˜åˆ¶å—ç›¸æœºå½±å“çš„ä¸–ç•Œç‰©ä½“ï¼›å…ˆåšåæ ‡è½¬æ¢ï¼Œå†è¿›è¡Œè§†å£è£å‰ªï¼ˆViewport Cullingï¼‰ï¼Œå±å¤–åˆ™è·³è¿‡ä»¥æå‡æ€§èƒ½

- ğŸ–¥ï¸ **`drawUISprite()`** - åœ¨å±å¹•åæ ‡ç³»ç›´æ¥ç»˜åˆ¶ UIï¼ˆå¦‚è¡€æ¡ã€å¾—åˆ†ï¼‰ï¼Œä¸å—ç›¸æœºå½±å“

- ğŸŒ„ **`drawParallax()`** - ç”¨äºå¯é‡å¤çš„è§†å·®èƒŒæ™¯ï¼›æ ¹æ®ç›¸æœºä½ç½®ä¸æ»šåŠ¨å› å­è®¡ç®—éœ€è¦ç»˜åˆ¶çš„èƒŒæ™¯å›¾å—ï¼Œå®ç°æ— é™æ»šåŠ¨

## ğŸ”Œ 6. é›†æˆä¸æµ‹è¯•

### ğŸ—ï¸ é›†æˆæ–¹å¼

åœ¨ `GameApp` ä¸­ä»¥ `unique_ptr` æŒæœ‰ `Renderer` ä¸ `Camera`ï¼Œåœ¨ `init()` é˜¶æ®µåˆå§‹åŒ–ï¼ˆä¸ `Time`ã€`ResourceManager` æ¨¡å¼ä¸€è‡´ï¼‰ã€‚

```cpp
// game_app.h
// ...
namespace engine::render {
class Renderer;
class Camera;
}

class GameApp final {   // final è¡¨ç¤ºè¯¥ç±»ä¸èƒ½è¢«ç»§æ‰¿
private:
    // ...

    std::unique_ptr<engine::render::Renderer> renderer_;
    std::unique_ptr<engine::render::Camera> camera_;

private:
    // ...

    [[nodiscard]] bool initRenderer();
    [[nodiscard]] bool initCamera();

    // æµ‹è¯•ç”¨å‡½æ•°
    void testResourceManager();
    void testRenderer();
    void testCamera();
};

// game_app.cpp
// ...
bool GameApp::init() {
    spdlog::trace("åˆå§‹åŒ– GameApp ...");
    // ...
    if (!initRenderer()) return false;
    if (!initCamera()) return false;

    // ...
}

void GameApp::update(float /* delta_time */) {
    // æ¸¸æˆé€»è¾‘æ›´æ–°
    testCamera();
}

void GameApp::render() {
    // 1. æ¸…é™¤å±å¹•
    renderer_->clearScreen();

    // 2. å…·ä½“æ¸²æŸ“ä»£ç 
    testRenderer();

    // 3. æ›´æ–°å±å¹•æ˜¾ç¤º
    renderer_->present();
}

// ...

bool GameApp::initSDL() {
    // å…¶å®ƒåˆå§‹åŒ–...

    // è®¾ç½®é€»è¾‘åˆ†è¾¨ç‡
    SDL_SetRenderLogicalPresentation(sdl_renderer_, 640, 360, SDL_LOGICAL_PRESENTATION_LETTERBOX);
    // ...
}

bool GameApp::initRenderer() {
    try {
        renderer_ = std::make_unique<engine::render::Renderer>(sdl_renderer_, resource_manager_.get());
    } catch (const std::exception& e) {
        spdlog::error("åˆå§‹åŒ–æ¸²æŸ“å™¨å¤±è´¥: {}", e.what());
        return false;
    }
    spdlog::trace("æ¸²æŸ“å™¨åˆå§‹åŒ–æˆåŠŸã€‚");
    return true;
}

bool GameApp::initCamera() {
    try {
        camera_ = std::make_unique<engine::render::Camera>(glm::vec2(640, 360));
    } catch (const std::exception& e) {
        spdlog::error("åˆå§‹åŒ–ç›¸æœºå¤±è´¥: {}", e.what());
        return false;
    }
    spdlog::trace("ç›¸æœºåˆå§‹åŒ–æˆåŠŸã€‚");
    return true;
}

// --- æµ‹è¯•ç”¨å‡½æ•° ---
// ...
void GameApp::testRenderer()
{
    engine::render::Sprite sprite_world("assets/textures/Actors/frog.png");
    engine::render::Sprite sprite_ui("assets/textures/UI/buttons/Start1.png");
    engine::render::Sprite sprite_parallax("assets/textures/Layers/back.png");

    static float rotation = 0.0f;
    rotation += 0.1f;

    // æ³¨æ„æ¸²æŸ“é¡ºåº
    renderer_->drawParallax(*camera_, sprite_parallax, glm::vec2(100, 100), glm::vec2(0.5f, 0.5f), glm::bvec2(true, false));
    renderer_->drawSprite(*camera_, sprite_world, glm::vec2(200, 200), glm::vec2(1.0f, 1.0f), rotation);
    renderer_->drawUISprite(sprite_ui, glm::vec2(100, 100));

}

void GameApp::testCamera()
{
    auto key_state = SDL_GetKeyboardState(nullptr);
    if (key_state[SDL_SCANCODE_UP]) camera_->move(glm::vec2(0, -1));   
    if (key_state[SDL_SCANCODE_DOWN]) camera_->move(glm::vec2(0, 1));
    if (key_state[SDL_SCANCODE_LEFT]) camera_->move(glm::vec2(-1, 0));
    if (key_state[SDL_SCANCODE_RIGHT]) camera_->move(glm::vec2(1, 0));
}
```

### ğŸ¬ æ¸²æŸ“æµç¨‹

é‡æ„ä¸ºä¸‰æ­¥ï¼š

1. ğŸ§¹ **`renderer_->clearScreen()`** - ç”¨èƒŒæ™¯è‰²æ¸…ç©ºç”»å¸ƒ
2. ğŸ¨ **`testRenderer()`** - å‘å‡ºæ‰€æœ‰å…·ä½“ç»˜åˆ¶æŒ‡ä»¤
3. ğŸ“º **`renderer_->present()`** - å°†ç”»å¸ƒå†…å®¹å‘ˆç°åˆ°å±å¹•

### ğŸ§ª æµ‹è¯•å‡½æ•°

- ğŸ“¹ **`testCamera()`** - ç”¨æ–¹å‘é”®ç§»åŠ¨ç›¸æœºï¼ŒéªŒè¯è§†å›¾ç§»åŠ¨ä¸è¾¹ç•Œé™åˆ¶
- ğŸ¨ **`testRenderer()`** - åŒæ—¶ç»˜åˆ¶èƒŒæ™¯ï¼ˆè§†å·®ï¼‰ã€é’è›™ï¼ˆä¸–ç•Œï¼‰ä¸æŒ‰é’®ï¼ˆUIï¼‰ï¼Œå¹¶è®©é’è›™æ—‹è½¬ï¼Œæ¼”ç¤ºä¸‰ç±»ç»˜åˆ¶æ–¹æ³•

## ğŸ”¨ 7. ç¼–è¯‘ä¸è¿è¡Œ

### ğŸ“ èµ„æºå‡†å¤‡

ç¡®ä¿æµ‹è¯•å›¾ç‰‡ï¼ˆå¦‚ `frog.png`ã€`Start1.png`ã€`back.png`ï¼‰ä½äºæ­£ç¡®çš„ `assets` ç›®å½•ã€‚

### ğŸš€ è¿è¡Œæ•ˆæœ

é‡æ–°ç¼–è¯‘å¹¶è¿è¡Œé¡¹ç›®ã€‚

ä½ å°†çœ‹åˆ°ï¼š

- ğŸŒŠ **å¯é‡å¤çš„è“è‰²èƒŒæ™¯**ï¼ˆè§†å·®æ»šåŠ¨ï¼‰
- ğŸ¸ **å±…ä¸­æ—‹è½¬çš„é’è›™**ï¼ˆä¸–ç•Œç‰©ä½“ï¼‰
- ğŸ”˜ **å·¦ä¸Šè§’é™æ­¢çš„ UI æŒ‰é’®**ï¼ˆå±å¹•åæ ‡ï¼‰
- âŒ¨ï¸ **å¯ç”¨æ–¹å‘é”®ç§»åŠ¨è§†è§’**ï¼Œè§‚å¯ŸèƒŒæ™¯ä¸ç‰©ä½“çš„æ»šåŠ¨å·®å¼‚

### ğŸ‰ æˆæœ

è‡³æ­¤ï¼Œæˆ‘ä»¬ä»ç©ºç™½çª—å£è¿ˆå‘äº†å…·å¤‡å®Œæ•´æ¸²æŸ“èƒ½åŠ›çš„ **2D æ¸¸æˆå¼•æ“åŸºç¡€**ã€‚

---

## ğŸ“‹ æ€»ç»“

æˆ‘ä»¬æˆåŠŸæ„å»ºäº†ä¸€ä¸ªå®Œæ•´çš„ 2D æ¸²æŸ“ç³»ç»Ÿï¼ŒåŒ…å«ï¼š

- âœ… **åƒç´ å®Œç¾çš„é€»è¾‘åˆ†è¾¨ç‡**
- âœ… **çµæ´»çš„ç²¾çµç³»ç»Ÿ**
- âœ… **å¼ºå¤§çš„ç›¸æœºæ§åˆ¶**
- âœ… **é«˜æ•ˆçš„æ¸²æŸ“ç®¡çº¿**
- âœ… **è§†å·®æ»šåŠ¨èƒŒæ™¯**

è¿™ä¸ºæˆ‘ä»¬åç»­çš„æ¸¸æˆå¯¹è±¡ã€åŠ¨ç”»ç³»ç»Ÿå’Œåœºæ™¯ç®¡ç†å¥ å®šäº†åšå®çš„åŸºç¡€ï¼