# å…³å¡è½½å…¥å™¨-å›¾ç‰‡å±‚

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- Bç«™åµŒå…¥ï¼šä½¿ç”¨ https æ˜ç¡®åè®®ï¼ˆé¿å… file:// æˆ– http å¯¼è‡´è¢«æµè§ˆå™¨æ‹¦æˆªï¼‰ -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1vYGEzdEGR&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[åœ¨ Bilibili ä¸Šè§‚çœ‹](https://www.bilibili.com/video/BV1vYGEzdEGR)

## ğŸ“Œ é—®é¢˜èƒŒæ™¯

æˆ‘ä»¬å·²ç»æ‹¥æœ‰äº†ä¸€ä¸ªåŠŸèƒ½æ—¥ç›Šå¼ºå¤§çš„æ¸¸æˆå¼•æ“ï¼Œä½†è‡³ä»Šä¸ºæ­¢ï¼Œæ‰€æœ‰çš„æ¸¸æˆå¯¹è±¡ï¼ˆæ¯”å¦‚é‚£ä¸ªæµ‹è¯•ç”¨çš„ç®±å­ï¼‰éƒ½æ˜¯åœ¨ä»£ç ä¸­ **"ç¡¬ç¼–ç "** åˆ›å»ºçš„ã€‚

### âš ï¸ ç¡¬ç¼–ç çš„é—®é¢˜

```cpp
// å½“å‰çš„åšæ³• - ä¸å¯è¡Œï¼
void GameScene::createTestObject() {
    auto obj = std::make_unique<GameObject>("box");
    obj->addComponent<TransformComponent>(glm::vec2(100, 100));
    obj->addComponent<SpriteComponent>("crate.png");
    // å¦‚æœè¦åˆ›å»º100ä¸ªå¯¹è±¡ï¼Ÿæ‰‹åŠ¨å†™100éï¼Ÿ
}
```

è¿™ç§æ–¹å¼å¯¹äºå¼€å‘ä¸€ä¸ªå®Œæ•´çš„æ¸¸æˆæ¥è¯´æ˜¯ **ä¸å¯è¡Œ** çš„ã€‚

### ğŸ¯ ä¸“ä¸šçš„æ¸¸æˆå¼€å‘æµç¨‹

```
å…³å¡è®¾è®¡å¸ˆ
    â†“
ä½¿ç”¨ä¸“ä¸šå·¥å…·è®¾è®¡å…³å¡
    â†“
å¯¼å‡ºä¸ºæ•°æ®æ–‡ä»¶
    â†“
ç¨‹åºè¯»å–å¹¶è§£é‡Šæ•°æ®
    â†“
è‡ªåŠ¨æ„å»ºæ¸¸æˆä¸–ç•Œ
```

æœ¬èŠ‚è¯¾ï¼Œæˆ‘ä»¬å°†å¼•å…¥å¼ºå¤§çš„å¼€æºåœ°å›¾ç¼–è¾‘å™¨ **Tiled**ï¼Œå¹¶å¼€å§‹ç¼–å†™æˆ‘ä»¬çš„ **å…³å¡åŠ è½½å™¨ï¼ˆLevelLoaderï¼‰**ã€‚

> ğŸ’¡ ç¬¬ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•è§£æ Tiled å¯¼å‡ºçš„ JSON æ–‡ä»¶ï¼Œå¹¶åŠ è½½å…¶ä¸­æœ€ç®€å•çš„ä¸€ç§å›¾å±‚â€”â€”**å›¾ç‰‡å±‚ï¼ˆImage Layerï¼‰**ï¼Œä»¥å®ç°è§†å·®æ»šåŠ¨èƒŒæ™¯ã€‚

---

## 1. Tiled ä¸ JSON æ ¼å¼ç®€ä»‹

### ğŸ› ï¸ Tiled æ˜¯ä»€ä¹ˆï¼Ÿ

**Tiled** æ˜¯ä¸€æ¬¾å…è´¹ã€çµæ´»çš„å…³å¡ç¼–è¾‘å™¨ï¼Œè¢«å¹¿æ³›ç”¨äº 2D æ¸¸æˆå¼€å‘ã€‚

**ç‰¹ç‚¹ï¼š**
- âœ… å…è´¹å¼€æº
- âœ… è·¨å¹³å°æ”¯æŒ
- âœ… å¯è§†åŒ–ç¼–è¾‘
- âœ… æ”¯æŒå¤šç§å¯¼å‡ºæ ¼å¼

**åŠŸèƒ½ï¼š**
- ğŸ¨ åƒæ­ç§¯æœ¨ä¸€æ ·ç»„åˆç“¦ç‰‡
- ğŸ“ æ”¾ç½®å¯¹è±¡å’Œå®ä½“
- ğŸ–¼ï¸ åˆ›å»ºå¤šå±‚èƒŒæ™¯
- ğŸ’¾ å¯¼å‡ºä¸ºå¤šç§æ ¼å¼ï¼ˆJSONã€XMLã€TMXç­‰ï¼‰

> æˆ‘ä»¬é€‰æ‹©çš„æ˜¯æ˜“äºè§£æçš„ **JSON æ ¼å¼**ã€‚

---

### ğŸ“„ Tiled JSON åœ°å›¾æ–‡ä»¶ç»“æ„

ä¸€ä¸ªå…¸å‹çš„ Tiled JSON åœ°å›¾æ–‡ä»¶ç»“æ„å¦‚ä¸‹ï¼š

```json
{
    "compressionlevel": -1,
    "height": 30,
    "width": 100,
    "tileheight": 16,
    "tilewidth": 16,
    "layers": [
        {
            "id": 1,
            "image": "../textures/Layers/back.png",
            "name": "Background",
            "offsetx": -168,
            "offsety": -168,
            "parallaxx": 0.5,
            "parallaxy": 0.5,
            "repeatx": true,
            "repeaty": false,
            "type": "imagelayer",
            "visible": true,
            "opacity": 1,
            "x": 0,
            "y": 0
        },
        {
            "id": 2,
            "name": "Tiles",
            "type": "tilelayer",
            "data": [0, 0, 1, 2, 3, ...],
            "visible": true
        },
        {
            "id": 3,
            "name": "Objects",
            "type": "objectgroup",
            "objects": [...]
        }
    ]
}
```

### ğŸ”‘ å…³é”®å­—æ®µè¯´æ˜

| å­—æ®µ | è¯´æ˜ | ä½¿ç”¨åœºæ™¯ |
|------|------|----------|
| `type` | å›¾å±‚ç±»å‹ | `"imagelayer"` / `"tilelayer"` / `"objectgroup"` |
| `image` | å›¾ç‰‡è·¯å¾„ | Image Layer ä¸“ç”¨ |
| `parallaxx` / `parallaxy` | è§†å·®å› å­ | æ§åˆ¶æ»šåŠ¨é€Ÿåº¦ï¼ˆ0=é™æ­¢ï¼Œ1=éšç›¸æœºï¼‰ |
| `repeatx` / `repeaty` | æ˜¯å¦é‡å¤ | èƒŒæ™¯æ˜¯å¦å¹³é“º |
| `offsetx` / `offsety` | åç§»é‡ | å›¾å±‚çš„åˆå§‹ä½ç½® |
| `visible` | æ˜¯å¦å¯è§ | æ§åˆ¶å›¾å±‚æ˜¾ç¤º |

---

### ğŸ¯ Tiled åœ°å›¾è§£ææ€è·¯

æˆ‘ä»¬çš„è§£ææ€è·¯å¾ˆç®€å•ï¼Œå°±æ˜¯éå† `layers` æ•°ç»„ï¼Œæ ¹æ®æ¯ä¸ªå›¾å±‚å¯¹è±¡çš„ `type` å­—æ®µæ¥å†³å®šå¦‚ä½•å¤„ç†å®ƒã€‚

```
å¼€å§‹è§£æ
    â†“
è·å– layers æ•°ç»„å¹¶éå†
    â†“
æ£€æŸ¥å›¾å±‚ç±»å‹ (type)
    â†“
â”œâ”€ type: "imagelayer"
â”‚  â”œâ”€ è¯»å–å›¾ç‰‡è·¯å¾„ã€è§†å·®å› å­ã€é‡å¤æ ‡å¿—
â”‚  â”œâ”€ åˆ›å»º GameObject
â”‚  â””â”€ æ·»åŠ  ParallaxComponent
â”‚
â”œâ”€ type: "tilelayer"
â”‚  â””â”€ [ä¸‹èŠ‚è¯¾å®ç°]
â”‚
â””â”€ type: "objectgroup"
   â””â”€ [ä¸‹ä¸‹èŠ‚è¯¾å®ç°]
```

---

## 2. ParallaxComponentï¼šä¸“ä¸ºè§†å·®èƒŒæ™¯è€Œç”Ÿ

`imagelayer` é€šå¸¸ç”¨äºå®ç°å¤šå±‚æ»šåŠ¨çš„èƒŒæ™¯ï¼Œå³ **"è§†å·®"** æ•ˆæœã€‚

### ğŸ¤” ä¸ºä»€ä¹ˆéœ€è¦æ–°ç»„ä»¶ï¼Ÿ

è™½ç„¶å®ƒå’Œ `SpriteComponent` å¾ˆåƒï¼ˆéƒ½æ˜¯æ¸²æŸ“ä¸€å¼ å›¾ç‰‡ï¼‰ï¼Œä½†å®ƒçš„æ¸²æŸ“é€»è¾‘ä¸ç›¸æœºä½ç½®ç´§å¯†ç›¸å…³ï¼š

| ç‰¹æ€§ | SpriteComponent | ParallaxComponent |
|------|-----------------|-------------------|
| **å®šä½æ–¹å¼** | ç»å¯¹ä¸–ç•Œåæ ‡ | ç›¸å¯¹ç›¸æœºä½ç½® |
| **æ»šåŠ¨é€Ÿåº¦** | å›ºå®šä¸å˜ | æ ¹æ®è§†å·®å› å­å˜åŒ– |
| **é‡å¤å¹³é“º** | ä¸æ”¯æŒ | æ”¯æŒæ°´å¹³/å‚ç›´é‡å¤ |
| **ä½¿ç”¨åœºæ™¯** | æ¸¸æˆå¯¹è±¡ã€è§’è‰² | èƒŒæ™¯å±‚ã€è£…é¥°å±‚ |

### ğŸ¨ è§†å·®æ•ˆæœç¤ºæ„

```
è¿œæ™¯ï¼ˆ0.3 å€é€Ÿï¼‰  ğŸ”ï¸  æ…¢é€Ÿæ»šåŠ¨
ä¸­æ™¯ï¼ˆ0.6 å€é€Ÿï¼‰  ğŸŒ²  ä¸­é€Ÿæ»šåŠ¨
è¿‘æ™¯ï¼ˆ1.0 å€é€Ÿï¼‰  ğŸŒ¿  è·Ÿéšç›¸æœº
ç©å®¶ï¼ˆå›ºå®šï¼‰      ğŸƒ  
```

ä¸ºæ­¤ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¸“é—¨çš„ `ParallaxComponent`ã€‚

---

### engine/component/parallax_component.h

```cpp
#pragma once
#include "component.h"
#include "../render/sprite.h"
#include <string>
#include <glm/vec2.hpp>

namespace engine::component {
class TransformComponent;

/**
 * @brief åœ¨èƒŒæ™¯ä¸­æ¸²æŸ“å¯æ»šåŠ¨çº¹ç†çš„ç»„ä»¶ï¼Œä»¥åˆ›å»ºè§†å·®æ•ˆæœã€‚
 *
 * è¯¥ç»„ä»¶æ ¹æ®ç›¸æœºçš„ä½ç½®å’Œæ»šåŠ¨å› å­æ¥ç§»åŠ¨çº¹ç†ã€‚
 */
class ParallaxComponent final : public Component {
    friend class engine::object::GameObject;
private:
    TransformComponent* transform_ = nullptr;   ///< @brief ç¼“å­˜å˜æ¢ç»„ä»¶

    engine::render::Sprite sprite_;             ///< @brief ç²¾çµå¯¹è±¡
    glm::vec2 scroll_factor_;                   ///< @brief æ»šåŠ¨é€Ÿåº¦å› å­ (0=é™æ­¢, 1=éšç›¸æœºç§»åŠ¨, <1=æ¯”ç›¸æœºæ…¢)
    glm::bvec2 repeat_;                         ///< @brief æ˜¯å¦æ²¿ç€Xå’ŒYè½´å‘¨æœŸæ€§é‡å¤
    bool is_hidden_ = false;                    ///< @brief æ˜¯å¦éšè—ï¼ˆä¸æ¸²æŸ“ï¼‰

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param texture_id èƒŒæ™¯çº¹ç†çš„èµ„æº IDã€‚
     * @param scroll_factor æ§åˆ¶èƒŒæ™¯ç›¸å¯¹äºç›¸æœºç§»åŠ¨é€Ÿåº¦çš„å› å­ã€‚
     *                      (0, 0) è¡¨ç¤ºå®Œå…¨é™æ­¢ã€‚
     *                      (1, 1) è¡¨ç¤ºä¸ç›¸æœºå®Œå…¨åŒæ­¥ç§»åŠ¨ã€‚
     *                      (0.5, 0.5) è¡¨ç¤ºä»¥ç›¸æœºä¸€åŠçš„é€Ÿåº¦ç§»åŠ¨ã€‚
     */
    ParallaxComponent(const std::string& texture_id, const glm::vec2& scroll_factor, const glm::bvec2& repeat);

    // --- è®¾ç½®å™¨ ---
    void setSprite(const engine::render::Sprite& sprite) { sprite_ = sprite; }  ///< @brief è®¾ç½®ç²¾çµå¯¹è±¡
    void setScrollFactor(const glm::vec2& factor) { scroll_factor_ = factor; }  ///< @brief è®¾ç½®æ»šåŠ¨é€Ÿåº¦å› å­
    void setRepeat(const glm::bvec2& repeat) { repeat_ = repeat; }              ///< @brief è®¾ç½®æ˜¯å¦é‡å¤
    void setHidden(bool hidden) { is_hidden_ = hidden; }                        ///< @brief è®¾ç½®æ˜¯å¦éšè—ï¼ˆä¸æ¸²æŸ“ï¼‰

    // --- è·å–å™¨ ---
    const engine::render::Sprite& getSprite() const { return sprite_; }          ///< @brief è·å–ç²¾çµå¯¹è±¡
    const glm::vec2& getScrollFactor() const { return scroll_factor_; }          ///< @brief è·å–æ»šåŠ¨é€Ÿåº¦å› å­
    const glm::bvec2& getRepeat() const { return repeat_; }                      ///< @brief è·å–æ˜¯å¦é‡å¤
    bool isHidden() const { return is_hidden_; }                                  ///< @brief è·å–æ˜¯å¦éšè—ï¼ˆä¸æ¸²æŸ“ï¼‰

protected:
    // æ ¸å¿ƒå¾ªç¯å‡½æ•°è¦†ç›–
    void update(float, engine::core::Context&) override {}     // å¿…é¡»å®ç°çº¯è™šå‡½æ•°ï¼Œç•™ç©º
    void init() override;                                      
    void render(engine::core::Context& context) override;      
};

} // namespace engine::component
```

### æ ¸å¿ƒæˆå‘˜å˜é‡

| å˜é‡ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `scroll_factor_` | `glm::vec2` | æ»šåŠ¨é€Ÿåº¦å› å­ã€‚(0,0)=é™æ­¢ï¼Œ(1,1)=éšç›¸æœºï¼Œ(0.5,0.5)=åŠé€Ÿ |
| `repeat_` | `glm::bvec2` | æ˜¯å¦åœ¨ X/Y è½´ä¸Šé‡å¤å¹³é“º |
| `is_hidden_` | `bool` | æ˜¯å¦éšè—æ­¤å›¾å±‚ |

---

### engine/component/parallax_component.cpp

```cpp
#include "parallax_component.h"
#include "transform_component.h"
#include "../render/renderer.h"
#include "../render/camera.h"
#include "../render/sprite.h"
#include "../object/game_object.h"
#include "../core/context.h"
#include <spdlog/spdlog.h>

namespace engine::component {

ParallaxComponent::ParallaxComponent(const std::string& texture_id, const glm::vec2& scroll_factor, const glm::bvec2& repeat)
    : sprite_(engine::render::Sprite(texture_id)),          // è§†å·®èƒŒæ™¯é»˜è®¤ä¸ºæ•´å¼ å›¾ç‰‡
      scroll_factor_(scroll_factor),
      repeat_(repeat)
{
    spdlog::trace("ParallaxComponent åˆå§‹åŒ–å®Œæˆï¼Œçº¹ç† ID: {}", texture_id);
}

void ParallaxComponent::init() {
    if (!owner_) {
        spdlog::error("ParallaxComponent åˆå§‹åŒ–æ—¶ï¼ŒGameObject ä¸ºç©ºã€‚");
        return;
    }
    transform_ = owner_->getComponent<TransformComponent>();
    if (!transform_) {
        spdlog::error("ParallaxComponent åˆå§‹åŒ–æ—¶ï¼ŒGameObject ä¸Šæ²¡æœ‰æ‰¾åˆ° TransformComponent ç»„ä»¶ã€‚");
        return;
    }
}

void ParallaxComponent::render(engine::core::Context& context) {
    if (is_hidden_ || !transform_) {
        return;
    }
    // ç›´æ¥è°ƒç”¨è§†å·®æ»šåŠ¨ç»˜åˆ¶å‡½æ•°
    context.getRenderer().drawParallax(context.getCamera(), sprite_, transform_->getPosition(), scroll_factor_, repeat_, transform_->getScale());  
}

} // namespace engine::component
```

### å…³é”®æ–¹æ³•è¯´æ˜

| æ–¹æ³• | èŒè´£ |
|------|------|
| `init()` | ç¼“å­˜ `TransformComponent` æŒ‡é’ˆï¼Œé¿å…æ¯å¸§æŸ¥æ‰¾ |
| `render()` | è°ƒç”¨ `Renderer::drawParallax()` å®ç°è§†å·®æ¸²æŸ“ |

> ğŸ’¡ **è®¾è®¡äº®ç‚¹**ï¼šè¿™ä¸ªç»„ä»¶çš„æ ¸å¿ƒæ˜¯ `scroll_factor_` å’Œ `repeat_`ï¼Œå®ƒçš„ `render` æ–¹æ³•å°†ç›´æ¥è°ƒç”¨æˆ‘ä»¬åœ¨ `Renderer` ä¸­å·²ç»å‡†å¤‡å¥½çš„ `drawParallax` å‡½æ•°ã€‚

---

## 3. LevelLoaderï¼šè§£æ Tiled JSON

è¿™æ˜¯æœ¬èŠ‚è¯¾çš„ **æ ¸å¿ƒ**ã€‚`LevelLoader` ç±»å°†è´Ÿè´£è¯»å– `.tmj` æ–‡ä»¶ï¼Œå¹¶æ ¹æ®å…¶å†…å®¹åœ¨ä¼ å…¥çš„ `Scene` ä¸­åˆ›å»ºç›¸åº”çš„æ¸¸æˆå¯¹è±¡ã€‚

### ğŸ¯ è®¾è®¡ç›®æ ‡

| åŠŸèƒ½ | è¯´æ˜ |
|------|------|
| **è¯»å– JSON** | åŠ è½½å¹¶è§£æ Tiled å¯¼å‡ºçš„åœ°å›¾æ–‡ä»¶ |
| **åˆ†å‘å¤„ç†** | æ ¹æ®å›¾å±‚ç±»å‹è°ƒç”¨ä¸åŒçš„åŠ è½½å‡½æ•° |
| **è·¯å¾„è§£æ** | å¤„ç†ç›¸å¯¹è·¯å¾„ï¼Œè½¬æ¢ä¸ºç»å¯¹è·¯å¾„ |
| **åˆ›å»ºå¯¹è±¡** | è‡ªåŠ¨åœ¨ Scene ä¸­åˆ›å»º GameObject |

---

### engine/scene/level_loader.h

```cpp
#pragma once
#include <string>
#include <nlohmann/json_fwd.hpp>

namespace engine::scene {
class Scene;

class LevelLoader final {
    std::string map_path_;      ///< @brief åœ°å›¾è·¯å¾„ï¼ˆæ‹¼æ¥è·¯å¾„æ—¶éœ€è¦ï¼‰
public:
    LevelLoader() = default;

    /**
     * @brief åŠ è½½å…³å¡æ•°æ®åˆ°æŒ‡å®šçš„ Scene å¯¹è±¡ä¸­ã€‚
     * @param map_path Tiled JSON åœ°å›¾æ–‡ä»¶çš„è·¯å¾„ã€‚
     * @param scene è¦åŠ è½½æ•°æ®çš„ç›®æ ‡ Scene å¯¹è±¡ã€‚
     * @return bool æ˜¯å¦åŠ è½½æˆåŠŸã€‚
     */
    bool loadLevel(const std::string& map_path, Scene& scene);

private:
    void loadImageLayer(const nlohmann::json& layer_json, Scene& scene);    ///< @brief åŠ è½½å›¾ç‰‡å›¾å±‚
    void loadTileLayer(const nlohmann::json& layer_json, Scene& scene);     ///< @brief åŠ è½½ç“¦ç‰‡å›¾å±‚
    void loadObjectLayer(const nlohmann::json& layer_json, Scene& scene);   ///< @brief åŠ è½½å¯¹è±¡å›¾å±‚

    /**
     * @brief è§£æå›¾ç‰‡è·¯å¾„ï¼Œåˆå¹¶åœ°å›¾è·¯å¾„å’Œç›¸å¯¹è·¯å¾„ã€‚ä¾‹å¦‚ï¼š
     * 1. åœ°å›¾è·¯å¾„ï¼š"assets/maps/level1.tmj"
     * 2. ç›¸å¯¹è·¯å¾„ï¼š"../textures/Layers/back.png"
     * 3. æœ€ç»ˆè·¯å¾„ï¼š"assets/textures/Layers/back.png"
     * @param image_path ï¼ˆå›¾ç‰‡ï¼‰ç›¸å¯¹è·¯å¾„
     * @return std::string è§£æåçš„å®Œæ•´è·¯å¾„ã€‚
     */
    std::string resolvePath(std::string image_path);
};

} // namespace engine::scene
```

---

### engine/scene/level_loader.cpp

```cpp
#include "level_loader.h"
#include "../component/parallax_component.h"
#include "../component/transform_component.h"
#include "../object/game_object.h"
#include "../scene/scene.h"
#include "../core/context.h"
#include "../render/sprite.h"
#include <nlohmann/json.hpp>
#include <fstream>
#include <spdlog/spdlog.h>
#include <glm/vec2.hpp>
#include <filesystem>

namespace engine::scene {

bool LevelLoader::loadLevel(const std::string& level_path, Scene& scene) {
    map_path_ = level_path;
    // 1. åŠ è½½ JSON æ–‡ä»¶
    std::ifstream file(level_path);
    if (!file.is_open()) {
        spdlog::error("æ— æ³•æ‰“å¼€å…³å¡æ–‡ä»¶: {}", level_path);
        return false;
    }

    // 2. è§£æ JSON æ•°æ®
    nlohmann::json json_data;
    try {
        file >> json_data;
    } catch (const nlohmann::json::parse_error& e) {
        spdlog::error("è§£æ JSON æ•°æ®å¤±è´¥: {}", e.what());
        return false;
    }

    // 3. åŠ è½½å›¾å±‚æ•°æ®
    if (!json_data.contains("layers") || !json_data["layers"].is_array()) {       // åœ°å›¾æ–‡ä»¶ä¸­å¿…é¡»æœ‰ layers æ•°ç»„
        spdlog::error("åœ°å›¾æ–‡ä»¶ '{}' ä¸­ç¼ºå°‘æˆ–æ— æ•ˆçš„ 'layers' æ•°ç»„ã€‚", level_path);
        return false;
    }
    for (const auto& layer_json : json_data["layers"]) {
        // è·å–å„å›¾å±‚å¯¹è±¡ä¸­çš„ç±»å‹ï¼ˆtypeï¼‰å­—æ®µ
        std::string layer_type = layer_json.value("type", "none");
        if (!layer_json.value("visible", true)) {
            spdlog::info("å›¾å±‚ '{}' ä¸å¯è§ï¼Œè·³è¿‡åŠ è½½ã€‚", layer_json.value("name", "Unnamed"));
            continue;
        }

        // æ ¹æ®å›¾å±‚ç±»å‹å†³å®šåŠ è½½æ–¹æ³•
        if (layer_type == "imagelayer") {       
            loadImageLayer(layer_json, scene);
        } else if (layer_type == "tilelayer") {
            loadTileLayer(layer_json, scene);
        } else if (layer_type == "objectgroup") {
            loadObjectLayer(layer_json, scene);
        } else {
            spdlog::warn("ä¸æ”¯æŒçš„å›¾å±‚ç±»å‹: {}", layer_type);
        }
    }

    spdlog::info("å…³å¡åŠ è½½å®Œæˆ: {}", level_path);
    return true;
}

void LevelLoader::loadImageLayer(const nlohmann::json& layer_json, Scene& scene) {
    // è·å–çº¹ç†ç›¸å¯¹è·¯å¾„ ï¼ˆä¼šè‡ªåŠ¨å¤„ç†'\/'ç¬¦å·ï¼‰
    const std::string& image_path = layer_json.value("image", "");
    if (image_path.empty()) {
        spdlog::error("å›¾å±‚ '{}' ç¼ºå°‘ 'image' å±æ€§ã€‚", layer_json.value("name", "Unnamed"));
        return;
    }
    auto texture_id = resolvePath(image_path);

    // è·å–å›¾å±‚åç§»é‡ï¼ˆjsonä¸­æ²¡æœ‰åˆ™ä»£è¡¨æœªè®¾ç½®ï¼Œç»™é»˜è®¤å€¼å³å¯ï¼‰
    const glm::vec2 offset = glm::vec2(layer_json.value("offsetx", 0.0f), layer_json.value("offsety", 0.0f));
    
    // è·å–è§†å·®å› å­åŠé‡å¤æ ‡å¿—
    const glm::vec2 scroll_factor = glm::vec2(layer_json.value("parallaxx", 1.0f), layer_json.value("parallaxy", 1.0f));
    const glm::bvec2 repeat = glm::bvec2(layer_json.value("repeatx", false), layer_json.value("repeaty", false));
    
    // è·å–å›¾å±‚åç§°
    const std::string& layer_name = layer_json.value("name", "Unnamed");
    
    /*  å¯ç”¨ç±»ä¼¼æ–¹æ³•è·å–å…¶å®ƒå„ç§å±æ€§ï¼Œè¿™é‡Œæˆ‘ä»¬æš‚æ—¶ç”¨ä¸ä¸Š */
    
    // åˆ›å»ºæ¸¸æˆå¯¹è±¡
    auto game_object = std::make_unique<engine::object::GameObject>(layer_name);
    // ä¾æ¬¡æ·»åŠ Transformï¼ŒParallaxç»„ä»¶
    game_object->addComponent<engine::component::TransformComponent>(offset);
    game_object->addComponent<engine::component::ParallaxComponent>(texture_id, scroll_factor, repeat);
    // æ·»åŠ åˆ°åœºæ™¯ä¸­
    scene.addGameObject(std::move(game_object));
    spdlog::info("åŠ è½½å›¾å±‚: '{}' å®Œæˆ", layer_name);
}

void LevelLoader::loadTileLayer(const nlohmann::json&, Scene&)
{
    // TODO
}

void LevelLoader::loadObjectLayer(const nlohmann::json&, Scene&)
{
    // TODO
}

std::string LevelLoader::resolvePath(std::string image_path)
{
    try {   
    // è·å–åœ°å›¾æ–‡ä»¶çš„çˆ¶ç›®å½•ï¼ˆç›¸å¯¹äºå¯æ‰§è¡Œæ–‡ä»¶ï¼‰ "assets/maps/level1.tmj" -> "assets/maps"
    auto map_dir = std::filesystem::path(map_path_).parent_path();
    // åˆå¹¶è·¯å¾„ï¼ˆç›¸å¯¹äºå¯æ‰§è¡Œæ–‡ä»¶ï¼‰å¹¶è¿”å›ã€‚ /* std::filesystem::canonicalï¼šè§£æè·¯å¾„ä¸­çš„å½“å‰ç›®å½•ï¼ˆ.ï¼‰å’Œä¸Šçº§ç›®å½•ï¼ˆ..ï¼‰å¯¼èˆªç¬¦ï¼Œ
                                      /*  å¾—åˆ°ä¸€ä¸ªå¹²å‡€çš„è·¯å¾„ */
    auto final_path = std::filesystem::canonical(map_dir / image_path);
    return final_path.string();
    } catch (const std::exception& e) {
        spdlog::error("è§£æè·¯å¾„å¤±è´¥: {}", e.what());
        return image_path;
    }
}

} // namespace engine::scene
```

---

### ğŸ” å…³é”®æ–¹æ³•è¯¦è§£

#### 1. loadLevel()

è¿™æ˜¯ä¸»å…¥å£ï¼Œè´Ÿè´£ï¼š

```
1. æ‰“å¼€å¹¶è¯»å– JSON æ–‡ä»¶
    â†“
2. è§£æ JSON æ•°æ®
    â†“
3. éå† layers æ•°ç»„
    â†“
4. æ ¹æ® type åˆ†å‘åˆ°ä¸åŒçš„å¤„ç†å‡½æ•°
```

**é”™è¯¯å¤„ç†ï¼š**
- âŒ æ–‡ä»¶æ— æ³•æ‰“å¼€
- âŒ JSON è§£æå¤±è´¥
- âŒ ç¼ºå°‘ layers æ•°ç»„

#### 2. loadImageLayer()

è¿™æ˜¯æœ¬èŠ‚è¯¾çš„ **æ ¸å¿ƒ**ï¼š

**å¤„ç†æµç¨‹ï¼š**

| æ­¥éª¤ | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| 1 | æå–å›¾ç‰‡è·¯å¾„ | ä» `image` å­—æ®µè·å– |
| 2 | è§£æä¸ºç»å¯¹è·¯å¾„ | è°ƒç”¨ `resolvePath()` |
| 3 | æå–åç§»é‡ | `offsetx`, `offsety` |
| 4 | æå–è§†å·®å› å­ | `parallaxx`, `parallaxy` |
| 5 | æå–é‡å¤æ ‡å¿— | `repeatx`, `repeaty` |
| 6 | åˆ›å»º GameObject | ä½¿ç”¨å›¾å±‚åç§° |
| 7 | æ·»åŠ  Transform ç»„ä»¶ | è®¾ç½®åç§»é‡ |
| 8 | æ·»åŠ  Parallax ç»„ä»¶ | è®¾ç½®æ‰€æœ‰è§†å·®å±æ€§ |
| 9 | æ·»åŠ åˆ°åœºæ™¯ | `scene.addGameObject()` |

#### 3. resolvePath()

è¿™æ˜¯ä¸€ä¸ª **éå¸¸é‡è¦** çš„è¾…åŠ©å‡½æ•°ã€‚

**é—®é¢˜åœºæ™¯ï¼š**

Tiled ä¸­ä¿å­˜çš„å›¾ç‰‡è·¯å¾„æ˜¯ **ç›¸å¯¹äº `.tmj` æ–‡ä»¶** çš„ã€‚

```
åœ°å›¾æ–‡ä»¶ï¼šassets/maps/level1.tmj
å›¾ç‰‡è·¯å¾„ï¼š../textures/Layers/back.png
éœ€è¦è½¬æ¢ä¸ºï¼šassets/textures/Layers/back.png
```

**å®ç°æ–¹å¼ï¼š**

ä½¿ç”¨ C++17 çš„ `<filesystem>` åº“ï¼š

1. è·å–åœ°å›¾æ–‡ä»¶çš„çˆ¶ç›®å½•ï¼š`std::filesystem::path(map_path_).parent_path()`
2. åˆå¹¶è·¯å¾„ï¼š`map_dir / image_path`
3. è§„èŒƒåŒ–è·¯å¾„ï¼š`std::filesystem::canonical()` è§£æ `.` å’Œ `..`

> ğŸ’¡ **æŠ€æœ¯äº®ç‚¹**ï¼š`std::filesystem::canonical()` ä¼šè‡ªåŠ¨è§£æç›¸å¯¹è·¯å¾„ï¼Œä½¿æ“ä½œå˜å¾—éå¸¸ç®€å•ã€‚

---

## 4. é›†æˆåˆ° GameScene

ç°åœ¨ï¼Œæˆ‘ä»¬è®© `GameScene` åœ¨åˆå§‹åŒ–æ—¶è°ƒç”¨ `LevelLoader` æ¥æ„å»ºåœºæ™¯ï¼Œè€Œä¸æ˜¯æ‰‹åŠ¨åˆ›å»ºå¯¹è±¡ã€‚

### src/game/scene/game_scene.h

```cpp
class GameScene final: public engine::scene::Scene {
private:
    // ...
    void testCamera();
}
```

### src/game/scene/game_scene.cpp

```cpp
#include "game_scene.h"
#include "../../engine/scene/level_loader.h"
#include "../../engine/input/input_manager.h"
#include "../../engine/render/camera.h"
// ...

namespace game::scene {

// ... æ„é€ å‡½æ•° ...

void GameScene::init() {
    // åŠ è½½å…³å¡
    engine::scene::LevelLoader level_loader;
    level_loader.loadLevel("assets/maps/level1.tmj", *this);

    // ä¹‹å‰çš„æµ‹è¯•å¯¹è±¡å¯ä»¥ä¿ç•™æˆ–åˆ é™¤
    createTestObject();

    Scene::init();
}

void GameScene::handleInput() {
    Scene::handleInput();
    testCamera(); // ä¿ç•™ç›¸æœºç§»åŠ¨çš„æµ‹è¯•ä»£ç 
}

void GameScene::testCamera() {
    auto& camera = context_.getCamera();
    auto& input_manager = context_.getInputManager();
    if (input_manager.isActionDown("move_up")) camera.move(glm::vec2(0, -2));   
    if (input_manager.isActionDown("move_down")) camera.move(glm::vec2(0, 2));
    if (input_manager.isActionDown("move_left")) camera.move(glm::vec2(-2, 0));
    if (input_manager.isActionDown("move_right")) camera.move(glm::vec2(2, 0));
}

// ... å…¶ä»–å‡½æ•° ...
}
```

### âœ¨ æ”¹è¿›è¯´æ˜

æˆ‘ä»¬è¿˜å°†ç›¸æœºç§»åŠ¨çš„æµ‹è¯•ä»£ç ä» `GameApp` ç§»åˆ°äº† `GameScene` çš„ `handleInput` ä¸­ï¼Œå¹¶ç¨å¾®æé«˜äº†ç§»åŠ¨é€Ÿåº¦ï¼Œè¿™æ ·é€»è¾‘å°±æ›´åŠ  **å†…èš** äº†ã€‚

**å¥½å¤„ï¼š**
- âœ… ç›¸æœºæ§åˆ¶é€»è¾‘å±äºæ¸¸æˆåœºæ™¯ï¼Œè€Œéå¼•æ“æ ¸å¿ƒ
- âœ… ä¸åŒåœºæ™¯å¯ä»¥æœ‰ä¸åŒçš„ç›¸æœºæ§åˆ¶æ–¹å¼
- âœ… ä»£ç ç»„ç»‡æ›´æ¸…æ™°

---

## âœ… ç¼–è¯‘ä¸è¿è¡Œ

ç¼–è¯‘å¹¶è¿è¡Œæ¸¸æˆï¼Œä½ å°†çœ‹åˆ°ç”± Tiled è®¾è®¡çš„ **è§†å·®èƒŒæ™¯** å·²ç»æˆåŠŸåŠ è½½åˆ°æˆ‘ä»¬çš„æ¸¸æˆä¸­äº†ï¼

### ğŸ® æµ‹è¯•æ­¥éª¤

1. è¿è¡Œæ¸¸æˆ
2. ä½¿ç”¨æ–¹å‘é”®ï¼ˆæˆ– WASDï¼‰ç§»åŠ¨ç›¸æœº
3. è§‚å¯Ÿä¸åŒå›¾å±‚ä»¥ä¸åŒé€Ÿåº¦æ»šåŠ¨çš„æ•ˆæœ

### è¿è¡Œæ•ˆæœ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ğŸ”ï¸ è¿œå±±ï¼ˆæ…¢é€Ÿæ»šåŠ¨ï¼‰       â”‚
â”‚                             â”‚
â”‚     ğŸŒ² æ£®æ—ï¼ˆä¸­é€Ÿæ»šåŠ¨ï¼‰     â”‚
â”‚                             â”‚
â”‚       ğŸŒ¿ è‰åœ°ï¼ˆè·Ÿéšç›¸æœºï¼‰   â”‚
â”‚         ğŸ“¦ æµ‹è¯•ç®±å­         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç§»åŠ¨ç›¸æœº â†’ è§‚å¯Ÿè§†å·®æ•ˆæœ
```

---

## ğŸ¯ ç³»ç»Ÿæ¶æ„æ€»ç»“

### æ ¸å¿ƒæˆå°±

æˆ‘ä»¬æˆåŠŸåœ°ï¼š

1. âœ… **å¼•å…¥ Tiled ç¼–è¾‘å™¨**ï¼šå®ç°å¯è§†åŒ–å…³å¡è®¾è®¡
2. âœ… **å®ç° ParallaxComponent**ï¼šæ”¯æŒè§†å·®æ»šåŠ¨èƒŒæ™¯
3. âœ… **åˆ›å»º LevelLoader**ï¼šè‡ªåŠ¨è§£æ JSON å¹¶æ„å»ºåœºæ™¯
4. âœ… **è·¯å¾„è§£æç³»ç»Ÿ**ï¼šæ­£ç¡®å¤„ç†ç›¸å¯¹è·¯å¾„
5. âœ… **æ•°æ®é©±åŠ¨å¼€å‘**ï¼šå…³å¡å†…å®¹ä»ä»£ç ä¸­è§£è€¦

### æ¶æ„å¯¹æ¯”

| ç‰¹æ€§ | æ”¹é€ å‰ | æ”¹é€ å |
|------|--------|--------|
| **å…³å¡åˆ›å»º** | ä»£ç ç¡¬ç¼–ç  | ä»æ–‡ä»¶åŠ è½½ |
| **ä¿®æ”¹æµç¨‹** | ä¿®æ”¹ä»£ç  â†’ ç¼–è¯‘ â†’ è¿è¡Œ | ä¿®æ”¹åœ°å›¾ â†’ è¿è¡Œ |
| **è®¾è®¡å·¥å…·** | æ—  | Tiled å¯è§†åŒ–ç¼–è¾‘ |
| **å¯ç»´æŠ¤æ€§** | å›°éš¾ | ç®€å• |
| **è®¾è®¡å¸ˆå‹å¥½** | å¦ | æ˜¯ |

### å·¥ä½œæµç¨‹

```
Tiled ç¼–è¾‘å™¨
    â†“
è®¾è®¡å…³å¡ï¼ˆæ”¾ç½®èƒŒæ™¯ã€ç“¦ç‰‡ã€å¯¹è±¡ï¼‰
    â†“
å¯¼å‡ºä¸º JSON æ–‡ä»¶ (.tmj)
    â†“
LevelLoader è§£æ JSON
    â†“
æ ¹æ®å›¾å±‚ç±»å‹åˆ†å‘å¤„ç†
    â†“
â”œâ”€ imagelayer â†’ ParallaxComponent
â”œâ”€ tilelayer â†’ [ä¸‹èŠ‚è¯¾]
â””â”€ objectgroup â†’ [ä¸‹ä¸‹èŠ‚è¯¾]
    â†“
è‡ªåŠ¨æ„å»ºæ¸¸æˆä¸–ç•Œ
```

---

## ğŸ”„ æ•°æ®é©±åŠ¨çš„ä¼˜åŠ¿

### ä¼ ç»Ÿæ–¹å¼ vs æ•°æ®é©±åŠ¨

#### âŒ ä¼ ç»Ÿæ–¹å¼

```cpp
// åˆ›å»º100ä¸ªå¯¹è±¡
for (int i = 0; i < 100; i++) {
    auto obj = std::make_unique<GameObject>("obj_" + std::to_string(i));
    obj->addComponent<TransformComponent>(glm::vec2(i * 32, 100));
    obj->addComponent<SpriteComponent>("tile.png");
    scene.addGameObject(std::move(obj));
}
```

**é—®é¢˜ï¼š**
- ä½ç½®ã€ç±»å‹éƒ½ç¡¬ç¼–ç 
- ä¿®æ”¹éœ€è¦é‡æ–°ç¼–è¯‘
- æ— æ³•å¯è§†åŒ–é¢„è§ˆ

#### âœ… æ•°æ®é©±åŠ¨æ–¹å¼

```cpp
// ä¸€è¡Œä»£ç åŠ è½½æ•´ä¸ªå…³å¡
LevelLoader loader;
loader.loadLevel("level1.tmj", scene);
```

**ä¼˜åŠ¿ï¼š**
- å…³å¡æ•°æ®åœ¨å¤–éƒ¨æ–‡ä»¶
- ä½¿ç”¨ Tiled å¯è§†åŒ–ç¼–è¾‘
- ä¿®æ”¹åç«‹å³ç”Ÿæ•ˆ
- æ”¯æŒå¤æ‚å¸ƒå±€

---

æˆ‘ä»¬æˆåŠŸåœ°å°†å…³å¡çš„ä¸€éƒ¨åˆ†å†…å®¹ä»ä»£ç ä¸­è§£è€¦å‡ºæ¥ï¼Œå®ç°äº†ç”±æ•°æ®é©±åŠ¨çš„åœºæ™¯æ„å»ºã€‚åœ¨æ¥ä¸‹æ¥çš„è¯¾ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ç»§ç»­å®Œå–„LevelLoaderï¼Œä»¥æ”¯æŒæ›´å¤æ‚çš„ç“¦ç‰‡å›¾å±‚å’Œå¯¹è±¡å›¾å±‚ã€‚