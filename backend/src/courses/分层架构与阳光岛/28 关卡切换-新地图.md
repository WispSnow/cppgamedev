# 关卡切换 - 新地图

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1bwtfzPEDE&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1bwtfzPEDE)

## 📌 问题背景

欢迎来到《C++游戏开发之旅》第28课！到目前为止，我们的"阳光岛"只有一个精心设计的关卡。但一个完整的平台跳跃游戏，其魅力在于带领玩家穿越一系列风格各异、挑战递增的关卡。

### ⚠️ 当前的问题

```
单一关卡的限制：
┌─────────────────────────┐
│   🗺️ Level 1            │
│   👤 玩家开始            │
│   🏁 通关后...           │
│   ？ 然后呢？            │
│                          │
│ ❌ 只有一个关卡          │
│ ❌ 无法前进到下一关      │
│ ❌ 游戏内容有限          │
│ ❌ 缺少进度感            │
└─────────────────────────┘
```

| 问题 | 说明 | 影响 |
|------|------|------|
| **单关卡限制** | 游戏只有一个关卡 | 内容量不足 |
| **无法扩展** | 无法添加更多关卡 | 重玩性差 |
| **缺少进度感** | 玩家无法体验进步 | 游戏体验不完整 |
| **场景切换缺失** | 无法在关卡间切换 | 架构不完善 |

### 💡 解决方案：多关卡系统

**核心思想**：
1. 在 Tiled 中设置关卡触发器（传送门）
2. 扩展 LevelLoader 支持自定义形状
3. GameScene 支持加载不同地图
4. 实现场景切换逻辑

```
多关卡系统架构：
┌──────────────────┐
│   Level 1        │
│   👤 → 🚪        │ 触发器
└────────┬─────────┘
         │ 切换
         ↓
┌──────────────────┐
│   Level 2        │
│   🚪 ← 👤 → 🚪   │ 新关卡
└────────┬─────────┘
         │ 切换
         ↓
┌──────────────────┐
│   Level 3        │
│   🚪 ← 👤 → 🏁   │ 最终关
└──────────────────┘
```

### 🎯 本课目标

| 目标 | 说明 |
|------|------|
| **设置关卡触发器** | 在 Tiled 中创建传送门触发区域 |
| **扩展关卡加载器** | 支持加载自定义形状对象 |
| **实现场景切换逻辑** | 玩家触碰时切换场景 |
| **让 GameScene 可复用** | 支持加载不同地图文件 |

---

## 第一部分：Tiled 编辑器配置

首先，我们需要一个可视化的方式来定义关卡的出口。

---

## 1. 在Tiled中创建关卡出口

Tiled 的对象层不仅可以放置基于图块的对象，还可以绘制自定义形状，这正是我们创建触发区域的完美工具。

### 创建步骤

```
在 Tiled 中创建触发器：
    ↓
1. 打开地图文件
    assets/maps/level1.tmj
    ↓
2. 选择对象层
    Actors 层
    ↓
3. 使用矩形工具
    工具栏 → 插入矩形
    ↓
4. 绘制触发区域
    在关卡终点绘制矩形
    ↓
5. 设置属性
    • Name: "level2"
    • Tag: "next_level"
    ↓
完成！
```

### 属性配置

**打开 `assets/maps/level1.tmj`**，在对象层（Actors）中，找到关卡的终点位置。使用工具栏上的"插入矩形"工具，绘制一个矩形来覆盖关卡的出口区域。

**选中这个新创建的矩形**，我们需要在左侧的属性面板中为它设置两个关键信息：

| 属性 | 值 | 说明 |
|------|-----|------|
| **名称 (Name)** | `level2` | 下一关卡的文件名（不带扩展名） |
| **自定义属性 (tag)** | `"next_level"` | 触发器类型标识 |

### JSON 数据结构

设置完成后，`level1.tmj` 文件的JSON数据中会增加这样一段描述：

```json
// assets/maps/level1.tmj (部分)
{
 "height":100.33,
 "id":17,
 "name":"level2",
 "properties":[
        {
         "name":"tag",
         "type":"string",
         "value":"next_level"
        }],
 "rotation":0,
 "type":"",
 "visible":true,
 "width":21,
 "x":1434,
 "y":59
}
```

### 💡 设计思路

**我们将下一个关卡的名称直接存储在触发器对象的名字里**，这是一种非常直观且数据驱动的设计。

```
数据驱动的优势：
┌──────────────────────┐
│ 触发器属性：         │
│ • name = "level2"    │ ← 目标关卡
│ • tag = "next_level" │ ← 类型标识
├──────────────────────┤
│ 当触发切换时：       │
│ 代码读取 name        │
│ → 知道加载哪个关卡   │
├──────────────────────┤
│ 添加新关卡：         │
│ 1. 创建 level3.tmj   │
│ 2. 在 level2 放触发器│
│ 3. name = "level3"   │
│ → 自动连接！         │
└──────────────────────┘
```

### 可视化效果

```
关卡出口触发器：
┌─────────────────────┐
│ Level 1 关卡        │
│                     │
│  👤 ← 玩家          │
│  →  →  →  →  →     │
│              ┌───┐  │
│              │🚪 │  │ ← 触发区域
│              └───┘  │   (不可见矩形)
│           next_level│
└─────────────────────┘
```

---

## 第二部分：引擎层扩展

现在我们需要让引擎能够识别和加载这些自定义形状对象。

---

## 2. 让LevelLoader识别自定义形状

到目前为止，我们的 `LevelLoader` 只会处理带有 `gid`（图块ID）的对象。对于我们刚刚创建的、没有 `gid` 的自定义矩形，它会直接忽略。现在，我们需要扩展它的能力。

### 对象类型对比

```
Tiled 对象层中的两种对象：
┌──────────────────────┐
│ 1. 图块对象          │
│    gid > 0           │
│    基于图块集        │
│    🖼️ 有纹理图片     │
├──────────────────────┤
│ 2. 自定义形状        │
│    gid = 0           │
│    手动绘制          │
│    ⬜ 无纹理         │
│    用作触发器        │
└──────────────────────┘
```

| 类型 | gid | 用途 | 示例 |
|------|-----|------|------|
| **图块对象** | > 0 | 可见的游戏对象 | 玩家、敌人、道具 |
| **自定义形状** | = 0 | 不可见的触发器 | 传送门、检查点 |

### src/engine/scene/level_loader.cpp（更新）

在 `loadObjectLayer` 方法中，我们为 `gid == 0` 的情况添加处理逻辑：

```cpp
// src/engine/scene/level_loader.cpp (部分)
void LevelLoader::loadObjectLayer(const nlohmann::json& layer_json, Scene& scene) {
    // ...
    for (const auto& object : objects) {
        auto gid = object.value("gid", 0);
        if (gid == 0) {  // 如果gid为0，则代表自己绘制的形状
            // 默认是矩形对象
            // --- 创建游戏对象并添加TransfromComponent ---
            const std::string& object_name = object.value("name", "Unnamed");
            auto game_object = std::make_unique<engine::object::GameObject>(object_name);
            
            auto position = glm::vec2(object.value("x", 0.0f), object.value("y", 0.0f));
            auto dst_size = glm::vec2(object.value("width", 0.0f), object.value("height", 0.0f));
            game_object->addComponent<engine::component::TransformComponent>(position, glm::vec2(1.0f), 0.0f);

            // --- 添加碰撞组件和物理组件 ---
            auto collider = std::make_unique<engine::physics::AABBCollider>(dst_size);
            auto* cc = game_object->addComponent<engine::component::ColliderComponent>(std::move(collider));
            
            // 自定义形状通常是trigger类型
            cc->setTrigger(object.value("trigger", true));
            // 添加物理组件，不受重力影响
            game_object->addComponent<engine::component::PhysicsComponent>(&scene.getContext().getPhysicsEngine(), false);
            
            // 获取标签信息并设置
            if (auto tag = getTileProperty<std::string>(object, "tag"); tag) {
                game_object->setTag(tag.value());
            }
            // 添加到场景
            scene.addGameObject(std::move(game_object));
            spdlog::info("加载对象: '{}' 完成 (类型: 自定义形状)", object_name);
            
        } else { // 如果gid存在，则按照图片解析流程
            // ... 原有逻辑
        }
    }
}
```

### 代码解析

```
自定义形状加载流程：
    ↓
1. 检测 gid == 0
    确认是自定义形状
    ↓
2. 读取属性
    • name (对象名称)
    • x, y (位置)
    • width, height (尺寸)
    • tag (自定义标签)
    ↓
3. 创建 GameObject
    new GameObject(name)
    ↓
4. 添加 TransformComponent
    设置位置和尺寸
    ↓
5. 添加 ColliderComponent
    创建 AABBCollider
    setTrigger(true)  ← 关键！
    ↓
6. 添加 PhysicsComponent
    不受重力影响
    ↓
7. 设置标签
    setTag("next_level")
    ↓
8. 添加到场景
    scene.addGameObject()
```

### 💡 关键设计：Trigger 标志

```cpp
cc->setTrigger(object.value("trigger", true));
```

**这是触发器的核心设置**：

```
Trigger vs Solid：
┌──────────────────────┐
│ Solid (实体碰撞器)： │
│ • 阻挡移动           │
│ • 产生碰撞响应       │
│ • 例如：墙壁         │
├──────────────────────┤
│ Trigger (触发器)：   │
│ • 不阻挡移动 ✓       │
│ • 检测碰撞 ✓         │
│ • 触发事件 ✓         │
│ • 例如：传送门       │
└──────────────────────┘
```

| 属性 | Solid | Trigger |
|------|-------|---------|
| **检测碰撞** | ✅ | ✅ |
| **阻挡移动** | ✅ | ❌ |
| **触发事件** | ❌ | ✅ |

### 组件配置

| 组件 | 配置 | 说明 |
|------|------|------|
| **TransformComponent** | `position`, `size` | 定义位置和尺寸 |
| **ColliderComponent** | `AABBCollider`, `isTrigger=true` | 碰撞检测但不阻挡 |
| **PhysicsComponent** | `useGravity=false` | 固定位置不移动 |

**现在，我们的引擎已经能够将Tiled中绘制的触发区正确加载为游戏世界中一个带触发功能的、不可见的碰撞盒了**。

---

## 第三部分：GameScene 的复用

现在我们需要让 GameScene 能够加载不同的关卡地图。

---

## 3. GameScene 的复用与关卡加载

目前我们的 `GameScene` 是硬编码加载 `level1.tmj` 的。为了让它能加载任意关卡，我们需要做一些改造。

### 第一步：场景名称即关卡名称

首先，`GameScene` 的实例名称将代表它要加载的关卡。

#### src/engine/core/game_app.cpp（更新）

在 `GameApp::init()` 中，我们将第一个场景的名称从 `"GameScene"` 改为 `"level1"`：

```cpp
// src/engine/core/game_app.cpp (部分)
bool GameApp::init() {
    // ...
    // 创建第一个场景并压入栈
    auto scene = std::make_unique<game::scene::GameScene>("level1", *context_, *scene_manager_);
    scene_manager_->requestPushScene(std::move(scene));
    // ...
}
```

### 场景名称的妙用

```
场景名称 = 关卡名称：
┌──────────────────────┐
│ 创建场景：           │
│ new GameScene(       │
│   "level1", ...)     │
│    ↓                 │
│ scene_name_ = "level1"│
│    ↓                 │
│ 自动加载：           │
│ "assets/maps/        │
│  level1.tmj"         │
└──────────────────────┘
```

### 第二步：动态构建地图路径

接着，在 `GameScene` 内部，我们根据自己的场景名 `scene_name_` 来动态构建关卡文件的路径。

#### src/game/scene/game_scene.h（更新）

```cpp
// src/game/scene/game_scene.h
class GameScene final : public engine::scene::Scene {
    // ...
private:
    // ...
    /// @brief 根据关卡名称获取对应的地图文件路径
    std::string levelNameToPath(const std::string& level_name) const { 
        return "assets/maps/" + level_name + ".tmj"; 
    }
};
```

#### src/game/scene/game_scene.cpp（更新）

```cpp
// src/game/scene/game_scene.cpp
bool GameScene::initLevel() {
    engine::scene::LevelLoader level_loader;
    // 使用新的辅助函数根据场景名获取路径
    auto level_path = levelNameToPath(scene_name_);
    if (!level_loader.loadLevel(level_path, *this)){
        spdlog::error("关卡 '{}' 加载失败", level_path);
        return false;
    }
    // ...
    return true;
}
```

### 路径转换机制

```
路径转换流程：
    ↓
scene_name_ = "level1"
    ↓
levelNameToPath()
    ↓
"assets/maps/" + "level1" + ".tmj"
    ↓
"assets/maps/level1.tmj"
    ↓
LevelLoader 加载该文件
```

### 可复用性展示

```
一个 GameScene 类，多个关卡：
┌──────────────────────┐
│ new GameScene(       │
│   "level1", ...)     │
│ → 加载 level1.tmj    │
├──────────────────────┤
│ new GameScene(       │
│   "level2", ...)     │
│ → 加载 level2.tmj    │
├──────────────────────┤
│ new GameScene(       │
│   "boss", ...)       │
│ → 加载 boss.tmj      │
└──────────────────────┘

同一个类，不同的数据！
```

**通过这个简单的改造，GameScene 类变得更加通用和强大**。我们只需要用不同的名字（如 `"level1"`, `"level2"`）来实例化它，它就能自动加载对应的地图文件。

---

## 第四部分：场景切换实现

最后一步，是把所有环节串联起来。

---

## 4. 碰撞检测与场景切换

当玩家与我们设置的 `next_level` 触发器碰撞时，就执行切换场景的逻辑。

### 第一步：添加碰撞处理

我们在 `GameScene::handleObjectCollisions()` 中添加新的碰撞处理分支：

#### src/game/scene/game_scene.cpp（更新）

```cpp
// src/game/scene/game_scene.cpp (部分)
void GameScene::handleObjectCollisions() {
    const auto& collisions = context_.getPhysicsEngine().getCollisions();
    for (const auto& col : collisions) {
        auto* obj1 = col.obj1;
        auto* obj2 = col.obj2;

        // ... 已有的碰撞处理逻辑 ...

        // 处理玩家与关底触发器碰撞
        if (obj1->getName() == "player" && obj2->getTag() == "next_level") {
            toNextLevel(obj2);
        } else if (obj2->getName() == "player" && obj1->getTag() == "next_level") {
            toNextLevel(obj1);
        }
    }
}
```

### 碰撞判断逻辑

```
触发器碰撞判断：
┌──────────────────────┐
│ 条件1：              │
│ obj1 = "player"      │
│ obj2.tag = "next_level"│
│ → toNextLevel(obj2)  │
├──────────────────────┤
│ 条件2：              │
│ obj2 = "player"      │
│ obj1.tag = "next_level"│
│ → toNextLevel(obj1)  │
└──────────────────────┘

双向判断，确保不漏检！
```

### 第二步：实现切换逻辑

这里的核心是新增的 `toNextLevel` 函数。它负责执行场景切换的魔法。

#### src/game/scene/game_scene.h（更新）

```cpp
// src/game/scene/game_scene.h
class GameScene final : public engine::scene::Scene {
    // ...
private:
    void toNextLevel(engine::object::GameObject* trigger);
    // ...
};
```

#### src/game/scene/game_scene.cpp（实现）

```cpp
// src/game/scene/game_scene.cpp
void GameScene::toNextLevel(engine::object::GameObject *trigger) {
    // 从触发器对象的名字获取下一关的场景名
    auto scene_name = trigger->getName(); 
    
    // 创建一个新的 GameScene 实例
    auto next_scene = std::make_unique<game::scene::GameScene>(scene_name, context_, scene_manager_);
    
    // 请求场景管理器替换当前场景
    scene_manager_.requestReplaceScene(std::move(next_scene));
}
```

### 代码解析详解

```
toNextLevel 工作流程：
    ↓
1. 接收触发器对象
    trigger (GameObject*)
    ↓
2. 获取下一关名称
    scene_name = trigger->getName()
    例如："level2"
    ↓
3. 创建新场景
    new GameScene(scene_name, ...)
    ↓
4. 请求替换场景
    requestReplaceScene()
    ↓
5. SceneManager 执行切换
    • 销毁当前场景 (level1)
    • 初始化新场景 (level2)
    • 开始渲染新场景
```

### 💡 Replace vs Push

```cpp
scene_manager_.requestReplaceScene(std::move(next_scene));
```

**为什么使用 Replace 而不是 Push？**

```
Push vs Replace：
┌──────────────────────┐
│ Push（压栈）：       │
│ [Level1]             │
│ [Level1, Level2]     │ ← 可以返回
│                      │
│ 用途：暂停菜单、商店 │
├──────────────────────┤
│ Replace（替换）：    │
│ [Level1]             │
│ [Level2]             │ ← 不能返回
│                      │
│ 用途：关卡切换       │
└──────────────────────┘
```

| 方法 | 效果 | 返回上一场景 | 适用场景 |
|------|------|-------------|---------|
| **Push** | 压入新场景 | ✅ 可以 | 暂停菜单、UI |
| **Replace** | 替换当前场景 | ❌ 不可以 | 关卡切换、Game Over |

**我们使用 Replace**，因为玩家进入下一关后，我们不希望他能"返回"到上一关。

### 完整的切换流程

```
完整的关卡切换流程：
┌──────────────────────┐
│ 1. 玩家移动          │
│    👤 →              │
├──────────────────────┤
│ 2. 接触触发器        │
│    👤 触碰 🚪        │
├──────────────────────┤
│ 3. 碰撞检测          │
│    PhysicsEngine     │
│    检测到碰撞        │
├──────────────────────┤
│ 4. 碰撞处理          │
│    handleObjectColl..│
│    识别 next_level   │
├──────────────────────┤
│ 5. 触发切换          │
│    toNextLevel()     │
│    读取 trigger name │
├──────────────────────┤
│ 6. 创建新场景        │
│    new GameScene(    │
│      "level2", ...)  │
├──────────────────────┤
│ 7. 请求替换          │
│    requestReplace... │
├──────────────────────┤
│ 8. SceneManager      │
│    销毁 level1       │
│    初始化 level2     │
├──────────────────────┤
│ 9. 玩家进入新关卡    │
│    🗺️ Level 2       │
│    👤 新的起点       │
└──────────────────────┘
```

---

## ✅ 编译与运行

编译并运行游戏，你会看到完整的关卡切换系统：

```
运行效果：
┌─────────────────────────┐
│  Level 1：              │
│  👤 开始游戏             │
│  → → → → → 🚪          │
│  触碰传送门             │
├─────────────────────────┤
│  切换中...              │
│  销毁 Level 1           │
│  加载 Level 2           │
├─────────────────────────┤
│  Level 2：              │
│  👤 新关卡开始           │
│  新的挑战               │
└─────────────────────────┘
```

**你会看到：**
- ✅ 玩家走到关卡终点的触发器
- ✅ 触碰后场景自动切换
- ✅ Level 2 地图成功加载
- ✅ 玩家出现在新关卡的起点
- ✅ 背景音乐继续播放
- ✅ 所有系统正常工作

---

## 🎯 系统架构总结

### 完整的关卡切换系统

```
关卡切换系统架构：
┌──────────────────────────┐
│      Tiled Editor        │ ← 配置层
│   (创建触发器)            │   绘制传送门
└────────┬─────────────────┘
         │
         ↓
┌──────────────────────────┐
│     LevelLoader          │ ← 加载层
│   (识别并加载触发器)      │   gid=0 处理
└────────┬─────────────────┘
         │
         ↓
┌──────────────────────────┐
│    PhysicsEngine         │ ← 检测层
│   (检测触发器碰撞)        │   Trigger 碰撞
└────────┬─────────────────┘
         │
         ↓
┌──────────────────────────┐
│     GameScene            │ ← 逻辑层
│ • handleObjectCollisions │   碰撞处理
│ • toNextLevel            │   切换逻辑
└────────┬─────────────────┘
         │
         ↓
┌──────────────────────────┐
│    SceneManager          │ ← 管理层
│   (执行场景替换)          │   Replace 场景
└──────────────────────────┘
```

### 核心成就

我们成功地：

1. ✅ **设置了关卡触发器**：Tiled 中绘制传送门区域
2. ✅ **扩展了 LevelLoader**：支持 gid=0 的自定义形状
3. ✅ **实现了 Trigger 机制**：不阻挡但可检测碰撞
4. ✅ **让 GameScene 可复用**：通过名称加载不同地图
5. ✅ **实现了场景切换**：Replace 模式切换关卡
6. ✅ **建立了数据驱动流程**：配置即可添加新关卡

### 数据驱动的优势

```
添加新关卡的步骤：
┌──────────────────────┐
│ 1. 在 Tiled 中       │
│    创建 level3.tmj   │
├──────────────────────┤
│ 2. 在 level2.tmj 中  │
│    添加触发器：      │
│    • name = "level3" │
│    • tag = "next_level"│
├──────────────────────┤
│ 3. 保存文件          │
├──────────────────────┤
│ 4. 运行游戏          │
│    自动连接！        │
└──────────────────────┘

无需修改任何代码！
```

| 步骤 | 工具 | 时间 | 难度 |
|------|------|------|------|
| **传统方式** | 编码 | 30分钟+ | 高 |
| **数据驱动** | Tiled | 5分钟 | 低 |

### 关键技术点

| 技术点 | 实现方式 | 效果 |
|-------|---------|------|
| **触发器** | `setTrigger(true)` | 可碰撞但不阻挡 |
| **自定义形状** | `gid == 0` 处理 | 支持手绘区域 |
| **场景名称** | 构造函数参数 | 动态加载地图 |
| **场景切换** | `requestReplaceScene` | 无缝切换关卡 |
| **数据驱动** | 触发器名称存储目标 | 配置即可扩展 |

### 设计模式应用

```
策略模式 + 工厂模式：
┌──────────────────────┐
│ GameScene 工厂：     │
│ • 同一个类           │
│ • 不同的场景名       │
│ • 加载不同地图       │
├──────────────────────┤
│ new GameScene(       │
│   "level1", ...)     │
│ new GameScene(       │
│   "level2", ...)     │
│ new GameScene(       │
│   "boss", ...)       │
└──────────────────────┘

一个类，多种用途！
```

### 职责划分

```
清晰的职责分工：
┌──────────────────┐
│ Tiled            │ ← 配置设计者
│ "定义触发区域"    │   策划使用
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ LevelLoader      │ ← 数据解析者
│ "加载触发器"      │   自动处理
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ PhysicsEngine    │ ← 碰撞检测者
│ "检测触碰"        │   物理层
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ GameScene        │ ← 逻辑处理者
│ "执行切换"        │   游戏层
└────────┬─────────┘
         │
         ↓
┌──────────────────┐
│ SceneManager     │ ← 场景管理者
│ "管理场景栈"      │   架构层
└──────────────────┘
```

---

## 📚 总结

太棒了！我们已经成功地建立了一套完整、数据驱动的关卡切换机制。**现在，你只需要在Tiled中创建新的地图文件（例如 `level2.tmj`），然后在前一个关卡的终点放置一个名为新关卡名字的触发器，游戏就能自动地将它们连接起来了**。

**关键要点：**
- 🗺️ Tiled 触发器：自定义矩形作为传送门
- 📦 gid=0 处理：LevelLoader 支持自定义形状
- 🎯 Trigger 机制：可碰撞但不阻挡的触发器
- 🔄 GameScene 复用：场景名称即关卡名称
- 🚪 场景切换：Replace 模式替换关卡
- 📝 数据驱动：配置即可添加新关卡

> 💡 **设计哲学**：在本课中，我们学会了使用Tiled的自定义形状作为游戏中的触发器。扩展了 LevelLoader 以支持非图块对象的加载，增强了其通用性。将 GameScene 重构为一个可复用的关卡模板。利用 SceneManager 实现了流畅的场景替换，完成了关卡切换的核心功能。这种数据驱动的设计让游戏扩展变得极其简单，策划人员无需编程就能添加新关卡。

**数据驱动的威力**：

```
代码 vs 配置：
┌─────────────────────┐
│ 硬编码方式（❌）：   │
│ • 每个关卡一个类     │
│ • 修改需要重新编译   │
│ • 策划依赖程序员     │
└─────────────────────┘

┌─────────────────────┐
│ 数据驱动方式（✅）： │
│ • 一个类处理所有关卡 │
│ • 配置文件即可扩展   │
│ • 策划独立工作       │
└─────────────────────┘

效率提升10倍！
```

---

## 🚀 下一步展望

当然，目前的关卡切换还有一个小问题：**玩家的生命值、得分等信息在切换后会重置**。

- ❓ 如何在关卡间保持玩家数据？
- ❓ 如何共享游戏状态？
- ❓ 如何实现数据持久化？

下一课，我们将解决这个问题：

- 💾 **共享游戏数据**：场景间传递数据
- 🎮 **游戏状态管理**：统一管理玩家信息
- 📊 **数据持久化**：保存和加载进度
- 🔄 **完整的游戏流程**：从开始到结束

准备好迎接新的挑战吧，我们下节课见！🎮🌟