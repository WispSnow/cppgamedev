# å…³å¡è½½å…¥å™¨-ç“¦ç‰‡å±‚

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- Bç«™åµŒå…¥ï¼šä½¿ç”¨ https æ˜ç¡®åè®®ï¼ˆé¿å… file:// æˆ– http å¯¼è‡´è¢«æµè§ˆå™¨æ‹¦æˆªï¼‰ -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV18VGwzvETd&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[åœ¨ Bilibili ä¸Šè§‚çœ‹](https://www.bilibili.com/video/BV18VGwzvETd)

## ğŸ“– æ¦‚è¿°

ä¸Šä¸€è¯¾ï¼Œæˆ‘ä»¬æˆåŠŸåœ°å°†Tiledä¸­çš„èƒŒæ™¯å›¾ç‰‡å±‚æ¸²æŸ“åˆ°äº†å±å¹•ä¸Šï¼Œä¸ºæˆ‘ä»¬çš„å…³å¡é“ºè®¾äº†è¿œæ™¯ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬è¦å¼€å§‹æ„å»ºç©å®¶èƒ½å¤Ÿ**ç«™ç«‹ã€è¡Œèµ°å’Œè·³è·ƒ**çš„å®ä½“ä¸–ç•Œäº†ã€‚æœ¬èŠ‚è¯¾ï¼Œæˆ‘ä»¬å°†æ·±å…¥ `LevelLoader`ï¼Œå®ç°å¯¹**ç“¦ç‰‡å±‚ï¼ˆTile Layerï¼‰**çš„è§£æå’ŒåŠ è½½ã€‚

ç“¦ç‰‡å±‚æ˜¯Tiledåœ°å›¾çš„æ ¸å¿ƒï¼Œå®ƒæ˜¯ä¸€ä¸ªç”±ç½‘æ ¼å•å…ƒç»„æˆçš„äºŒç»´æ•°ç»„ï¼Œæ¯ä¸ªå•å…ƒæ ¼å¯ä»¥æ”¾ç½®ä¸€ä¸ªæ¥è‡ª**å›¾å—é›†ï¼ˆTilesetï¼‰**çš„ç“¦ç‰‡ã€‚è¿™æ¯”ç®€å•çš„å›¾ç‰‡å±‚è¦å¤æ‚å¾—å¤šã€‚

---

## ğŸ§± 1. Tiledç“¦ç‰‡ç³»ç»Ÿæ ¸å¿ƒæ¦‚å¿µ

åœ¨ç¼–å†™ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»ç†è§£Tiledæ˜¯å¦‚ä½•ç»„ç»‡ç“¦ç‰‡æ•°æ®çš„ã€‚

<img src="https://theorhythm.top/gamedev/SL/SL.051.webp" alt="ç“¦ç‰‡å±‚" style="display: block; margin: auto; width: 700px;" />

### ğŸ“š æ ¸å¿ƒæœ¯è¯­

- ğŸ¨ **å›¾å—é›† (Tileset)** - è¿™æ˜¯ä¸€ä¸ªåŒ…å«äº†å¤šä¸ªç“¦ç‰‡çš„èµ„æºé›†åˆã€‚å®ƒå¯ä»¥æ˜¯ä¸€å¼ åŒ…å«æ‰€æœ‰ç“¦ç‰‡çš„å¤§å›¾ï¼ˆSpritesheetï¼‰ï¼Œä¹Ÿå¯ä»¥æ˜¯å¤šä¸ªç‹¬ç«‹å›¾ç‰‡çš„é›†åˆã€‚Tiledä¼šå°†å›¾å—é›†çš„æ•°æ®ä¿å­˜åœ¨ä¸€ä¸ªå•ç‹¬çš„ `.tsj` æ–‡ä»¶ä¸­

- ğŸ”¢ **å…¨å±€ID (GID)** - Tiledä¼šç»™ä¸€ä¸ªåœ°å›¾ä¸­æ‰€æœ‰å›¾å—é›†é‡Œçš„æ¯ä¸€ä¸ªç“¦ç‰‡åˆ†é…ä¸€ä¸ªä»1å¼€å§‹çš„ã€ç‹¬ä¸€æ— äºŒçš„IDï¼Œè¿™å°±æ˜¯GIDã€‚**GIDä¸º0è¡¨ç¤ºç©ºç™½æ ¼**

- ğŸ·ï¸ **firstgid** - åœ¨åœ°å›¾æ–‡ä»¶ `.tmj` ä¸­ï¼Œæ¯ä¸ªå¼•ç”¨çš„å›¾å—é›†éƒ½æœ‰ä¸€ä¸ª `firstgid` å±æ€§ã€‚å®ƒè¡¨ç¤ºè¿™ä¸ªå›¾å—é›†çš„ç¬¬ä¸€ä¸ªç“¦ç‰‡åœ¨æ•´ä¸ªåœ°å›¾ä¸­çš„GIDæ˜¯å¤šå°‘

- ğŸ“ **å±€éƒ¨ID (LID)** - ä¸€ä¸ªç“¦ç‰‡åœ¨å®ƒè‡ªå·±æ‰€å±çš„å›¾å—é›†å†…éƒ¨çš„IDï¼Œä»0å¼€å§‹

- ğŸ”„ **æ¢ç®—å…³ç³»** - `LID = GID - firstgid`ã€‚é€šè¿‡è¿™ä¸ªå…¬å¼ï¼Œå½“æˆ‘ä»¬ä»åœ°å›¾æ•°æ®ä¸­è¯»åˆ°ä¸€ä¸ªGIDæ—¶ï¼Œå°±èƒ½åˆ¤æ–­å‡ºå®ƒå±äºå“ªä¸ªå›¾å—é›†ï¼Œå¹¶ä¸”çŸ¥é“å®ƒæ˜¯è¯¥å›¾å—é›†é‡Œçš„ç¬¬å‡ ä¸ªç“¦ç‰‡

### ğŸ¯ Tiledåœ°å›¾è§£ææ€è·¯

æ ¹æ®è¿™äº›æ¦‚å¿µï¼Œæˆ‘ä»¬çš„è§£ææ€è·¯ä¹Ÿå˜å¾—æ¸…æ™°äº†ï¼š

#### ğŸ“¥ æ­¥éª¤1: åŠ è½½å›¾å—é›†

- é¦–å…ˆéå†åœ°å›¾æ–‡ä»¶ä¸­çš„ `tilesets` æ•°ç»„
- æ ¹æ® `source` å­—æ®µæ‰¾åˆ°å¯¹åº”çš„ `.tsj` æ–‡ä»¶å¹¶è§£æ
- å°†å…¶æ•°æ®ä¸ `firstgid` ä¸€èµ·ç¼“å­˜èµ·æ¥

#### ğŸ—ºï¸ æ­¥éª¤2: åŠ è½½å›¾å±‚

- éå† `layers` æ•°ç»„
- å¦‚æœæ˜¯ `tilelayer`:
  1. éå†è¯¥å±‚çš„ `data` æ•°ç»„ï¼Œé‡Œé¢å­˜æ”¾äº†æ¯ä¸ªç½‘æ ¼å•å…ƒçš„GID
  2. å¯¹äºæ¯ä¸€ä¸ªGIDï¼Œä½¿ç”¨æˆ‘ä»¬ç¼“å­˜çš„å›¾å—é›†æ•°æ®æ¥æŸ¥æ‰¾å®ƒå¯¹åº”çš„å›¾ç‰‡ã€æºçŸ©å½¢å’Œè‡ªå®šä¹‰å±æ€§
  3. å°†è¿™äº›ä¿¡æ¯ç»„è£…æˆä¸€ä¸ª `TileInfo` å¯¹è±¡
  4. æ‰€æœ‰ `TileInfo` å¯¹è±¡è¢«å­˜å…¥ä¸€ä¸ª `std::vector` ä¸­
  5. æœ€åï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å«è¿™ä¸ªvectorçš„ `TileLayerComponent` æ¸¸æˆå¯¹è±¡

---

## ğŸ§© 2. TileLayerComponentï¼šç“¦ç‰‡ä¸–ç•Œçš„å®¹å™¨

æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„ç»„ä»¶æ¥æŒæœ‰å’Œæ¸²æŸ“æ•´ä¸ªç“¦ç‰‡å±‚ã€‚

### ğŸ”§ å¤´æ–‡ä»¶: `engine/component/tilelayer_component.h`
```cpp
#pragma once
#include "../render/sprite.h"
#include "component.h"
#include <vector>
#include <glm/vec2.hpp>

namespace engine::render {
class Sprite;
}

namespace engine::core {
class Context;
}

namespace engine::component {
/**
 * @brief å®šä¹‰ç“¦ç‰‡çš„ç±»å‹ï¼Œç”¨äºæ¸¸æˆé€»è¾‘ï¼ˆä¾‹å¦‚ç¢°æ’ï¼‰ã€‚
 */
enum class TileType {
    EMPTY,      ///< @brief ç©ºç™½ç“¦ç‰‡
    NORMAL,     ///< @brief æ™®é€šç“¦ç‰‡
    SOLID,      ///< @brief é™æ­¢å¯ç¢°æ’ç“¦ç‰‡
    // æœªæ¥è¡¥å……å…¶å®ƒç±»å‹
};

/**
 * @brief åŒ…å«å•ä¸ªç“¦ç‰‡çš„æ¸²æŸ“å’Œé€»è¾‘ä¿¡æ¯ã€‚
 */
struct TileInfo {
    render::Sprite sprite;      ///< @brief ç“¦ç‰‡çš„è§†è§‰è¡¨ç¤º
    TileType type;              ///< @brief ç“¦ç‰‡çš„é€»è¾‘ç±»å‹
    TileInfo(render::Sprite s = render::Sprite(), TileType t = TileType::EMPTY) : sprite(std::move(s)), type(t) {}
};

/**
 * @brief ç®¡ç†å’Œæ¸²æŸ“ç“¦ç‰‡åœ°å›¾å±‚ã€‚
 *
 * å­˜å‚¨ç“¦ç‰‡åœ°å›¾çš„å¸ƒå±€ã€æ¯ä¸ªç“¦ç‰‡çš„ç²¾çµä¿¡æ¯å’Œç±»å‹ã€‚
 * è´Ÿè´£åœ¨æ¸²æŸ“é˜¶æ®µç»˜åˆ¶å¯è§çš„ç“¦ç‰‡ã€‚
 */
class TileLayerComponent final : public Component {
    friend class engine::object::GameObject;
private:
    glm::ivec2 tile_size_;              ///< @brief å•ä¸ªç“¦ç‰‡å°ºå¯¸ï¼ˆåƒç´ ï¼‰
    glm::ivec2 map_size_;               ///< @brief åœ°å›¾å°ºå¯¸ï¼ˆç“¦ç‰‡æ•°ï¼‰
    std::vector<TileInfo> tiles_;       ///< @brief å­˜å‚¨æ‰€æœ‰ç“¦ç‰‡ä¿¡æ¯ (æŒ‰"è¡Œä¸»åº"å­˜å‚¨, index = y * map_width_ + x)
    glm::vec2 offset_ = {0.0f, 0.0f};   ///< @brief ç“¦ç‰‡å±‚åœ¨ä¸–ç•Œä¸­çš„åç§»é‡ (ç“¦ç‰‡å±‚é€šå¸¸ä¸éœ€è¦ç¼©æ”¾åŠæ—‹è½¬ï¼Œå› æ­¤ä¸å¼•å…¥Transformç»„ä»¶)
                                                 // offset_ æœ€å¥½ä¹Ÿä¿æŒé»˜è®¤çš„0ï¼Œä»¥å…å¢åŠ ä¸å¿…è¦çš„å¤æ‚æ€§
    bool is_hidden_ = false;            ///< @brief æ˜¯å¦éšè—ï¼ˆä¸æ¸²æŸ“ï¼‰

public:
    TileLayerComponent() = default;

    /**
     * @brief æ„é€ å‡½æ•°
     * @param tile_size å•ä¸ªç“¦ç‰‡å°ºå¯¸ï¼ˆåƒç´ ï¼‰
     * @param map_size åœ°å›¾å°ºå¯¸ï¼ˆç“¦ç‰‡æ•°ï¼‰
     * @param tiles åˆå§‹åŒ–ç“¦ç‰‡æ•°æ®çš„å®¹å™¨ (ä¼šè¢«ç§»åŠ¨)
     */
    TileLayerComponent(glm::ivec2 tile_size, glm::ivec2 map_size, std::vector<TileInfo>&& tiles);

    /**
     * @brief æ ¹æ®ç“¦ç‰‡åæ ‡è·å–ç“¦ç‰‡ä¿¡æ¯
     * @param pos ç“¦ç‰‡åæ ‡ (0 <= x < map_size_.x, 0 <= y < map_size_.y)
     * @return const TileInfo* æŒ‡å‘ç“¦ç‰‡ä¿¡æ¯çš„æŒ‡é’ˆï¼Œå¦‚æœåæ ‡æ— æ•ˆåˆ™è¿”å› nullptr
     */
    const TileInfo* getTileInfoAt(glm::ivec2 pos) const;

    /**
     * @brief æ ¹æ®ç“¦ç‰‡åæ ‡è·å–ç“¦ç‰‡ç±»å‹
     * @param pos ç“¦ç‰‡åæ ‡ (0 <= x < map_size_.x, 0 <= y < map_size_.y)
     * @return TileType ç“¦ç‰‡ç±»å‹ï¼Œå¦‚æœåæ ‡æ— æ•ˆåˆ™è¿”å› TileType::EMPTY
     */
    TileType getTileTypeAt(glm::ivec2 pos) const;

     /**
      * @brief æ ¹æ®ä¸–ç•Œåæ ‡è·å–ç“¦ç‰‡ç±»å‹
      * @param world_pos ä¸–ç•Œåæ ‡
      * @return TileType ç“¦ç‰‡ç±»å‹ï¼Œå¦‚æœåæ ‡æ— æ•ˆæˆ–å¯¹åº”ç©ºç“¦ç‰‡åˆ™è¿”å› TileType::EMPTY
      */
    TileType getTileTypeAtWorldPos(const glm::vec2& world_pos) const;

    // getters and setters
    glm::ivec2 getTileSize() const { return tile_size_; }               ///< @brief è·å–å•ä¸ªç“¦ç‰‡å°ºå¯¸
    glm::ivec2 getMapSize() const { return map_size_; }                 ///< @brief è·å–åœ°å›¾å°ºå¯¸
    glm::vec2 getWorldSize() const {                                    ///< @brief è·å–åœ°å›¾ä¸–ç•Œå°ºå¯¸
        return glm::vec2(map_size_.x * tile_size_.x, map_size_.y * tile_size_.y); 
    }
    const std::vector<TileInfo>& getTiles() const { return tiles_; }    ///< @brief è·å–ç“¦ç‰‡å®¹å™¨
    const glm::vec2& getOffset() const { return offset_; }              ///< @brief è·å–ç“¦ç‰‡å±‚çš„åç§»é‡
    bool isHidden() const { return is_hidden_; }                        ///< @brief è·å–æ˜¯å¦éšè—ï¼ˆä¸æ¸²æŸ“ï¼‰

    void setOffset(const glm::vec2& offset) { offset_ = offset; }       ///< @brief è®¾ç½®ç“¦ç‰‡å±‚çš„åç§»é‡
    void setHidden(bool hidden) { is_hidden_ = hidden; }                ///< @brief è®¾ç½®æ˜¯å¦éšè—ï¼ˆä¸æ¸²æŸ“ï¼‰


protected:
    // æ ¸å¿ƒå¾ªç¯æ–¹æ³•
    void init() override;
    void update(float, engine::core::Context&) override {}
    void render(engine::core::Context& context) override;
};

} // namespace engine::component
```

### ğŸ’¡ æ ¸å¿ƒè®¾è®¡è¯´æ˜

- ğŸ“¦ **`TileInfo`** - è¿™ä¸ªç»“æ„ä½“æ˜¯æ ¸å¿ƒï¼Œå®ƒåŒ…å«äº†å•ä¸ªç“¦ç‰‡çš„æ‰€æœ‰ä¿¡æ¯ï¼š
  - ç”¨äºæ¸²æŸ“çš„ `Sprite`
  - ç”¨äºæ¸¸æˆé€»è¾‘çš„ `TileType`

- ğŸ“Š **`tiles_`** - ä¸€ä¸ª `std::vector`ï¼ŒæŒ‰**è¡Œä¸»åº**å­˜å‚¨äº†åœ°å›¾ä¸Šæ‰€æœ‰ç“¦ç‰‡çš„ `TileInfo`

- ğŸ¨ **`render()`** - å®ƒçš„é€»è¾‘å°±æ˜¯éå† `tiles_`ï¼Œè®¡ç®—æ¯ä¸ªç“¦ç‰‡åœ¨ä¸–ç•Œä¸­çš„ä½ç½®ï¼Œç„¶åè°ƒç”¨ `Renderer::drawSprite` æ¥ç»˜åˆ¶å®ƒ

### âš™ï¸ å®ç°æ–‡ä»¶: `engine/component/tilelayer_component.cpp`
```cpp
#include "tilelayer_component.h"
#include "../object/game_object.h"
#include "../core/context.h"
#include "../render/renderer.h"
#include "../render/camera.h"
#include <spdlog/spdlog.h>

namespace engine::component {

TileLayerComponent::TileLayerComponent(glm::ivec2 tile_size, glm::ivec2 map_size, std::vector<TileInfo>&& tiles)
    : tile_size_(tile_size),
      map_size_(map_size),
      tiles_(std::move(tiles))
{
    if (tiles_.size() != static_cast<size_t>(map_size_.x * map_size_.y)) {
        spdlog::error("TileLayerComponent: åœ°å›¾å°ºå¯¸ä¸æä¾›çš„ç“¦ç‰‡å‘é‡å¤§å°ä¸åŒ¹é…ã€‚ç“¦ç‰‡æ•°æ®å°†è¢«æ¸…é™¤ã€‚");
        tiles_.clear();
        map_size_ = {0, 0};
    }
    spdlog::trace("TileLayerComponent æ„é€ å®Œæˆ");
}

void TileLayerComponent::init() {
    if (!owner_) {
        spdlog::warn("TileLayerComponent çš„ owner_ æœªè®¾ç½®ã€‚");
    }
    spdlog::trace("TileLayerComponent åˆå§‹åŒ–å®Œæˆ");
}

void TileLayerComponent::render(engine::core::Context& context) {
    if (tile_size_.x <= 0 || tile_size_.y <= 0) {
        return; // é˜²æ­¢é™¤ä»¥é›¶æˆ–æ— æ•ˆå°ºå¯¸
    }
    // éå†æ‰€æœ‰ç“¦ç‰‡
    for (int y = 0; y < map_size_.y; ++y) {
        for (int x = 0; x < map_size_.x; ++x) {
            size_t index = static_cast<size_t>(y) * map_size_.x + x;
            // æ£€æŸ¥ç´¢å¼•æœ‰æ•ˆæ€§ä»¥åŠç“¦ç‰‡æ˜¯å¦éœ€è¦æ¸²æŸ“
            if (index < tiles_.size() && tiles_[index].type != TileType::EMPTY) {
                const auto& tile_info = tiles_[index];
                // è®¡ç®—è¯¥ç“¦ç‰‡åœ¨ä¸–ç•Œä¸­çš„å·¦ä¸Šè§’ä½ç½® (drawSprite é¢„æœŸæ¥æ”¶å·¦ä¸Šè§’åæ ‡)
                glm::vec2 tile_left_top_pos = {
                    offset_.x + static_cast<float>(x) * tile_size_.x,
                    offset_.y + static_cast<float>(y) * tile_size_.y
                };
                // ä½†å¦‚æœå›¾ç‰‡çš„å¤§å°ä¸ç“¦ç‰‡çš„å¤§å°ä¸ä¸€è‡´ï¼Œéœ€è¦è°ƒæ•´ y åæ ‡ (ç“¦ç‰‡å±‚çš„å¯¹é½ç‚¹æ˜¯å·¦ä¸‹è§’)
                if(static_cast<int>(tile_info.sprite.getSourceRect()->h) != tile_size_.y) {
                    tile_left_top_pos.y -= (tile_info.sprite.getSourceRect()->h - static_cast<float>(tile_size_.y));
                }
                // æ‰§è¡Œç»˜åˆ¶
                context.getRenderer().drawSprite(context.getCamera(), tile_info.sprite, tile_left_top_pos);
            }
        }
    }
}

const TileInfo* TileLayerComponent::getTileInfoAt(glm::ivec2 pos) const {
    if (pos.x < 0 || pos.x >= map_size_.x || pos.y < 0 || pos.y >= map_size_.y) {
        spdlog::warn("TileLayerComponent: ç“¦ç‰‡åæ ‡è¶Šç•Œ: ({}, {})", pos.x, pos.y);
        return nullptr;
    }
    size_t index = static_cast<size_t>(pos.y * map_size_.x + pos.x);
    // ç“¦ç‰‡ç´¢å¼•ä¸èƒ½è¶Šç•Œ
    if (index < tiles_.size()) {
        return &tiles_[index];
    }
    spdlog::warn("TileLayerComponent: ç“¦ç‰‡ç´¢å¼•è¶Šç•Œ: {}", index);
    return nullptr;
}

TileType TileLayerComponent::getTileTypeAt(glm::ivec2 pos) const {
    const TileInfo* info = getTileInfoAt(pos);
    return info ? info->type : TileType::EMPTY;
}

TileType TileLayerComponent::getTileTypeAtWorldPos(const glm::vec2& world_pos) const {
    glm::vec2 relative_pos = world_pos - offset_;

    int tile_x = static_cast<int>(std::floor(relative_pos.x / tile_size_.x));
    int tile_y = static_cast<int>(std::floor(relative_pos.y / tile_size_.y));

    return getTileTypeAt(glm::ivec2{tile_x, tile_y});
}

} // namespace engine::component
```

---

## âš¡ 3. å‡çº§ LevelLoader

ç°åœ¨æ˜¯é‡å¤´æˆï¼Œæˆ‘ä»¬å°†ä¸º `LevelLoader` æ·»åŠ åŠ è½½å›¾å—é›†å’Œç“¦ç‰‡å±‚çš„èƒ½åŠ›ã€‚

### ğŸ”§ å¤´æ–‡ä»¶æ›´æ–°: `engine/scene/level_loader.h`
```cpp
#pragma once
#include <string>
#include <glm/vec2.hpp>
#include <nlohmann/json.hpp>
#include <map>

namespace engine::component { struct TileInfo; }
namespace engine::scene { class Scene; }

class LevelLoader final {
    std::string map_path_;
    glm::ivec2 map_size_;
    glm::ivec2 tile_size_;
    std::map<int, nlohmann::json> tileset_data_; // firstgid -> tileset json data

public:
    // ...
private:
    // ... loadImageLayer, loadObjectLayer ...
    void loadTileLayer(const nlohmann::json& layer_json, Scene& scene);
    
    // æ–°å¢
    engine::component::TileInfo getTileInfoByGid(int gid);
    void loadTileset(const std::string& tileset_path, int first_gid);
    
    std::string resolvePath(const std::string& relative_path, const std::string& file_path);
};
```

### ğŸ“‹ å…³é”®æ”¹åŠ¨è¯´æ˜

#### æ–°å¢æˆå‘˜å˜é‡

- ğŸ“ **`map_size_`, `tile_size_`** - å­˜å‚¨åœ°å›¾çš„å…¨å±€ä¿¡æ¯
- ğŸ’¾ **`std::map<int, nlohmann::json> tileset_data_`** - ç¼“å­˜æ‰€æœ‰å›¾å—é›†çš„æ•°æ®ï¼Œé”®ä¸º `firstgid`

#### æ–°å¢æ–¹æ³•

- ğŸ” **`getTileInfoByGid()`** - æ ¹æ®GIDè·å–ç“¦ç‰‡ä¿¡æ¯
- ğŸ“¥ **`loadTileset()`** - åŠ è½½å›¾å—é›†æ•°æ®
- ğŸ—ºï¸ **`loadTileLayer()`** - åŠ è½½ç“¦ç‰‡å±‚

### âš™ï¸ å®ç°æ–‡ä»¶æ›´æ–°: `engine/scene/level_loader.cpp`
```cpp
#include "level_loader.h"
#include "../component/tilelayer_component.h"
// ...
namespace engine::scene {

bool LevelLoader::loadLevel(const std::string& level_path, Scene& scene) {
    // ... åŠ è½½å’Œè§£æ JSON æ–‡ä»¶ ...

    map_path_ = level_path;
    map_size_ = glm::ivec2(json_data.value("width", 0), json_data.value("height", 0));
    tile_size_ = glm::ivec2(json_data.value("tilewidth", 0), json_data.value("tileheight", 0));

    // **æ­¥éª¤1: åŠ è½½æ‰€æœ‰å›¾å—é›†**
    if (json_data.contains("tilesets") && json_data["tilesets"].is_array()) {
        for (const auto& tileset_json : json_data["tilesets"]) {
            auto tileset_path = resolvePath(tileset_json["source"], map_path_);
            auto first_gid = tileset_json["firstgid"];
            loadTileset(tileset_path, first_gid);
        }
    }

    // **æ­¥éª¤2: åŠ è½½å›¾å±‚**
    // ... éå†å›¾å±‚ ...
        if (layer_type == "tilelayer") {
            loadTileLayer(layer_json, scene);
        }
    // ...
    return true;
}

void LevelLoader::loadTileset(const std::string& tileset_path, int first_gid) {
    std::ifstream tileset_file(tileset_path);
    if (!tileset_file.is_open()) { /* ... error ... */ return; }
    
    nlohmann::json ts_json;
    tileset_file >> ts_json;
    
    ts_json["file_path"] = tileset_path; // æ³¨å…¥æ–‡ä»¶è·¯å¾„ï¼Œæ–¹ä¾¿ä¹‹åè§£æç›¸å¯¹è·¯å¾„
    tileset_data_[first_gid] = std::move(ts_json);
}

void LevelLoader::loadTileLayer(const nlohmann::json& layer_json, Scene& scene) {
    // ...
    std::vector<engine::component::TileInfo> tiles;
    tiles.reserve(map_size_.x * map_size_.y);

    const auto& data = layer_json["data"];

    // **æ­¥éª¤3: æ ¹æ® GID å¡«å……ç“¦ç‰‡ä¿¡æ¯**
    for (const auto& gid : data) {
        tiles.push_back(getTileInfoByGid(gid));
    }

    // **æ­¥éª¤4: åˆ›å»º GameObject å’Œ Component**
    auto game_object = std::make_unique<engine::object::GameObject>(layer_json.value("name", "Unnamed"));
    game_object->addComponent<engine::component::TileLayerComponent>(tile_size_, map_size_, std::move(tiles));
    scene.addGameObject(std::move(game_object));
}

engine::component::TileInfo LevelLoader::getTileInfoByGid(int gid) {
    if (gid == 0) return {}; // ç©ºç“¦ç‰‡

    // æ‰¾åˆ° GID æ‰€å±çš„å›¾å—é›†
    auto tileset_it = tileset_data_.upper_bound(gid);
    if (tileset_it == tileset_data_.begin()) return {};
    --tileset_it;

    const auto& tileset = tileset_it->second;
    auto local_id = gid - tileset_it->first;
    const std::string file_path = tileset.value("file_path", "");

    if (tileset.contains("image")) { // Case 1: å•å¼ å¤§å›¾çš„å›¾å—é›†
        auto texture_id = resolvePath(tileset["image"], file_path);
        auto columns = tileset.value("columns", 1);
        auto coord_x = local_id % columns;
        auto coord_y = local_id / columns;
        SDL_FRect texture_rect = {
            static_cast<float>(coord_x * tile_size_.x),
            static_cast<float>(coord_y * tile_size_.y),
            static_cast<float>(tile_size_.x),
            static_cast<float>(tile_size_.y)
        };
        return { {texture_id, texture_rect}, engine::component::TileType::NORMAL };
    } else { // Case 2: ç‹¬ç«‹å›¾ç‰‡çš„å›¾å—é›†
        const auto& tiles_json = tileset["tiles"];
        for (const auto& tile_json : tiles_json) {
            if (tile_json.value("id", -1) == local_id) {
                auto texture_id = resolvePath(tile_json["image"], file_path);
                // å¤šå›¾ç‰‡é›†åˆæ²¡æœ‰ç»Ÿä¸€çš„æºçŸ©å½¢ï¼Œé»˜è®¤ä½¿ç”¨æ•´å¼ å›¾ç‰‡
                return { {texture_id}, engine::component::TileType::NORMAL };
            }
        }
    }
    return {}; // æœªæ‰¾åˆ°
}
}
```

---

## ğŸ¨ 4. ä¸€ä¸ªå…³é”®çš„æ¸²æŸ“ç»†èŠ‚

åƒç´ ç”»æ¸¸æˆåœ¨æ¸²æŸ“ç“¦ç‰‡æ—¶ï¼Œéå¸¸å®¹æ˜“åœ¨ç“¦ç‰‡ä¹‹é—´å‡ºç°ç»†å¾®çš„ç¼éš™ã€‚è¿™æ˜¯å› ä¸ºGPUé»˜è®¤ä¼šä½¿ç”¨çº¿æ€§æ’å€¼ï¼ˆ`SDL_SCALEMODE_LINEAR`ï¼‰æ¥ç¼©æ”¾çº¹ç†ï¼Œå¯¼è‡´ç“¦ç‰‡è¾¹ç¼˜çš„åƒç´ ä¸é‚»è¿‘çš„é€æ˜åƒç´ "æ··åˆ"ï¼Œä»è€Œäº§ç”ŸåŠé€æ˜çš„è¾¹ç¼˜ã€‚

### ğŸ’¡ è§£å†³æ–¹æ¡ˆï¼šæœ€è¿‘é‚»æ’å€¼

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¿…é¡»å‘Šè¯‰SDLä½¿ç”¨**æœ€è¿‘é‚»æ’å€¼**ï¼ˆ`SDL_SCALEMODE_NEAREST`ï¼‰ï¼Œè¿™ç§æ¨¡å¼ä¼šé€‰æ‹©æœ€æ¥è¿‘çš„åƒç´ é¢œè‰²ï¼Œä¿æŒåƒç´ ç”»çš„é”åˆ©è¾¹ç¼˜ã€‚

### ğŸ”§ æ›´æ–°: `engine/resource/texture_manager.cpp`
```cpp
// ... in TextureManager::loadTexture ...
SDL_Texture* raw_texture = IMG_LoadTexture(renderer_, file_path.c_str());

// **æ–°å¢: è®¾ç½®çº¹ç†ç¼©æ”¾æ¨¡å¼**
if (raw_texture) {
    if (!SDL_SetTextureScaleMode(raw_texture, SDL_SCALEMODE_NEAREST)) {
        spdlog::warn("æ— æ³•è®¾ç½®çº¹ç†ç¼©æ”¾æ¨¡å¼ä¸ºæœ€é‚»è¿‘æ’å€¼");
    }
}
// ...
```

---

## ğŸ‰ 5. æœ€ç»ˆæ•ˆæœ

`GameScene` çš„ä»£ç å‡ ä¹ä¸éœ€è¦æ”¹å˜ï¼Œ`level_loader.loadLevel` ç°åœ¨ä¼šè‡ªåŠ¨å¤„ç†æ–°å¢çš„ç“¦ç‰‡å±‚é€»è¾‘ã€‚

### ğŸš€ è¿è¡Œç»“æœ

ç¼–è¯‘å¹¶è¿è¡Œæ¸¸æˆã€‚ä½ å°†çœ‹åˆ°ï¼Œé™¤äº†ä¹‹å‰çš„è§†å·®èƒŒæ™¯ï¼Œç”±ç“¦ç‰‡æ„æˆçš„å…³å¡åœ°é¢å’Œå¹³å°ä¹Ÿå·²ç»è¢«æˆåŠŸæ¸²æŸ“å‡ºæ¥äº†ï¼ä½ å¯ä»¥ç§»åŠ¨ç›¸æœºæ¥è§‚å¯Ÿæ•´ä¸ªå…³å¡çš„ç»“æ„ã€‚

### âœ… æœ¬èŠ‚æˆæœ

è™½ç„¶ç°åœ¨è¿™äº›ç“¦ç‰‡è¿˜åªæ˜¯"è´´å›¾"ï¼Œè§’è‰²å¹¶ä¸èƒ½ä¸å®ƒä»¬å‘ç”Ÿäº¤äº’ï¼Œä½†æˆ‘ä»¬å·²ç»æˆåŠŸåœ°å°†å¤æ‚çš„å…³å¡æ•°æ®ç»“æ„åŒ–åœ°åŠ è½½åˆ°äº†å¼•æ“ä¸­ã€‚åœ¨åç»­çš„è¯¾ç¨‹é‡Œï¼Œæˆ‘ä»¬å°†åŸºäº `TileType` ä¸ºè¿™äº›ç“¦ç‰‡æ·»åŠ ç‰©ç†å±æ€§ï¼Œè®©å®ƒä»¬æˆä¸ºçœŸæ­£çš„"å®ä½“"ã€‚

---

## ğŸ“‹ æ€»ç»“

æœ¬èŠ‚è¯¾æˆ‘ä»¬å®Œæˆäº†ï¼š

- âœ… ç†è§£äº†Tiledç“¦ç‰‡ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µï¼ˆGIDã€Tilesetã€LIDç­‰ï¼‰
- âœ… å®ç°äº† `TileLayerComponent` ç»„ä»¶æ¥å­˜å‚¨å’Œæ¸²æŸ“ç“¦ç‰‡å±‚
- âœ… å‡çº§äº† `LevelLoader` ä»¥æ”¯æŒå›¾å—é›†å’Œç“¦ç‰‡å±‚çš„åŠ è½½
- âœ… è§£å†³äº†åƒç´ ç”»ç“¦ç‰‡æ¸²æŸ“çš„ç¼éš™é—®é¢˜
- âœ… æˆåŠŸå°†Tiledåœ°å›¾ä¸­çš„ç“¦ç‰‡å±‚æ¸²æŸ“åˆ°æ¸¸æˆä¸­

ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†ä¸ºè¿™äº›ç“¦ç‰‡æ·»åŠ ç‰©ç†å±æ€§ï¼Œè®©å®ƒä»¬èƒ½å¤Ÿä¸ç©å®¶äº§ç”ŸçœŸå®çš„ç¢°æ’äº¤äº’ï¼