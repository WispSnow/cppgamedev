# 瓦片层单向平台与斜坡

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1xfbZzFEG8&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1xfbZzFEG8)

## 📌 问题背景

我们的物理世界已经有了坚实的地面和障碍物，但一个优秀的平台游戏需要更丰富的地形来增加趣味性和挑战性。本节课，我们将为引擎引入两个经典的地形特性：**单向平台（One-Way Platforms）** 和 **斜坡（Slopes）**。

同时，为了提升游戏体验，我们还会实现一个 **平滑跟随玩家的相机**，并设置 **世界边界** 来防止玩家掉出地图。

### ⚠️ 当前的问题

```
缺少丰富地形：
┌─────────────────────────┐
│   👤                     │
│  ━━━━━━ 只有平地        │
│ ▓▓▓▓▓▓▓                 │
│                          │
│ ❌ 无法跳上平台          │
│ ❌ 无法在斜坡上行走      │
│ ❌ 相机移动不流畅        │
└─────────────────────────┘
```

### 🎯 本课目标

| 目标 | 说明 |
|------|------|
| **单向平台** | 可以从下方跳上，不能从上方穿下 |
| **斜坡系统** | 支持多种角度的斜坡，平滑移动 |
| **平滑相机** | 自动跟随玩家，线性插值平滑移动 |
| **世界边界** | 防止玩家掉出地图 |

<img src="https://theorhythm.top/gamedev/SL/SL.063.webp" alt="单向平台与斜坡" style="display: block; margin: auto; width: 700px;" />

---

## 1. 单向平台（Uni-directional Solid）

单向平台，也常被称为 **"跳台"**，是一种玩家可以从下方跳上来，但不能从上方穿下去的平台。这是平台游戏中的经典设计，极大地丰富了关卡的立体感。

### 💡 核心思想

```
单向平台机制：
┌─────────────────────┐
│   👤 ↑ 从下方跳上    │
│   ↑                  │
│  ━━━━━ 平台         │  ← 可以站立
│                      │
│  ━━━━━ 平台         │
│   👤 ↓ 从上方落下    │  ← 可以穿过
│   ↓                  │
└─────────────────────┘

关键：只在向下移动时才产生碰撞
```

### Tiled 设置

我们在图块集（`.tsj`）中，为用作单向平台的瓦片添加一个新的自定义属性：

| 属性 | 值 |
|------|---|
| **名称** | `unisolid` |
| **类型** | `bool` |
| **值** | `true` |

### 操作步骤

| 步骤 | 操作 |
|------|------|
| **1. 打开图块集** | 在 Tiled 中打开你的图块集文件 |
| **2. 选择平台瓦片** | 选择要用作单向平台的瓦片 |
| **3. 添加属性** | 在属性面板添加 `unisolid` 属性 |
| **4. 设置为 true** | 勾选该属性 |
| **5. 保存** | 保存图块集文件 |

---

## 2. 单向平台实现

### 扩展 TileType

我们在 `tilelayer_component.h` 中添加新的类型来识别这种平台。

#### engine/component/tilelayer_component.h（更新）

```cpp
enum class TileType {
    EMPTY,
    NORMAL,
    SOLID,
    UNISOLID, // 新增
    // ... a lot of slope types
};
```

### 瓦片类型对比

| 类型 | 向下移动 | 向上移动 | 水平移动 |
|------|---------|---------|---------|
| **SOLID** | 🚫 阻挡 | 🚫 阻挡 | 🚫 阻挡 |
| **UNISOLID** | 🚫 阻挡 | ✅ 穿过 | ✅ 穿过 |
| **NORMAL** | ✅ 穿过 | ✅ 穿过 | ✅ 穿过 |

---

### 更新 LevelLoader

让 `LevelLoader` 能够识别 `unisolid` 属性。

#### engine/scene/level_loader.cpp（更新）

```cpp
engine::component::TileType LevelLoader::getTileType(const nlohmann::json &tile_json)
{
    if (tile_json.contains("properties")) {
        for (const auto& property : tile_json["properties"]) {
            if (property.value("name", "") == "solid") {
                return property.value("value", false) ? TileType::SOLID : TileType::NORMAL;
            }
            // 新增：检查 unisolid 属性
            else if (property.value("name", "") == "unisolid") {
                return property.value("value", false) ? TileType::UNISOLID : TileType::NORMAL;
            }
            // ... (斜坡逻辑)
        }
    }
    return TileType::NORMAL;
}
```

### 属性解析流程

```
属性解析优先级：
    ↓
检查 properties 数组
    ↓
1. 检查 "solid" → 返回 SOLID
    ↓
2. 检查 "unisolid" → 返回 UNISOLID
    ↓
3. 检查 "slope" → 返回 SLOPE_*
    ↓
4. 默认 → 返回 NORMAL
```

---

### 修改 PhysicsEngine

这是 **关键一步**。在 `resolveTileCollisions` 中，我们只在物体 **向下移动** 时才将 `UNISOLID` 瓦片视为障碍物。

#### engine/physics/physics_engine.cpp（更新）

```cpp
void PhysicsEngine::resolveTileCollisions(engine::component::PhysicsComponent* pc, float delta_time) {
    // ... (前期准备代码)

    // Y轴碰撞解析
    if (ds.y > 0) { // 向下移动
        // ... (获取左下和右下角的瓦片类型 tile_type_left, tile_type_right)

        // 如果下方是 SOLID 或 UNISOLID，则视为地面
        if (tile_type_left == TileType::SOLID || tile_type_right == TileType::SOLID ||
            tile_type_left == TileType::UNISOLID || tile_type_right == TileType::UNISOLID) 
        {
            new_obj_pos.y = tile_y * tile_size.y - obj_size.y;
            pc->velocity_.y = 0.0f;
        }
        // ...
    } else if (ds.y < 0) { // 向上移动
        // ... (获取左上和右上角的瓦片类型)

        // 向上移动时，UNISOLID 不应产生碰撞
        if (tile_type_left == TileType::SOLID || tile_type_right == TileType::SOLID) {
            new_obj_pos.y = (tile_y + 1) * tile_size.y;
            pc->velocity_.y = 0.0f;
        }
    }
    // ... (X轴解析)
}
```

### 碰撞检测逻辑

| 移动方向 | SOLID | UNISOLID | 说明 |
|---------|-------|----------|------|
| **向下 ↓** | 产生碰撞 | 产生碰撞 | 可以站立在上面 |
| **向上 ↑** | 产生碰撞 | **不碰撞** | 可以从下方穿过 |
| **水平 ←→** | 产生碰撞 | **不碰撞** | 不阻挡横向移动 |

### 可视化效果

```
单向平台工作原理：
    
情况1: 向上跳跃
   ↑ 
  👤      → velocity.y < 0
  ━━━━━  → 不检测 UNISOLID
           → 穿过！

情况2: 向下落地
  ━━━━━  → 检测 UNISOLID
  👤      → velocity.y > 0
   ↓      → 落地停止！
```

---

## 3. 斜坡（Slopes）

处理斜坡是平台游戏物理引擎中的一个 **经典难题**。我们的目标是让角色能够在斜坡上平滑地上下行走，而不是被卡住或抖动。

### 💡 设计思想

斜坡的核心在于：地面高度不再是固定的，而是根据 **水平位置** 线性变化的。

```
斜坡高度计算：
┌────────────┐
│     /      │ ← SLOPE_0_1 (左低右高)
│    /       │   height = rel_x * tile_height
│   /        │
│  /         │   rel_x: 在瓦片内的相对位置 (0.0 ~ 1.0)
│ /          │
└────────────┘
```

### Tiled 设置

我们为斜坡瓦片定义一个 `slope`（字符串类型）的自定义属性。属性的值描述了斜坡的形状，格式为 **"左侧高度_右侧高度"**，高度单位是瓦片高度的倍数（0, 1, 2 分别代表 0, 0.5, 1.0）。

### 斜坡类型定义

| 属性值 | 描述 | 可视化 |
|--------|------|--------|
| `"0_1"` | 从左到右上升的完整斜坡 | `/` |
| `"1_0"` | 从左到右下降的完整斜坡 | `\` |
| `"0_2"` | 从左到右上升的半高斜坡（底部） | `_/` |
| `"2_1"` | 从左到右上升的半高斜坡（顶部） | `¯/` |
| `"1_2"` | 从左到右下降的半高斜坡（顶部） | `¯\` |
| `"2_0"` | 从左到右下降的半高斜坡（底部） | `\_` |

### 斜坡类型可视化

```
完整斜坡：
┌────┐  ┌────┐
│   /│  │\   │
│  / │  │ \  │
│ /  │  │  \ │
│/   │  │   \│
└────┘  └────┘
 0_1     1_0

半高斜坡（底部）：
┌────┐  ┌────┐
│    │  │    │
│   /│  │\   │
│  / │  │ \  │
│_/  │  │  \_│
└────┘  └────┘
 0_2     2_0

半高斜坡（顶部）：
┌────┐  ┌────┐
│¯¯/│  │\¯¯ │
│ / │  │ \  │
│/  │  │  \ │
│   │  │   │
└────┘  └────┘
 2_1     1_2
```

---

## 4. 斜坡实现

### 扩展 TileType

为所有斜坡类型添加枚举值。

#### engine/component/tilelayer_component.h（更新）

```cpp
enum class TileType {
    // ...
    UNISOLID,
    SLOPE_0_1, SLOPE_1_0, // 新增
    SLOPE_0_2, SLOPE_2_1, // 新增
    SLOPE_1_2, SLOPE_2_0, // 新增
};
```

### 枚举值对应关系

| 枚举值 | Tiled 属性值 | 说明 |
|--------|-------------|------|
| `SLOPE_0_1` | `"0_1"` | 完整上升斜坡 |
| `SLOPE_1_0` | `"1_0"` | 完整下降斜坡 |
| `SLOPE_0_2` | `"0_2"` | 半高上升斜坡（底） |
| `SLOPE_2_1` | `"2_1"` | 半高上升斜坡（顶） |
| `SLOPE_1_2` | `"1_2"` | 半高下降斜坡（顶） |
| `SLOPE_2_0` | `"2_0"` | 半高下降斜坡（底） |

---

### 更新 LevelLoader

解析 `slope` 字符串并映射到对应的 `TileType`。

#### engine/scene/level_loader.cpp（更新）

```cpp
engine::component::TileType LevelLoader::getTileType(const nlohmann::json &tile_json)
{
    // ...
    else if (property.value("name", "") == "slope") {
        auto slope_type = property.value("value", "");
        if (slope_type == "0_1") return TileType::SLOPE_0_1;
        if (slope_type == "1_0") return TileType::SLOPE_1_0;
        // ... (其他斜坡类型)
    }
    // ...
}
```

---

## 5. 核心斜坡算法

我们将创建一个辅助函数 `getTileHeightAtWidth`，用于计算在斜坡瓦片内部的 **任意水平位置** 上，地面的精确高度。

### engine/physics/physics_engine.h（更新）

```cpp
class PhysicsEngine {
    // ...
private:
    // 新增辅助函数
    float getTileHeightAtWidth(float width, engine::component::TileType type, glm::vec2 tile_size);
};
```

### engine/physics/physics_engine.cpp（实现）

```cpp
float PhysicsEngine::getTileHeightAtWidth(float width, engine::component::TileType type, glm::vec2 tile_size)
{
    // width 是物体角点在瓦片内的相对x坐标
    auto rel_x = glm::clamp(width / tile_size.x, 0.0f, 1.0f);
    switch (type) {
        case TileType::SLOPE_0_1: return rel_x * tile_size.y; // 线性插值
        case TileType::SLOPE_1_0: return (1.0f - rel_x) * tile_size.y;
        case TileType::SLOPE_0_2: return rel_x * tile_size.y * 0.5f;
        case TileType::SLOPE_2_1: return rel_x * tile_size.y * 0.5f + tile_size.y * 0.5f;
        // ... (其他斜坡类型)
        default: return 0.0f; // 非斜坡瓦片高度为0
    }
}
```

### 算法详解

| 参数 | 含义 | 范围 |
|------|------|------|
| `width` | 物体角点在瓦片内的 X 坐标偏移 | `0 ~ tile_size.x` |
| `rel_x` | 归一化的相对位置 | `0.0 ~ 1.0` |
| `返回值` | 该位置的地面高度 | `0 ~ tile_size.y` |

### 高度计算公式

| 斜坡类型 | 公式 | 说明 |
|---------|------|------|
| `SLOPE_0_1` | `rel_x * h` | 从 0 线性增长到 h |
| `SLOPE_1_0` | `(1 - rel_x) * h` | 从 h 线性下降到 0 |
| `SLOPE_0_2` | `rel_x * h * 0.5` | 从 0 增长到 0.5h |
| `SLOPE_2_1` | `rel_x * h * 0.5 + 0.5h` | 从 0.5h 增长到 h |

### 可视化说明

```
SLOPE_0_1 示例：
┌────────────┐  tile_size.y = 32
│        ★/  │  
│       / │  │  物体在 rel_x = 0.75 位置
│      /  │  │  height = 0.75 * 32 = 24
│     /   ↓  │
│    /   24  │
│   /        │
│  /         │
│ /          │
│/           │
└────────────┘
   ↑
   0.75 * tile_size.x
```

---

## 6. 斜坡碰撞解析

然后，我们在 `resolveTileCollisions` 中，当向下移动且未碰到 `SOLID` 或 `UNISOLID` 瓦片时，检查脚下是否为斜坡。

### engine/physics/physics_engine.cpp（更新）

```cpp
void PhysicsEngine::resolveTileCollisions(...) {
    // ...
    if (ds.y > 0) { // 向下移动
        // ... (检查 SOLID 和 UNISOLID)
        if (is_ground) {
            // ...
        } else {
            // 未踩到实体地面，检查脚下是否有斜坡
            auto width_left = obj_pos.x - tile_x_left * tile_size.x;
            auto width_right = obj_pos.x + obj_size.x - tile_x_right * tile_size.x;
            auto height_left = getTileHeightAtWidth(width_left, tile_type_left, tile_size);
            auto height_right = getTileHeightAtWidth(width_right, tile_type_right, tile_size);

            // 取两个脚下点的较高者作为地面高度
            auto height = glm::max(height_left, height_right);
            if (height > 0.0f) {
                // 计算斜坡地面的世界Y坐标
                float ground_y = (tile_y + 1) * tile_size.y - height;
                // 如果物体底部穿过了斜坡，则将其放回斜坡表面
                if (new_obj_pos.y + obj_size.y > ground_y) {
                     new_obj_pos.y = ground_y - obj_size.y;
                     pc->velocity_.y = 0.0f;
                }
            }
        }
    }
    // ...
}
```

### 斜坡检测流程

```
斜坡碰撞检测流程：
    ↓
1. 向下移动
    ↓
2. 检查 SOLID/UNISOLID → 未碰到
    ↓
3. 获取左下、右下角的瓦片坐标
    ↓
4. 计算两个角在各自瓦片内的偏移
    ↓
5. 使用 getTileHeightAtWidth() 计算各自的地面高度
    ↓
6. 取两者中较高的值
    ↓
7. 计算地面的世界坐标
    ↓
8. 如果物体穿过了地面 → 调整位置，清零速度
```

### 关键细节

| 步骤 | 说明 | 原因 |
|------|------|------|
| **检测两个角** | 左下角 + 右下角 | 确保物体完整接触地面 |
| **取较高值** | `max(height_left, height_right)` | 防止物体陷入斜坡 |
| **世界坐标转换** | `ground_y = (tile_y + 1) * tile_size.y - height` | 从瓦片局部坐标转为世界坐标 |
| **穿透检测** | `obj_bottom > ground_y` | 只有穿过才调整 |

---

## 7. 水平移动时的斜坡处理

我们还需要在处理 **水平移动** 时也考虑斜坡，以确保角色能平滑地 **"走上"** 斜坡而不是被卡住。

### 💡 核心思想

```
水平移动遇到斜坡：
┌────────────┐
│  👤→       │  移动到斜坡边缘
│  ━━━━━━    │
│      /     │  ← 检测到斜坡
│     /      │  → 自动调整 Y 坐标
│    /       │  → 平滑走上斜坡
│   /        │
└────────────┘

而不是：
┌────────────┐
│  👤→ 🚫    │  撞墙停止
│  ━━━━━━    │
│      /     │
└────────────┘
```

### 实现逻辑

逻辑与垂直检测类似，计算角色侧面进入斜坡瓦片时的地面高度，并调整其 Y 坐标。

```cpp
// X轴移动时也检查斜坡
if (ds.x != 0) {
    // 计算物体侧面的瓦片坐标
    // 检查该瓦片是否为斜坡
    // 如果是，计算在该位置的地面高度
    // 调整 Y 坐标，让物体"走上"斜坡
}
```

---

## 8. 平滑相机与世界边界

为了让游戏体验更上一层楼，我们不再手动控制相机，而是让它 **自动、平滑地** 跟随玩家。

### 💡 设计思想

```
相机跟随效果：
┌────────────────┐
│    视口范围    │
│                │
│      👤  目标  │ ← 相机平滑移动，保持目标在中心
│                │
└────────────────┘

使用线性插值（lerp）：
new_pos = mix(current_pos, target_pos, smooth_speed * dt)
```

### 平滑跟随的优势

| 方案 | 效果 | 说明 |
|------|------|------|
| ❌ 直接设置位置 | 相机瞬移，突兀 | `camera.pos = player.pos` |
| ✅ 线性插值 | 平滑过渡，舒适 | `glm::mix()` |

---

### engine/render/camera.h & camera.cpp（更新）

```cpp
// camera.h
class Camera final {
private:
    // ...
    float smooth_speed_ = 5.0f;
    engine::component::TransformComponent* target_ = nullptr; // 跟随目标
public:
    void update(float delta_time); // 相机也需要每帧更新
    void setTarget(engine::component::TransformComponent* target);
};

// camera.cpp
void Camera::update(float delta_time)
{
    if (target_ == nullptr) return;
    // 计算目标位置（让目标位于视口中心）
    glm::vec2 desired_position = target_->getPosition() - viewport_size_ / 2.0f;
    // 使用线性插值平滑地移动相机到目标位置
    position_ = glm::mix(position_, desired_position, smooth_speed_ * delta_time);
    clampPosition(); // 确保相机不越界
}
```

### 关键参数

| 参数 | 作用 | 推荐值 |
|------|------|--------|
| `smooth_speed_` | 控制跟随速度 | `5.0` |
| `target_` | 跟随的目标对象 | 玩家的 `TransformComponent` |
| `desired_position` | 目标位置（居中） | `target_pos - viewport_size / 2` |

### 线性插值公式

```
glm::mix(a, b, t) = a + (b - a) * t

其中：
- a: 当前位置
- b: 目标位置
- t: 插值系数 (0~1)
- 返回: 插值后的位置

t = smooth_speed * delta_time
t 越大，跟随越快
```

---

## 9. 场景整合

现在，场景的 `update` 会先更新物理，再更新相机。`GameScene` 在初始化时会设置好相机的跟随目标和边界。

### engine/scene/scene.cpp（更新）

```cpp
void Scene::update(float delta_time) {
    if (!is_initialized_) return;
    context_.getPhysicsEngine().update(delta_time);
    context_.getCamera().update(delta_time); // 更新相机
    // ... (更新游戏对象)
}
```

### game/scene/game_scene.cpp（更新）

```cpp
void GameScene::init() {
    // ... (加载关卡，获取 main_layer)
    
    // 获取玩家对象并设为相机目标
    player_ = findGameObjectByName("player");
    context_.getCamera().setTarget(player_->getComponent<TransformComponent>());

    // 根据地图大小设置相机和物理世界边界
    auto world_size = main_layer->getComponent<TileLayerComponent>()->getWorldSize();
    context_.getCamera().setLimitBounds({glm::vec2(0.0f), world_size});
    context_.getPhysicsEngine().setWorldBounds({glm::vec2(0.0f), world_size});
    
    Scene::init();
}
```

### 初始化流程

```
GameScene 初始化：
    ↓
1. 加载关卡（LevelLoader）
    ↓
2. 获取主图层（main_layer）
    ↓
3. 查找玩家对象（findGameObjectByName）
    ↓
4. 设置相机目标（setTarget）
    ↓
5. 计算地图大小（getWorldSize）
    ↓
6. 设置相机边界（setLimitBounds）
    ↓
7. 设置物理世界边界（setWorldBounds）
    ↓
8. 调用父类 init()
```

### 边界设置

| 边界类型 | 作用 | 来源 |
|---------|------|------|
| **相机边界** | 限制相机移动范围 | 瓦片层的世界尺寸 |
| **物理边界** | 防止物体掉出地图 | 瓦片层的世界尺寸 |

---

## ✅ 编译与运行

编译并运行游戏。你会看到：

```
运行效果：
┌─────────────────────────┐
│                          │
│     ━━━━━ 单向平台      │ ← 可以跳上，不能穿下
│   👤                     │
│    /                     │ ← 斜坡
│   /                      │
│  /                       │
│ ━━━━━━━━━━━━━          │
│                          │
│ ✅ 平滑相机跟随          │
└─────────────────────────┘
```

**你会看到：**
- ✅ 可以从下方跳上单向平台
- ✅ 不能从上方穿过单向平台
- ✅ 可以在斜坡上平滑行走
- ✅ 从斜坡上走下来不会卡顿
- ✅ 相机平滑跟随玩家
- ✅ 相机不会超出地图边界
- ✅ 玩家不会掉出地图

---

## 🎯 系统架构总结

### 完整的地形系统流程

```
1. Tiled 编辑器
   ↓ 设置 unisolid 属性
   ↓ 设置 slope 属性
2. JSON 文件
   ↓ LevelLoader 读取
3. TileLayerComponent
   ↓ 存储 TileType
4. PhysicsEngine 碰撞解析
   ↓
   ├─ SOLID: 全方向碰撞
   ├─ UNISOLID: 仅向下碰撞
   └─ SLOPE: 高度计算碰撞
5. 平滑相机
   ↓ 线性插值跟随
6. 世界边界
   ↓ 限制移动范围
```

### 核心成就

我们成功地：

1. ✅ **单向平台**：可以从下方穿过的平台
2. ✅ **斜坡系统**：多种角度的斜坡支持
3. ✅ **高度计算**：精确的斜坡地面高度
4. ✅ **平滑移动**：在斜坡上自然行走
5. ✅ **平滑相机**：线性插值跟随玩家
6. ✅ **世界边界**：防止掉出地图

### 地形类型对比

| 地形类型 | 碰撞逻辑 | 使用场景 |
|---------|---------|---------|
| **SOLID** | 全方向阻挡 | 地面、墙壁、天花板 |
| **UNISOLID** | 仅向下阻挡 | 跳台、平台 |
| **SLOPE** | 高度计算 | 山坡、楼梯 |
| **NORMAL** | 无碰撞 | 背景、装饰 |

### 相机系统特点

```
相机更新流程：
    ↓
1. 检查是否有目标
    ↓
2. 计算目标位置（居中）
    ↓
3. 线性插值移动
    ↓
4. 边界限制（clampPosition）
    ↓
5. 应用到渲染
```

| 特性 | 说明 | 优势 |
|------|------|------|
| **平滑跟随** | 线性插值 | 视觉舒适，不突兀 |
| **居中显示** | 目标在视口中心 | 视野均衡 |
| **边界限制** | 不超出地图 | 避免显示空白区域 |

---

## 📚 总结

我们已经实现了丰富的地形系统和平滑的相机！

**关键要点：**
- 🪜 单向平台只在向下移动时碰撞
- ⛰️ 斜坡通过高度计算实现平滑移动
- 📐 线性插值公式实现地面高度
- 🎥 相机使用 `glm::mix()` 平滑跟随
- 🌍 世界边界防止物体掉出地图
- 🎮 完整的平台游戏地形系统

> 💡 **设计哲学**：平台游戏的核心在于地形设计。单向平台增加了垂直探索的可能性，斜坡让移动更加流畅自然。这些看似简单的特性，却能极大地丰富游戏玩法和关卡设计的深度！

---

## 🚀 下一步展望

现在我们有了完整的地形系统和流畅的相机！但游戏还需要更多内容：

- ❓ 如何实现玩家的状态管理（跑步、跳跃、攻击）？
- ❓ 如何添加动画让游戏更生动？
- ❓ 如何处理玩家与敌人的交互？

下一课，我们将实现 **玩家组件与状态机**：

- 🎮 玩家控制器
- 🔄 状态机系统
- 🏃 多种角色状态

让我们继续完善这个游戏世界！🎮🌟
