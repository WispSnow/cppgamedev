# 结束场景与最终完成

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1R5eyznEfE&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1R5eyznEfE)

## 📌 问题背景

欢迎来到我们课程的最后一节！我们已经构建了标题、游戏和暂停场景，现在只剩下最后一块拼图——**结束场景（End Scene）**。这个场景将在玩家赢得游戏或耗尽生命时出现，为他们的冒险提供一个明确的结局，并记录下他们的成就。

### ⚠️ 当前的问题

```
无结束场景的游戏：
┌─────────────────────────┐
│ 玩家到达终点...           │
│ 玩家生命耗尽...           │
│                         │
│ ❌ 无胜利提示             │
│ ❌ 无失败提示             │
│ ❌ 无得分显示             │
│ ❌ 无法重新开始           │
│ ❌ 体验不完整             │
└─────────────────────────┘
```

| 问题 | 说明 | 影响 |
|------|------|------|
| **无结束反馈** | 赢了或输了无提示 | 缺少成就感 |
| **无得分记录** | 无法看到最高分 | 缺少竞争性 |
| **流程不完整** | 无法重新开始 | 用户体验差 |
| **数据不持久** | 分数不保存 | 无记录价值 |

### 💡 解决方案：完整的游戏闭环

同时，我们还会进行一些关键的优化和打磨，确保游戏的流程天衣无缝，让玩家可以**顺畅地从开始玩到结束，再重新开始新的挑战**。

**核心思想**：
1. 创建EndScene处理胜利/失败
2. 实现游戏结束触发逻辑
3. 开发持久化最高分系统
4. 完善游戏流程细节

```
完整游戏循环：
┌──────────────────────────┐
│     TitleScene           │ ← 开始
│     [开始游戏]            │
└────────┬─────────────────┘
         │
         ↓
┌──────────────────────────┐
│     GameScene            │ ← 游玩
│     • 收集宝石            │
│     • 击败敌人            │
│     • 到达终点            │
└────┬────────────────┬────┘
     │ 胜利            │ 失败
     ↓                ↓
┌──────────────────────────┐
│     EndScene             │ ← 结束 ✨
│     • 显示结果            │
│     • 保存最高分           │
│     • [重新开始][返回]     │
└────────┬─────────────────┘
         │
         ↓ 重新开始
┌──────────────────────────┐
│     TitleScene           │ ← 循环
└──────────────────────────┘

完整的游戏闭环！
```

### 🎯 本课目标

| 目标 | 说明 |
|------|------|
| **创建EndScene** | 处理游戏胜利和失败 |
| **触发结束逻辑** | 到达终点或生命耗尽 |
| **最高分系统** | 持久化保存玩家记录 |
| **最终打磨** | 优化游戏流程细节 |

---

## 第一部分：EndScene 设计

### 💡 结束场景的职责

EndScene 的职责很明确：**根据游戏结果，向玩家显示不同的信息，并提供"重新开始"或"返回主菜单"的选项**。

```
EndScene 功能：
┌──────────────────────┐
│ 根据结果显示           │
│ • 胜利 → YOU WIN!    │
│ • 失败 → YOU DIED!   │
├──────────────────────┤
│ 显示得分信息           │
│ • 本次得分            │
│ • 历史最高分           │
├──────────────────────┤
│ 提供操作选项           │
│ • 重新开始            │
│ • 返回主菜单          │
└──────────────────────┘
```

---

## 1. EndScene 实现

它的核心逻辑在 `createUI` 方法中。通过从 SessionData 读取 `is_win_` 标志，它可以动态地决定显示"YOU WIN!"还是"YOU DIED!"，甚至连文本颜色也会随之改变。

### src/game/scene/end_scene.cpp（实现）

```cpp
void EndScene::createUI() {
    auto is_win = session_data_->getIsWin();

    // --- 根据胜负结果显示不同的主信息 ---
    std::string main_message = is_win ? "YOU WIN! CONGRATS!" : "YOU DIED! TRY AGAIN!";
    // 赢了是绿色，输了是红色
    engine::utils::FColor message_color = is_win ? engine::utils::FColor{0.0f, 1.0f, 0.0f, 1.0f} : 
                                                   engine::utils::FColor{1.0f, 0.0f, 0.0f, 1.0f};

    auto main_label = std::make_unique<engine::ui::UILabel>(/*...*/, main_message, /*...*/, message_color);
    ui_manager_->addElement(std::move(main_label));

    // --- 显示当前得分和最高分 ---
    int current_score = session_data_->getCurrentScore();
    int high_score = session_data_->getHighScore();
    
    std::string score_text = "Score: " + std::to_string(current_score);
    auto score_label = std::make_unique<engine::ui::UILabel>(/*...*/, score_text, /*...*/);
    ui_manager_->addElement(std::move(score_label));

    std::string high_score_text = "High Score: " + std::to_string(high_score);
    auto high_score_label = std::make_unique<engine::ui::UILabel>(/*...*/, high_score_text, /*...*/);
    ui_manager_->addElement(std::move(high_score_label));

    // --- 创建"返回"和"重新开始"按钮 ---
    // ...
}
```

### EndScene 显示逻辑

```
EndScene 动态显示：
┌──────────────────────────┐
│ 胜利情况：                 │
│ ╔═══════════════════╗    │
│ ║ YOU WIN! CONGRATS!║    │ ← 绿色文字
│ ║                   ║    │
│ ║ Score: 1500       ║    │
│ ║ High Score: 2000  ║    │
│ ║                   ║    │
│ ║ [重新开始] [返回]   ║    │
│ ╚═══════════════════╝    │
└──────────────────────────┘

┌──────────────────────────┐
│ 失败情况：               │
│ ╔═══════════════════╗    │
│ ║ YOU DIED! TRY AGAIN!║  │ ← 红色文字
│ ║                   ║    │
│ ║ Score: 800        ║    │
│ ║ High Score: 2000  ║    │
│ ║                   ║    │
│ ║ [重新开始] [返回]   ║    │
│ ╚═══════════════════╝    │
└──────────────────────────┘
```

### 显示逻辑对比

| 结果 | 主信息 | 文字颜色 | 情感 |
|-----|--------|---------|------|
| **胜利** | "YOU WIN! CONGRATS!" | 绿色 (0,1,0) | 喜悦 🎉 |
| **失败** | "YOU DIED! TRY AGAIN!" | 红色 (1,0,0) | 鼓励 💪 |

### UI元素列表

```
EndScene UI元素：
┌──────────────────────┐
│ 1. 主信息标签          │
│    • 胜利/失败文字     │
│    • 动态颜色         │
├──────────────────────┤
│ 2. 得分显示           │
│    • 本次得分         │
│    • 历史最高分       │
├──────────────────────┤
│ 3. 操作按钮           │
│    • 重新开始         │
│    • 返回主菜单       │
└──────────────────────┘
```

---

## 第二部分：触发游戏结束

### 💡 游戏结束的条件

游戏何时结束？我们定义了两个条件。

---

## 2. 结束条件定义

### 结束条件

| 条件 | 触发方式 | 结果 | 实现位置 |
|-----|---------|------|---------|
| **胜利** | 碰到"win"对象 | is_win=true | handleObjectCollisions() |
| **失败1** | 生命值耗尽 | is_win=false | 之前已实现 |
| **失败2** | 掉出地图下方 | is_win=false | update() |

### 胜利条件

**胜利**：当玩家控制的角色与一个在Tiled编辑器中被命名为 `"win"` 的特殊对象碰撞时。

```
胜利触发：
┌──────────────────────┐
│ Tiled地图编辑         │
│ 创建对象 name="win"   │
│      │               │
│      ↓               │
│ 玩家碰撞检测           │
│      │               │
│      ↓               │
│ showEndScene(true)   │
│      │               │
│      ↓               │
│ YOU WIN! 🎉          │
└──────────────────────┘
```

### 失败条件

**失败**：当玩家的生命值耗尽（这个在之前的课程已经实现），或者从地图的下方掉落出去时。

```
失败触发：
┌──────────────────────┐
│ 方式1：生命值耗尽       │
│ health <= 0          │
│      ↓               │
│ showEndScene(false)  │
├──────────────────────┤
│ 方式2：掉出地图         │
│ y > world.bottom+100 │
│      ↓               │
│ showEndScene(false)  │
└──────────────────────┘
```

### src/game/scene/game_scene.cpp（实现）

我们创建了一个辅助函数 `showEndScene` 来统一处理场景切换，并在 GameScene 的更新和碰撞处理逻辑中调用它。

```cpp
// 封装了切换到结束场景的逻辑
void GameScene::showEndScene(bool is_win)
{
    spdlog::debug("显示结束场景，游戏 {}", is_win ? "胜利" : "失败");
    game_session_data_->setIsWin(is_win);
    auto end_scene = std::make_unique<game::scene::EndScene>(context_, scene_manager_, game_session_data_);
    scene_manager_.requestPushScene(std::move(end_scene));
}

void GameScene::update(float delta_time) {
    // ...
    // 玩家掉出地图下方则判断为失败
    if (player_ ) {
        auto pos = player_->getComponent<engine::component::TransformComponent>()->getPosition();
        auto world_rect = context_.getPhysicsEngine().getWorldBounds();
        if (world_rect && pos.y > world_rect->position.y + world_rect->size.y + 100.0f) {
            showEndScene(false);
        }
    }
}

void GameScene::handleObjectCollisions()
{
    // ...
    for (const auto& pair : collisions) {
        // ...
        // 处理玩家与胜利触发器碰撞
        if (obj1->getName() == "player" && obj2->getName() == "win") {
            showEndScene(true);
        } else if (obj2->getName() == "player" && obj1->getName() == "win") {
            showEndScene(true);
        }
    }
}
```

### showEndScene 工作流程

```
showEndScene 流程：
    ↓
1. 接收胜负标志
   is_win (true/false)
    ↓
2. 更新SessionData
   setIsWin(is_win)
    ↓
3. 创建EndScene
   make_unique<EndScene>()
    ↓
4. Push场景
   requestPushScene()
    ↓
5. EndScene显示
   根据is_win显示结果
```

### 触发位置总结

```
结束触发位置：
┌──────────────────────────┐
│ GameScene::update()      │
│ ✅ 检测掉出地图            │
│    y > bottom + 100      │
├──────────────────────────┤
│ GameScene::              │
│ handleObjectCollisions() │
│ ✅ 检测胜利碰撞            │
│    name == "win"         │
├──────────────────────────┤
│ GameScene::              │
│ handlePlayerDamage()     │
│ ✅ 生命值耗尽（之前实现）    │
│    health <= 0           │
└──────────────────────────┘
```

---

## 第三部分：最高分系统

### 💡 持久化玩家记录

一个好的街机风格游戏，必须能**记住玩家的最高分**！我们不希望这个记录在游戏关闭后就消失。

---

## 3. 最高分持久化

为此，我们为 SessionData 增加了一个强大的新功能：`syncHighScore`。

### syncHighScore 逻辑

这个函数会在游戏启动、退出或开始新关卡时被调用。它的逻辑非常巧妙：

```
syncHighScore 逻辑：
┌──────────────────────┐
│ 1. 读取文件           │
│    save.json         │
│    high_score = X    │
├──────────────────────┤
│ 2. 比较分数           │
│    内存 vs 文件       │
├──────────────────────┤
│ 3. 双向同步           │
│    取最大值           │
├──────────────────────┤
│ 4. 更新到两处         │
│    • 内存            │
│    • 文件            │
└──────────────────────┘
```

### 同步策略

| 情况 | 内存分数 | 文件分数 | 操作 | 结果 |
|-----|---------|---------|------|------|
| **情况1** | 1500 | 1000 | 更新文件 | 文件=1500 |
| **情况2** | 1000 | 1500 | 更新内存 | 内存=1500 |
| **情况3** | 1500 | 1500 | 无需更新 | 保持不变 |

### src/game/data/session_data.cpp（实现）

```cpp
bool SessionData::syncHighScore(const std::string& filename)
{
    try {
        // ... (读取文件和JSON)
        auto high_score_in_file = j.value("high_score", 0);

        if (high_score_in_file < high_score_) {     // 内存分数 > 文件分数
            j["high_score"] = high_score_;          // 更新文件
            // ... (写入文件)
        } else if (high_score_in_file > high_score_) {  // 文件分数 > 内存分数
            high_score_ = high_score_in_file;       // 更新内存
        }
        return true;
    } catch (const std::exception& e) {
        // ...
        return false;
    }
}
```

### 同步流程

```
syncHighScore 工作流程：
    ↓
1. 读取 save.json
   high_score_in_file = ?
    ↓
2. 与内存对比
   ┌─────────┬─────────┐
   │ 内存>文件│ 文件>内存│
   ↓         ↓
3. 更新文件  更新内存
   写JSON     high_score_ = file
    ↓         ↓
4. 完成同步
   两处都是最高值 ✅
```

我们在 **TitleScene, GameScene, MenuScene** 的初始化和退出逻辑中都调用了这个函数，以保证数据同步。

### 调用时机

```
syncHighScore 调用时机：
┌──────────────────────┐
│ 1. TitleScene::init()│
│    游戏启动时         │
│    加载历史最高分      │
├──────────────────────┤
│ 2. GameScene::init() │
│    开始游戏时          │
│    同步最高分          │
├──────────────────────┤
│ 3. MenuScene::       │
│    onSaveClicked()   │
│    保存游戏时          │
│    更新最高分          │
├──────────────────────┤
│ 4. EndScene::init()  │
│    游戏结束时          │
│    保存新纪录          │
└──────────────────────┘

确保数据永不丢失！
```

### 数据持久化价值

```
持久化的意义：
┌─────────────────────┐
│ 无持久化（差）：     │
│ • 关闭游戏后丢失    │
│ • 无法比较记录      │
│ • 缺少成就感        │
│ ❌ 竞争性弱         │
├─────────────────────┤
│ 有持久化（好）：     │
│ • 永久保存记录      │
│ • 可以超越自己      │
│ • 挑战最高分        │
│ ✅ 竞争性强         │
└─────────────────────┘

记录让游戏"有历史"！
```

---

## 第四部分：最终打磨

### 💡 细节决定成败

为了让游戏体验更加完美，我们做了几项最后的优化。

---

## 4. 游戏流程优化

### 优化1：解除相机边界

当玩家从 GameScene 返回到 TitleScene 时，我们不希望相机的移动还受限于之前关卡的地图边界。通过将 `Camera::setLimitBounds` 的参数改为 `std::optional`，我们现在可以传入 `std::nullopt` 来彻底解除边界限制。

### src/game/scene/title_scene.cpp（更新）

```cpp
void TitleScene::init() {
    // ...
    // 重置相机坐标，不限制边界
    context_.getCamera().setPosition(glm::vec2(0.0f, 0.0f));
    context_.getCamera().setLimitBounds(std::nullopt); 
    // ...
}
```

### 相机边界问题

```
相机边界问题：
┌──────────────────────┐
│ 问题：               │
│ GameScene有边界限制  │
│ 地图范围: 0-1000     │
│      ↓               │
│ 返回TitleScene       │
│ 相机仍被限制！❌     │
│ 无法自由滚动         │
├──────────────────────┤
│ 解决：               │
│ TitleScene::init()   │
│ setLimitBounds(      │
│   std::nullopt) ✅   │
│      ↓               │
│ 相机自由移动         │
│ 背景正常滚动         │
└──────────────────────┘
```

### 优化2：完善生命值UI

我们修复了生命值UI的一个小问题。现在，无论最大生命值是多少，UI都能正确地先绘制出所有"空的"心形背景，然后再根据当前生命值决定点亮多少个"填充的"心形前景。

### src/game/scene/game_scene.cpp（优化）

```cpp
void GameScene::createHealthUI() {
    // ...
    for (int i = 0; i < max_health; ++i) {      // 先创建所有背景图标
        // ...
    }
    for (int i = 0; i < max_health; ++i) {      // 再创建所有前景图标
        // ...
        auto fg_icon = std::make_unique<engine::ui::UIImage>(...);
        bool is_visible = (i < current_health);
        fg_icon->setVisible(is_visible);         // 根据当前生命值设置可见性
        health_panel_->addChild(std::move(fg_icon));
    }
    // ...
}
```

### 生命值UI优化

```
生命值UI优化：
┌──────────────────────┐
│ 优化前：             │
│ 创建时只创建         │
│ current_health个图标 │
│ ❌ 动态添加麻烦      │
├──────────────────────┤
│ 优化后：             │
│ 1. 创建max_health个  │
│    背景图标（全显示）│
│ 2. 创建max_health个  │
│    前景图标          │
│ 3. 根据current设置   │
│    前景可见性        │
│ ✅ 切换只改可见性    │
└──────────────────────┘

性能更好，逻辑更清晰！
```

### 优化对比

| 项目 | 优化前 | 优化后 | 效果 |
|-----|-------|-------|------|
| **相机边界** | 保持限制 | 可解除限制 | 场景切换流畅 ✅ |
| **生命值UI** | 动态创建 | 切换可见性 | 性能更好 ✅ |

### 其他优化细节

```
其他打磨细节：
┌──────────────────────┐
│ ✅ 场景切换平滑      │
│    无画面跳动        │
├──────────────────────┤
│ ✅ UI布局精确        │
│    像素级对齐        │
├──────────────────────┤
│ ✅ 音效时机准确      │
│    反馈及时          │
├──────────────────────┤
│ ✅ 数据同步可靠      │
│    无丢失风险        │
└──────────────────────┘
```

---

## ✅ 完整游戏流程

让我们验证完整的游戏流程：

```
完整游戏流程测试：
┌─────────────────────────┐
│  1. 启动游戏            │
│     TitleScene          │
│     [开始游戏]          │
│     ↓                   │
│  2. 进入游戏            │
│     GameScene           │
│     状态: Playing       │
│     ↓                   │
│  3. 游戏过程            │
│     • 收集宝石 +分数    │
│     • 击败敌人 +分数    │
│     • 受伤 -生命        │
│     ↓                   │
│  4. 暂停功能            │
│     按ESC → MenuScene   │
│     状态: Paused        │
│     [继续] → 恢复游戏   │
│     ↓                   │
│  5. 游戏结束            │
│     • 到达终点 → 胜利   │
│     • 生命耗尽 → 失败   │
│     • 掉出地图 → 失败   │
│     ↓                   │
│  6. 结束场景            │
│     EndScene            │
│     • 显示结果          │
│     • 保存最高分        │
│     • [重新开始][返回]  │
│     ↓                   │
│  7. 循环游戏            │
│     可重新开始或退出    │
└─────────────────────────┘

完整流程，天衣无缝！
```

### 功能检查清单

```
最终功能检查：
┌──────────────────────┐
│ ✅ 标题场景正常      │
│ ✅ 游戏场景完整      │
│ ✅ 暂停功能可用      │
│ ✅ 结束场景正确      │
│ ✅ 胜利条件触发      │
│ ✅ 失败条件触发      │
│ ✅ 最高分保存        │
│ ✅ 场景切换流畅      │
│ ✅ 数据持久化        │
│ ✅ UI显示正确        │
└──────────────────────┘
```

---

## 🎯 课程总结

### 💡 我们完成了什么

恭喜你，坚持到了最后！至此，我们的"阳光岛"项目已经**完全竣工**。

```
项目完成度：
┌──────────────────────────┐
│ ✅ 引擎核心（完成）       │
│    • 资源管理            │
│    • 渲染系统            │
│    • 物理引擎            │
│    • 音频系统            │
│    • 输入管理            │
│    • 场景管理            │
├──────────────────────────┤
│ ✅ 组件系统（完成）        │
│    • Transform           │
│    • Sprite              │
│    • Physics             │
│    • Collider            │
│    • Health              │
│    • AI                  │
├──────────────────────────┤
│ ✅ UI系统（完成）          │
│    • UIManager           │
│    • UIElement           │
│    • UIPanel/Image/Label │
│    • UIButton            │
│    • UIInteractive       │
├──────────────────────────┤
│ ✅ 游戏场景（完成）        │
│    • TitleScene          │
│    • GameScene           │
│    • MenuScene           │
│    • HelpsScene          │
│    • EndScene            │
├──────────────────────────┤
│ ✅ 游戏逻辑（完成）      │
│    • 玩家控制            │
│    • 敌人AI              │
│    • 碰撞检测            │
│    • 物品系统            │
│    • 得分系统            │
│    • 关卡设计            │
└──────────────────────────┘

一个完整的2D游戏！🎉
```

### 从零到完整

回顾这36节课，我们从一个空白的 `main.cpp` 文件开始，一步步构建了一个**功能强大、结构清晰**的2D游戏。

```
开发历程：
┌──────────────────────┐
│ 第1-5课：基础        │
│ • 环境配置           │
│ • 项目架构           │
│ • 主循环             │
│ • 资源管理           │
├──────────────────────┤
│ 第6-14课：核心系统   │
│ • 渲染器             │
│ • 相机               │
│ • 输入管理           │
│ • 游戏对象           │
│ • 组件系统           │
│ • 场景管理           │
│ • 关卡载入           │
├──────────────────────┤
│ 第15-26课：游戏逻辑  │
│ • 物理引擎           │
│ • 碰撞检测           │
│ • 玩家控制           │
│ • 动画系统           │
│ • AI系统             │
│ • 音频系统           │
├──────────────────────┤
│ 第27-36课：完善流程  │
│ • 关卡切换           │
│ • 文字渲染           │
│ • UI系统             │
│ • 场景管理           │
│ • 游戏流程           │
│ • 最终打磨           │
└──────────────────────┘

36课，从零到完整！
```

### 核心技术成就

我们不仅实现了一个有趣的平台跳跃游戏，更重要的是，我们深入实践了**现代C++游戏开发的核心思想**：

#### 1. 分层架构

**将引擎与游戏逻辑彻底分离**。

```
分层架构：
┌──────────────────┐
│   Game Layer     │ ← 游戏逻辑
│   (可替换)       │
├──────────────────┤
│   Engine Layer   │ ← 引擎核心
│   (可复用)       │
└──────────────────┘

引擎独立，游戏灵活！
```

#### 2. 组件式设计

**用灵活的组件来组合游戏对象的功能**。

```
组件组合：
GameObject
  ├─ TransformComponent
  ├─ SpriteComponent
  ├─ PhysicsComponent
  ├─ ColliderComponent
  └─ HealthComponent

灵活组合，无限可能！
```

#### 3. 状态模式

**优雅地管理玩家、AI和UI的复杂状态**。

```
状态模式应用：
• PlayerState (Idle/Walk/Jump)
• AIState (Patrol/Chase/Attack)
• UIState (Normal/Hover/Pressed)
• GameState (Title/Playing/Paused)

状态清晰，易于扩展！
```

#### 4. 场景管理

**通过场景堆栈构建出完整的游戏流程**。

```
场景堆栈：
• Replace - 主要流程
• Push - 临时叠加
• Pop - 返回上层

灵活管理，完整流程！
```

#### 5. 数据驱动

**利用JSON进行关卡设计和配置管理**。

```
数据驱动：
• 关卡数据 (Tiled JSON)
• 配置数据 (config.json)
• 存档数据 (save.json)

配置驱动，易于调整！
```

---

## 🎓 学习成果

### 你现在拥有的能力

你现在拥有的，不仅仅是一个完成的项目，更是**一套可以用来创造更多、更复杂游戏的坚实框架和宝贵经验**。

```
你的收获：
┌──────────────────────┐
│ 1. 完整的游戏引擎    │
│    可复用的框架      │
├──────────────────────┤
│ 2. 现代C++实践       │
│    智能指针、RAII等  │
├──────────────────────┤
│ 3. 游戏开发思维      │
│    架构设计能力      │
├──────────────────────┤
│ 4. 问题解决经验      │
│    调试和优化        │
├──────────────────────┤
│ 5. 完整项目经验      │
│    从零到完成        │
└──────────────────────┘
```

---

## 🌟 结语

### 感谢与展望

感谢你的一路同行，希望这次的"**C++游戏开发之旅**"对你有所启发。

> 💡 **未来的游戏世界，等你来创造！**

```
继续前进：
┌──────────────────────┐
│ 这不是结束，         │
│ 而是新的开始！       │
│                      │
│ • 继续学习           │
│ • 不断实践           │
│ • 勇于创新           │
│ • 分享经验           │
│                      │
│ 🚀 向着更远的目标    │
│    继续前进！        │
└──────────────────────┘
```

---

## 🎊 恭喜你完成了整个课程！

```
════════════════════════════════
    🏆 课程完成徽章 🏆
    
    C++ 游戏开发之旅
    
    ⭐ 36课全部完成 ⭐
    ⭐ 一个完整的游戏 ⭐
    ⭐ 宝贵的开发经验 ⭐
    
    继续加油！🚀
════════════════════════════════
```

**再次感谢你的坚持与努力！愿你在游戏开发的道路上越走越远！** 🎮✨