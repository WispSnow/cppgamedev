# 精灵图类

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/ltynaCnh4Co?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1eLXMYJEuZ&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了游戏对象的自动挂载功能，使得对象之间的管理变得更加简单和直观。然而，目前我们的玩家角色仍然只是一个简单的红色方块。为了让游戏更加生动和视觉上更有吸引力，我们需要引入精灵图系统。本课将讲解如何设计和实现精灵图类，以及如何将其集成到我们的游戏框架中。

## 精灵图系统的需求

在游戏开发中，精灵图（Sprite）是一种常见的2D图像表示形式，通常用于表示游戏中的角色、物体、特效等。一个完善的精灵图系统需要满足以下需求：

1. **视觉表现**：显示图像，可能包括动画、旋转、缩放等效果
2. **组合性**：一个游戏对象可能有多个精灵图组件（例如，角色的身体、武器、装备等）
3. **简单的使用方式**：容易将精灵图附加到游戏对象上
4. **资源管理**：有效地管理和使用纹理资源
5. **渲染顺序**：控制不同精灵图之间的渲染顺序

为了满足这些需求，我们设计了一个新的对象类型系统：对象附属系统（Object Affiliate System）。

## 对象附属系统

对象附属系统是一种特殊的对象关系模式，它允许一个对象（主体）拥有多个附属对象（附件）。与普通的父子关系不同，附属对象的位置和行为直接依赖于其主体对象。这种设计非常适合表示游戏中的视觉组件，如精灵图、粒子效果等。

<img src="https://theorhythm.top/gamedev/GE/09-精灵图类.PNG" style='width: 800px;' />

### ObjectAffiliate类

我们首先定义了一个新的基类`ObjectAffiliate`，它代表一个附属对象：

```cpp
// object_affiliate.h
#ifndef OBJECT_AFFILIATE_H
#define OBJECT_AFFILIATE_H

#include "object_screen.h"

class ObjectAffiliate : public Object 
{
protected:
    ObjectScreen *parrent_ = nullptr; // 父节点
    glm::vec2 offset_ = glm::vec2(0, 0); // 相对父节点的偏移
    glm::vec2 size_ = glm::vec2(0, 0); // 大小

public:
    // getters and setters
    ObjectScreen *getParrent() const { return parrent_; }
    void setParrent(ObjectScreen *parrent) { parrent_ = parrent; }
    glm::vec2 getOffset() const { return offset_; }
    void setOffset(const glm::vec2 &offset) { offset_ = offset; }
    glm::vec2 getSize() const { return size_; }
    void setSize(const glm::vec2 &size) { size_ = size; }
};

#endif // OBJECT_AFFILIATE_H
```

`ObjectAffiliate`类有以下主要特点：

1. **主体引用**：通过`parrent_`成员引用其主体对象（必须是`ObjectScreen`类型或其子类）
2. **相对位置**：通过`offset_`成员定义相对于主体的位置偏移
3. **尺寸**：通过`size_`成员定义附属对象的大小

与普通的子对象不同，附属对象不会被自动添加到其主体的子对象列表中。相反，附属对象需要同时被添加为主体的子对象（自动挂载）和设置主体引用（附属关系）。这种双重关系确保了附属对象既能享受自动挂载的好处，又能直接访问和使用主体的属性。

## Texture结构体

在实现精灵图之前，我们首先需要一个结构来表示纹理资源。我们定义了一个`Texture`结构体：

```cpp
// sprite.h
struct Texture
{
    SDL_Texture *texture = nullptr;
    SDL_FRect src_rect = {0, 0, 0, 0};
    float angle = 0;
    bool is_flip = false;
    Texture() = default;
    Texture(const std::string& file_path); 
};
```

`Texture`结构体包含以下成员：

1. **纹理指针**：指向SDL纹理对象的指针
2. **源矩形**：定义纹理上要显示的区域（用于精灵表动画）
3. **角度**：纹理的旋转角度
4. **翻转标记**：指示是否水平翻转纹理

`Texture`还提供了一个构造函数，可以直接从文件路径创建纹理：

```cpp
// sprite.cpp
Texture::Texture(const std::string &file_path)
{
    texture = Game::GetInstance().getAssetStore()->getImage(file_path);
    SDL_GetTextureSize(texture, &src_rect.w, &src_rect.h);
}
```

这个构造函数做了两件事：

1. 使用资源管理器加载纹理
2. 获取纹理的原始大小，设置源矩形

## Sprite类

有了`Texture`和`ObjectAffiliate`，我们现在可以实现`Sprite`类：

```cpp
// sprite.h
class Sprite : public ObjectAffiliate
{
protected:
    Texture texture_;

public:
    Sprite() = default;
    virtual void render() override;

    // getters and setters
    Texture getTexture() const { return texture_; }
    void setTexture(const Texture &texture);
};
```

`Sprite`类包含一个`Texture`成员，以及用于访问和修改它的getter和setter方法。`render`方法负责在屏幕上绘制精灵图：

```cpp
// sprite.cpp
void Sprite::render()
{
    if (texture_.texture == nullptr)
    {
        return;
    }
    if (parrent_ == nullptr)
    {
        return;
    }
    auto pos = parrent_->getRenderPosition() + offset_;
    game_.renderTexture(texture_, pos, size_);
}

void Sprite::setTexture(const Texture &texture)
{
    texture_ = texture;
    size_ = glm::vec2(texture.src_rect.w, texture.src_rect.h);
}
```

`render`方法的工作流程：

1. 检查纹理和主体是否存在
2. 计算渲染位置（主体的屏幕位置 + 偏移）
3. 调用`game_.renderTexture`方法绘制纹理

`setTexture`方法设置纹理，并自动更新精灵的大小以匹配纹理大小。

## 在Game类中实现纹理渲染

为了统一和简化纹理渲染过程，我们在`Game`类中添加了一个新的方法：

```cpp
// game.h
void renderTexture(const Texture& texture, const glm::vec2& position, const glm::vec2& size);
```

```cpp
// game.cpp
void Game::renderTexture(const Texture &texture, const glm::vec2 &position, const glm::vec2 &size)
{
    SDL_FRect dst_rect = {
        position.x,
        position.y,
        size.x,
        size.y
    };
    SDL_RenderTextureRotated(renderer_, texture.texture, &texture.src_rect, &dst_rect, texture.angle, nullptr, texture.is_flip ? SDL_FLIP_HORIZONTAL : SDL_FLIP_NONE);
}
```

这个方法使用SDL的`SDL_RenderTextureRotated`函数，它允许我们在一次调用中实现纹理的位置、大小、旋转和翻转。通过将这个功能封装在`Game`类中，我们可以在未来轻松地扩展或修改渲染逻辑，而不需要修改所有使用纹理的代码。

## 在Player类中使用精灵图

现在我们可以为玩家角色添加一个精灵图：

```cpp
// player.cpp
void Player::init()
{
    Actor::init();
    max_speed_ = 500.0f;
    auto sprite = new Sprite();
    sprite->setTexture(Texture("assets/sprite/ghost-idle.png"));
    sprite->setParrent(this);
    addChild(sprite);
}
```

这段代码做了以下几件事：

1. 创建一个新的`Sprite`对象
2. 设置纹理（从文件路径创建）
3. 设置精灵的主体为当前玩家对象
4. 将精灵添加为玩家的子对象

请注意，我们既设置了精灵的主体（`setParrent(this)`），又将其添加为子对象（`addChild(sprite)`）。这种双重关系确保了精灵既能正确定位（相对于玩家），又能自动随玩家更新和渲染。

现在，我们可以保留原来的红色方块渲染代码作为备用，但在精灵图正常工作时，玩家会显示为精灵图而不是红色方块。

## 精灵图系统的优势

我们的精灵图系统有以下优势：

1. **模块化**：精灵图是独立的对象，可以轻松添加、移除或替换
2. **复合性**：一个游戏对象可以拥有多个精灵图，每个精灵图可以有不同的外观和行为
3. **资源管理**：使用AssetStore加载和管理纹理资源，避免重复加载
4. **渲染控制**：可以控制旋转、缩放、翻转等渲染属性
5. **自动定位**：精灵图自动跟随其主体对象移动
6. **生命周期管理**：利用自动挂载系统，精灵图的生命周期与其主体对象同步



## 总结

在本课中，我们实现了精灵图系统，它为我们的游戏对象提供了视觉表现力。我们引入了对象附属系统，它允许一个对象拥有多个视觉组件，每个组件都可以独立控制其外观和行为。我们还实现了`Texture`结构体和`Sprite`类，以及在`Game`类中添加了统一的纹理渲染方法。

这个系统为我们的游戏框架增添了丰富的视觉表现能力，使我们能够创建更加生动和有吸引力的游戏。在接下来的课程中，我们将继续扩展这个系统，添加更多的功能，如动画、状态机、特效等。

## 练习

1. **添加多个精灵**：修改`Player`类，为玩家添加多个精灵组件，如身体、武器、盾牌等，并确保它们在正确的位置显示。

2. **优化渲染**：修改`Game::renderTexture`方法，添加优化功能，如视口裁剪（只渲染视口内的精灵）、批处理（减少渲染调用次数）等。