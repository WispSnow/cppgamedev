# 最后的完善

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/P1_xATYZ0Ek?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV19k5vzrEi7&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前面的课程中，我们已经实现了游戏的所有主要功能，包括角色移动、敌人生成、碰撞检测、UI系统、存档系统、视差滚动背景、窗口缩放和游戏变速等。在这最后一课中，我们将对代码进行一些最终的优化和完善，修复潜在的bug，并提高代码的可维护性和稳定性。

## 一、命名规范统一

良好的变量命名是代码可读性和可维护性的基础。在我们的项目中，最初有一些不一致的命名，特别是关于"parent"这个概念：

```cpp
// 旧代码中的不一致命名
ObjectScreen *parrent_ = nullptr; // 拼写错误：parrent 应该为 parent
```

我们统一将所有的`parrent_`修改为正确的拼写`parent_`，并相应地更新了所有相关方法：

```cpp
// 修正后的代码
ObjectScreen *parent_ = nullptr; // 正确的拼写

// 修改后的getter和setter
ObjectScreen *getParent() const { return parent_; }
void setParent(ObjectScreen *parent) { parent_ = parent; }
```

这种看似微小的修改实际上对代码的长期维护非常重要，它确保了命名的一致性，减少了理解代码时的混淆。

## 二、改进碰撞器类型设计

碰撞检测是游戏核心机制之一，良好的设计可以提高代码的清晰度和可扩展性。我们对`Collider`类进行了以下改进：

### 1. 明确的类型命名

```cpp
// 修改前
Type type_ = Type::CIRCLE;
Type type() const { return type_; }
void setType(Type type) { type_ = type; }

// 修改后
Type collider_type_ = Type::CIRCLE;
Type getColliderType() const { return collider_type_; }
void setColliderType(Type collider_type) { collider_type_ = collider_type; }
```

通过在成员变量和方法名中添加`collider_`前缀，我们明确了这些是与碰撞器类型相关的，避免了与其他类型可能的混淆。

### 2. 更安全的碰撞检测

```cpp
bool Collider::isColliding(Collider *other)
{
    if (!other) return false;
    if (collider_type_ == Type::CIRCLE && other->collider_type_ == Type::CIRCLE)
    {
        auto point1 = parent_->getPosition() + offset_ + size_ / 2.0f;
        auto point2 = other->parent_->getPosition() + other->offset_ + other->size_ / 2.0f;
        return glm::length(point1 - point2) < (size_.x + other->size_.x) / 2.0f;
    }
    // TODO： 其它形状的碰撞检测
    return false;
}
```

我们添加了对`other`参数的空指针检查，增强了代码的健壮性，防止因为传入空指针而导致的游戏崩溃。

## 三、改进对象创建和安全性

在我们的游戏引擎中，很多对象是通过静态工厂方法创建的，例如`addSpriteChild`、`addColliderChild`等。我们发现这些方法中存在一个共同的问题：它们假设`parent`参数总是有效的，但在实际应用中，这一点并不总是成立。

### 1. 添加空指针检查

```cpp
// 修改前
Sprite *Sprite::addSpriteChild(ObjectScreen *parent, const std::string &file_path, float scale, Anchor anchor)
{
    auto sprite = new Sprite();
    // ... 初始化代码 ...
    sprite->setParent(parent);
    parent->addChild(sprite); // 如果parent为空，这里会崩溃
    return sprite;
}

// 修改后
Sprite *Sprite::addSpriteChild(ObjectScreen *parent, const std::string &file_path, float scale, Anchor anchor)
{
    auto sprite = new Sprite();
    // ... 初始化代码 ...
    sprite->setParent(parent);
    if (parent) parent->addChild(sprite); // 安全检查
    return sprite;
}
```

这种修改应用到了所有类似的工厂方法中，包括`AffiliateBar`、`Collider`、`SpriteAnim`、`Stats`和`WeaponThunder`等类的创建方法。

### 2. 更合理的方法顺序

在一些类中，我们调整了方法的顺序，将静态工厂方法放在类方法的最前面，这样更容易找到创建对象的方法：

```cpp
// TextLabel.cpp
TextLabel *TextLabel::addTextLabelChild(ObjectScreen *parent, const std::string &text, const std::string &font_path, int font_size, Anchor anchor)
{
    // ... 创建代码 ...
}

void TextLabel::render()
{
    // ... 渲染代码 ...
}

void TextLabel::clean()
{
    // ... 清理代码 ...
}
```

这种组织方式使得代码更容易阅读和理解，特别是对于不熟悉代码库的开发者。

## 四、改进边界碰撞检测

在原始代码中，我们的角色移动限制较为简单，只是简单地将位置限制在世界范围内：

```cpp
// 修改前
void Actor::move(float dt)
{
    setPosition(position_ + velocity_ * dt);
    position_ = glm::clamp(position_, glm::vec2(0), game_.getCurrentScene()->getWorldSize());
}
```

这种方法不考虑角色的碰撞盒大小，可能导致角色看起来部分移出屏幕。我们进行了改进：

```cpp
// 修改后
void Actor::move(float dt)
{
    setPosition(position_ + velocity_ * dt);
    // 根据碰撞盒大小来限制移动区域
    glm::vec2 margin_top_left = glm::vec2(0);
    glm::vec2 margin_bottom_right = glm::vec2(0);
    if (collider_){
        margin_top_left = collider_->getOffset();
        margin_bottom_right = collider_->getOffset() + collider_->getSize();
    }
    position_ = glm::clamp(position_, glm::vec2(0) - margin_top_left, game_.getCurrentScene()->getWorldSize() - margin_bottom_right);
}
```

这个改进考虑了角色的碰撞盒大小和位置，确保角色的碰撞盒完全在游戏世界内，而不仅仅是角色的中心点。

## 五、减少不必要的代码

代码简洁性对于维护和理解都很重要。我们删除了一些不必要的空行和默认构造函数/析构函数：

```cpp
// 修改前
class SceneMain: public Scene
{
    // ... 成员变量 ...
public:
    SceneMain() = default;
    virtual ~SceneMain() = default;

    // ... 方法 ...
};

// 修改后
class SceneMain: public Scene
{
    // ... 成员变量 ...
public:
    // ... 方法 ...
};
```

由于没有特殊的构造或析构需求，我们可以依赖编译器生成的默认版本。

## 六、改进方法的私有/公有访问控制

良好的封装是面向对象设计的核心原则之一。我们重新审视了各个类的方法，并根据它们的用途调整了访问控制：

### 1. HUDButton类中的方法

```cpp
// 修改前
class HUDButton : public ObjectScreen 
{
    // ... 成员变量 ...
public:
    // ... 其他公有方法 ...
    void checkHover();
    void checkState();
};

// 修改后
class HUDButton : public ObjectScreen 
{
    // ... 成员变量 ...
public:
    // ... 其他公有方法 ...

private:
    void checkHover();
    void checkState();
};
```

`checkHover`和`checkState`是内部实现细节，不需要暴露给外部使用，因此改为私有方法。

### 2. Enemy类中的方法

```cpp
// 修改前
class Enemy : public Actor
{
    // ... 成员变量和枚举 ...
public:
    // ... 公有方法 ...
    void aim_target(Player* target);
    void checkState();
    void changeState(State new_state);
    void attack();
    void remove();
};

// 修改后
class Enemy : public Actor
{
protected:
    // ... 成员变量和枚举移至protected区域 ...
public:
    // ... 公有方法 ...
    // getters and setters
    Player* getTarget() { return target_; }
    void setTarget(Player* target) { target_ = target; }

private:
    void aim_target(Player* target);
    void checkState();
    void changeState(State new_state);
    void attack();
    void remove();
};
```

我们将敌人的状态枚举和内部实现方法移到了适当的访问控制区域，只留下必要的公有接口。

## 七、添加有用的注释

注释可以帮助其他开发者（包括未来的自己）理解代码的意图和工作方式。我们添加了一些有用的注释：

```cpp
// 在Weapon类中添加注释
// 这个类通常是用作基类，因此没有静态创建函数。使用时需创建具体的子类，例如 WeaponThunder

// 在ObjectAffiliate类中添加警告
void setScale(float scale);         // 注意：此函数每次调用都会对当前大小进行倍乘，不适于每帧调用

// 在Enemy类中添加解释
SpriteAnim* current_anim_ = nullptr;    // 这是个附加指针，不需要进行delete操作
```

这些注释解释了一些可能引起误解或误用的代码部分，帮助防止潜在的bug。

## 八、其他细节优化

除了上述主要改进外，我们还进行了一些其他的细节优化：

### 1. 添加更多的getter方法

为`HUDText`类添加了`getSize`方法，使外部代码能够查询文本元素的大小：

```cpp
glm::vec2 getSize() const { return size_; }
```

### 2. 虚函数声明的一致性

在`ObjectWorld`类中，我们将`takeDamage`方法从返回空语句的实现改为纯声明：

```cpp
// 修改前
virtual void takeDamage(float) { return; }

// 修改后
virtual void takeDamage(float) {}
```

这种方式更清晰地表明这是一个需要被子类重写的方法。

### 3. 更好的函数组织

我们重新组织了一些类的函数声明顺序，将相关的函数放在一起：

```cpp
// WeaponThunder类
static WeaponThunder* addWeaponThunderChild(Actor* parent, float cool_down, float mana_cost);

virtual void init() override;
virtual bool handleEvents(SDL_Event& event) override;
virtual void update(float dt) override;
```

虚函数按照它们通常被调用的顺序排列，使代码更容易理解和跟踪。

## 总结

在这最后一课中，我们对游戏代码进行了全面的优化和完善：

1. **命名规范统一**：将不一致的命名（如`parrent_`）统一为正确的拼写（`parent_`）
2. **改进碰撞器设计**：更明确的类型命名和更安全的碰撞检测
3. **对象创建安全性**：添加空指针检查，防止因为空指针导致的崩溃
4. **边界碰撞改进**：考虑角色碰撞盒的大小，实现更准确的边界限制
5. **代码精简**：删除不必要的构造函数/析构函数和多余空行
6. **访问控制优化**：将内部实现方法设为私有，改进类的封装
7. **添加有用注释**：解释复杂逻辑和潜在的使用陷阱
8. **其他细节优化**：添加getter方法、改进虚函数声明、优化函数组织等

这些优化虽然看起来是小改动，但对于代码的长期维护、扩展和稳定性都有重要意义。良好的代码不仅能正确工作，还应当易于理解、易于修改和易于扩展。通过这些最后的完善，我们的游戏代码达到了更高的质量标准。

## 实践建议

在进行类似的代码优化时，可以考虑以下几点：

1. **使用静态代码分析工具**：如Clang-Tidy、Cppcheck等，它们可以自动检测一些常见的代码问题
2. **进行代码审查**：请其他开发者审查你的代码，他们可能发现你忽略的问题
3. **渐进式重构**：不要试图一次性修复所有问题，而是逐步改进，每次聚焦在一个方面
4. **编写单元测试**：确保你的修改不会破坏现有功能
5. **保持一致性**：遵循项目现有的代码风格和约定，除非你有充分的理由改变它们

通过持续的优化和完善，我们的游戏不仅功能完整，也达到了良好的代码质量，为未来的扩展和维护奠定了坚实的基础。
