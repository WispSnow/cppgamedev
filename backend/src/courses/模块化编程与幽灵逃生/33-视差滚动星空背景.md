# 视差滚动星空背景

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/YF9S4kEJvpU?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1pvdfYJEau&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们学习了如何实现二进制存档系统，使玩家的游戏数据能够持久保存。这一课，我们将为游戏增加一个美观的视觉效果——视差滚动星空背景。这种效果常见于2D游戏，能够为游戏增添深度感和沉浸感。

<img src="https://theorhythm.top/gamedev/GE/33-视差滚动星空背景截图.png" style='width: 800px;' />

## 一、什么是视差滚动

视差滚动（Parallax Scrolling）是一种模拟深度的视觉技术，通过让不同层次的背景以不同速度移动，创造出立体感和空间深度。这一技术最早应用于2D游戏，用来弥补2D游戏缺乏真实深度的不足。

### 1. 视差滚动的原理

视差滚动的基本原理来源于真实世界中的视差现象：

- 当我们移动时，近处的物体移动速度较快
- 远处的物体移动速度较慢
- 非常远的物体（如星空）几乎看不出移动

通过在游戏中模拟这种效果，我们可以在2D平面上创造出层次感和空间深度。

### 2. 视差滚动的应用场景

视差滚动在游戏中有广泛的应用：

- **横版游戏**：如《超级马里奥》，远处的山脉移动缓慢，近处的地面移动较快
- **太空游戏**：如《R-Type》，远处的星星几乎静止，近处的小行星快速移动
- **赛车游戏**：远处的建筑移动缓慢，近处的道路快速移动
- **RPG游戏**：多层次的背景元素以不同速度移动，增强场景深度

## 二、实现视差滚动星空的设计思路

为我们的游戏添加视差滚动星空背景，需要以下步骤：

1. 设计多层次的星星背景（远、中、近三层）
2. 为每层星星分配不同的移动速度（通过缩放相机位置实现）
3. 实现星星的绘制方法（使用点绘制而非精灵，提高性能）
4. 添加一些视觉效果（如星星颜色变化）

### 1. 设计BgStar类

我们将创建一个专门的`BgStar`类来实现星空背景：

```cpp
// bg_star.h
#ifndef BG_STAR_H
#define BG_STAR_H

#include "../core/object.h"

class BgStar : public Object {
protected:
    std::vector<glm::vec2> star_far_;    // 远处星星的位置
    std::vector<glm::vec2> star_mid_;    // 中等距离星星的位置
    std::vector<glm::vec2> star_near_;   // 近处星星的位置
    float scale_far_ = 0.2;              // 远处星星的移动比例
    float scale_mid_ = 0.5;              // 中等距离星星的移动比例
    float scale_near_ = 0.7;             // 近处星星的移动比例
    SDL_FColor color_far_ = {0, 0, 0, 1};  // 远处星星的颜色
    SDL_FColor color_mid_ = {0, 0, 0, 1};  // 中等距离星星的颜色
    SDL_FColor color_near_ = {0, 0, 0, 1}; // 近处星星的颜色
    float timer_ = 0;                     // 用于颜色动画
    int num_ = 2000;                      // 每一层的星星数量

public:
    static BgStar* addBgStarChild(Object* parent, int num, float scale_far, float scale_mid, float scale_near);
    virtual void update(float dt) override;
    virtual void render() override;

    // getters and setters
    float getScaleFar() const { return scale_far_; }
    void setScaleFar(float scale_far) { scale_far_ = scale_far; }
    float getScaleMid() const { return scale_mid_; }
    void setScaleMid(float scale_mid) { scale_mid_ = scale_mid; }
    float getScaleNear() const { return scale_near_; }
    void setScaleNear(float scale_near) { scale_near_ = scale_near; }
};

#endif // BG_STAR_H
```

这个类包含了三层星星的位置数据、移动比例和颜色，并且提供了创建、更新和渲染方法。

## 三、实现Game::drawPoints方法

为了高效地绘制大量星星，我们需要在`Game`类中添加一个绘制点集的方法：

```cpp
// game.h
class Game {
    // ... 已有代码 ...
public:
    // ... 已有方法 ...
    void drawPoints(const std::vector<glm::vec2>& points, glm::vec2 render_pos, SDL_FColor fcolor);
    // ... 已有方法 ...
};
```

```cpp
// game.cpp
void Game::drawPoints(const std::vector<glm::vec2> &points, glm::vec2 render_pos, SDL_FColor fcolor)
{
    SDL_SetRenderDrawColorFloat(renderer_, fcolor.r, fcolor.g, fcolor.b, fcolor.a);
    for (auto point : points){
        auto x = point.x + render_pos.x;
        auto y = point.y + render_pos.y;
        SDL_RenderPoint(renderer_, x, y);
    }
    SDL_SetRenderDrawColorFloat(renderer_, 0, 0, 0, 1);
}
```

这个方法使用SDL2的`SDL_RenderPoint`函数绘制一系列点，每个点都有相同的颜色。我们可以用这个方法高效地绘制大量星星，而不需要为每个星星创建精灵对象。

## 四、实现BgStar类

接下来，我们实现`BgStar`类的方法：

### 1. 添加星空背景

```cpp
// bg_star.cpp
#include "bg_star.h"
#include "../core/scene.h"

BgStar *BgStar::addBgStarChild(Object *parent, int num, float scale_far, float scale_mid, float scale_near)
{
    BgStar *bg_star = new BgStar();
    bg_star->init();
    bg_star->num_ = num;
    bg_star->scale_far_ = scale_far;
    bg_star->scale_mid_ = scale_mid;
    bg_star->scale_near_ = scale_near;
    bg_star->star_far_.reserve(num);        // 预先把内存分配好，以免后续重新分配
    bg_star->star_mid_.reserve(num);
    bg_star->star_near_.reserve(num);
    auto extra = Game::GetInstance().getCurrentScene()->getWorldSize() - Game::GetInstance().getScreenSize();
    for (auto i = 0; i < num; i++)
    {
        bg_star->star_far_.push_back(Game::GetInstance().randomVec2(glm::vec2(0), Game::GetInstance().getScreenSize() + extra * scale_far));
        bg_star->star_mid_.push_back(Game::GetInstance().randomVec2(glm::vec2(0), Game::GetInstance().getScreenSize() + extra * scale_mid));
        bg_star->star_near_.push_back(Game::GetInstance().randomVec2(glm::vec2(0), Game::GetInstance().getScreenSize() + extra * scale_near));
    }
    if (parent) parent->addChild(bg_star);
    return bg_star;
}
```

这个静态方法创建一个`BgStar`对象，并初始化三层星星。每层星星都在一个比屏幕略大的区域内随机分布，以确保当相机移动时，屏幕边缘不会出现没有星星的空白区域。

注意以下几点：
- 使用`reserve`预先分配内存，避免后续添加星星时重新分配内存，提高性能
- 使用`Game::randomVec2`生成随机位置
- 考虑了世界大小和屏幕大小的差异，确保星星覆盖整个可见区域

### 2. 更新星星状态

```cpp
// bg_star.cpp
void BgStar::update(float dt)
{
    // 更新颜色
    timer_ += dt;
    color_far_ = {0.5f + 0.5f*sinf(timer_*0.9f), 0.5f + 0.5f*sinf(timer_*0.8f), 0.5f + 0.5f*sinf(timer_*0.7f), 1};
    color_mid_ = {0.5f + 0.5f*sinf(timer_*0.8f), 0.5f + 0.5f*sinf(timer_*0.7f), 0.5f + 0.5f*sinf(timer_*0.6f), 1};
    color_near_ = {0.5f + 0.5f*sinf(timer_*0.7f), 0.5f + 0.5f*sinf(timer_*0.6f), 0.5f + 0.5f*sinf(timer_*0.5f), 1};
}
```

在`update`方法中，我们更新星星的颜色。通过使用正弦函数和计时器，我们让星星的颜色随时间缓慢变化，增加视觉上的生动感。每层星星使用稍微不同的颜色变化频率，以增加变化的多样性。

### 3. 渲染星空背景

```cpp
// bg_star.cpp
void BgStar::render()
{
    game_.drawPoints(star_far_, - game_.getCurrentScene()->getCameraPosition() * scale_far_, color_far_);
    game_.drawPoints(star_mid_, - game_.getCurrentScene()->getCameraPosition() * scale_mid_, color_mid_);
    game_.drawPoints(star_near_, - game_.getCurrentScene()->getCameraPosition() * scale_near_, color_near_);
}
```

`render`方法是视差滚动效果的关键。对于每层星星，我们计算出根据相机位置的偏移量，并将其传递给`drawPoints`方法。

关键点在于每层星星的偏移量是相机位置乘以不同的缩放因子：
- 远处星星：相机位置 * 0.2（移动较慢）
- 中等距离星星：相机位置 * 0.5（移动速度适中）
- 近处星星：相机位置 * 0.7（移动较快）

这种差异化的移动速度正是实现视差效果的核心。

## 五、在游戏中使用星空背景

最后，我们在游戏的主场景中添加星空背景：

```cpp
// scene_main.cpp
#include "raw/bg_star.h"

void SceneMain::init()
{
    // ... 已有代码 ...
    
    // 添加星空背景
    BgStar::addBgStarChild(this, 2000, 0.2, 0.5, 0.7);
    
    // ... 已有代码 ...
}
```

我们在主场景初始化时创建了一个`BgStar`对象，每层有2000个星星，缩放因子分别为0.2、0.5和0.7。

## 六、视差滚动的性能考虑

在实现视差滚动背景时，性能是一个重要考虑因素，尤其是当我们需要绘制大量对象时。以下是一些性能优化策略：

### 1. 使用点而非精灵

在我们的实现中，星星是以点的形式绘制的，而不是使用精灵。这大大提高了性能，因为：
- 点的绘制开销比精灵小得多
- 不需要为每个星星加载纹理
- 可以批量绘制大量点

### 2. 内存预分配

我们使用`reserve`预先为星星数组分配内存，避免在添加星星时反复进行内存分配，这可以减少内存碎片和提高性能。

### 3. 避免在渲染时修改数据

星星的位置在创建后就不再改变，我们只在渲染时根据相机位置计算偏移量。这避免了每帧更新大量星星位置的开销。

### 4. 视差比例的选择

视差比例的选择影响视觉效果的真实感。我们选择了0.2、0.5和0.7三个层次，这提供了良好的深度感，同时不会造成过大的视觉跳跃。

## 七、扩展与改进

以下是一些可能的扩展和改进方向：

### 1. 增加星星的闪烁效果

除了颜色变化，我们还可以添加大小变化，模拟星星的闪烁：

```cpp
// 示例代码：星星闪烁效果
void BgStar::render()
{
    // 使用额外的大小参数
    float size_far = 1.0f + 0.2f * sinf(timer_ * 0.5f);
    float size_mid = 1.0f + 0.3f * sinf(timer_ * 0.6f);
    float size_near = 1.0f + 0.4f * sinf(timer_ * 0.7f);
    
    // 绘制不同大小的点
    game_.drawSizedPoints(star_far_, - game_.getCurrentScene()->getCameraPosition() * scale_far_, color_far_, size_far);
    // ...其他层同理
}
```

### 2. 添加星星的淡入淡出

当玩家移动到新区域时，我们可以让新的星星淡入，增强过渡效果：

```cpp
// 示例代码：星星淡入淡出
void BgStar::update(float dt)
{
    // ... 已有代码 ...
    
    // 检查相机是否移动到新区域
    glm::vec2 current_camera = game_.getCurrentScene()->getCameraPosition();
    if (glm::distance(current_camera, last_camera_) > threshold_) {
        // 在新区域边缘添加新星星
        addNewStarsAtEdge(current_camera - last_camera_);
        last_camera_ = current_camera;
    }
}
```

### 3. 增加行星或彗星

除了普通星星，我们可以添加一些特殊的天体，如行星或彗星，增加背景的变化：

```cpp
// 示例代码：添加行星
void BgStar::init()
{
    // ... 已有代码 ...
    
    // 添加几个行星
    planets_.reserve(5);
    for (int i = 0; i < 5; i++) {
        Planet planet;
        planet.position = Game::GetInstance().randomVec2(glm::vec2(0), Game::GetInstance().getScreenSize());
        planet.size = Game::GetInstance().randomFloat(5.0f, 15.0f);
        planet.color = {Game::GetInstance().randomFloat(0.5f, 1.0f),
                       Game::GetInstance().randomFloat(0.5f, 1.0f),
                       Game::GetInstance().randomFloat(0.5f, 1.0f), 1.0f};
        planets_.push_back(planet);
    }
}
```

### 4. 星云或银河

可以添加一些星云或银河图案，作为背景的一部分：

```cpp
// 示例代码：添加星云
void BgStar::render()
{
    // ... 已有代码 ...
    
    // 渲染星云
    for (const auto& nebula : nebulas_) {
        game_.drawTexture(nebula.texture, nebula.position - game_.getCurrentScene()->getCameraPosition() * 0.1f,
                         nebula.size, nebula.rotation, nebula.color);
    }
}
```

## 总结

在本课中，我们学习了如何实现视差滚动星空背景：

1. **视差滚动概念**：了解了视差滚动的原理和应用场景
2. **设计BgStar类**：设计了一个专门的类来管理三层不同深度的星星
3. **实现点绘制方法**：在Game类中添加了高效绘制点集的方法
4. **创建随机星星**：在适当的区域内随机生成大量星星
5. **实现视差效果**：通过不同的缩放因子，让不同层次的星星以不同速度移动
6. **添加颜色动画**：让星星的颜色随时间变化，增加视觉效果
7. **性能优化**：使用点而非精灵、预分配内存等优化策略

视差滚动是增强2D游戏深度感的重要技术，通过本课的学习，我们为游戏添加了一个美观且高效的星空背景，大大提升了游戏的视觉效果和沉浸感。

## 练习

1. 修改星星的颜色变化逻辑，创造出不同的视觉效果
2. 实现星星的大小变化，模拟闪烁效果
3. 为不同层次的星星设置不同的数量，观察效果差异
4. 添加一些特殊天体，如行星、彗星或星云
5. 实现星星的动态生成和移除，使得当相机移动到新区域时，可以看到新的星星