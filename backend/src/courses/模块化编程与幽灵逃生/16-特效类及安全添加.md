# 特效类及安全添加

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/kuV9grCXxLE?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1w3o8YTEZq&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏开发中，特效是增强游戏视觉体验和提供反馈的重要元素。无论是技能释放、角色死亡还是环境变化，适当的视觉特效都能让游戏世界更加生动。在本课中，我们将设计和实现一个通用的特效类，并解决特效生命周期管理中的一些常见问题。

<img src="https://theorhythm.top/gamedev/GE/16-特效类.PNG" style='width: 800px;' />

## 特效系统的需求

在开始实现之前，我们需要明确特效系统的基本需求：

1. **临时性**：特效通常是短暂的，需要在播放完成后自动移除
2. **独立性**：特效应该是相对独立的对象，可以放置在游戏世界的任何位置
3. **序列性**：某些情况下，需要在一个特效结束后触发下一个事件或特效
4. **多样性**：支持不同的视觉效果，如爆炸、闪光、烟雾等
5. **易用性**：提供简单的接口，方便在游戏中添加各种特效

基于这些需求，我们将设计一个`Effect`类来实现特效功能。

## 一、创建特效类

### 特效类的设计

`Effect`类继承自`ObjectWorld`，这使得它可以放置在游戏世界的任何位置。它使用一个`SpriteAnim`组件来显示动画，并在动画结束后自动移除自身。此外，我们还添加了一个`next_object_`指针，用于在特效结束后添加另一个对象到场景中，这为实现特效链和序列事件提供了基础。

以下是`Effect`类的定义：

```cpp
// effect.h
#ifndef EFFECT_H
#define EFFECT_H

#include "../core/object_world.h"
#include "../affiliate/sprite_anim.h"
#include <string>

class Effect : public ObjectWorld
{
    SpriteAnim* sprite_ = nullptr;
    ObjectWorld* next_object_ = nullptr;        // 播放完毕后添加到场景中。

public:
    static Effect* addEffectChild(Object* parent, const std::string& file_path,glm::vec2 pos, float scale = 1.0f, ObjectWorld* next_object = nullptr);
    virtual void update(float dt) override;

    // setters and getters
    void setSpriteAnim(SpriteAnim* sprite) { sprite_ = sprite; }
    SpriteAnim* getSpriteAnim() { return sprite_; }
    void setNextObject(ObjectWorld* next_object) { next_object_ = next_object; }
    ObjectWorld* getNextObject() { return next_object_; }

private:
    void checkFinish();
};

#endif // EFFECT_H
```

### 特效类的实现

接下来，我们实现`Effect`类的核心功能：

```cpp
// effect.cpp
#include "effect.h"
#include "../core/scene.h"

Effect *Effect::addEffectChild(Object* parent, const std::string &file_path, glm::vec2 pos, float scale, ObjectWorld *next_object)
{
    auto effect = new Effect();
    effect->init();
    effect->sprite_ = SpriteAnim::addSpriteAnimChild(effect, file_path, scale);
    effect->sprite_->setLoop(false);
    effect->setPosition(pos);
    effect->setNextObject(next_object);
    if (parent) parent->addChild(effect);
    return effect;
}

void Effect::update(float dt)
{
    ObjectWorld::update(dt);
    checkFinish();
}


void Effect::checkFinish()
{
    if (sprite_->getFinish())
    {
        need_remove_ = true;
        if (next_object_){
            game_.getCurrentScene()->safeAddChild(next_object_);
        }
    }
}
```

让我们详细分析这些方法：

1. **addEffectChild**：静态工厂方法，创建并初始化一个特效对象。它设置特效的精灵动画、位置、缩放比例和下一个对象，然后将特效添加为父对象的子对象（如果父对象存在）。注意这里的`setLoop(false)`确保动画只播放一次。

2. **update**：在每一帧更新特效的状态，并检查是否已经完成。

3. **checkFinish**：检查精灵动画是否已经完成。如果完成，设置`need_remove_`标志以便在下一帧移除特效，并尝试添加`next_object_`到当前场景（如果存在）。

这个设计使得特效类具有以下特点：

- **自动销毁**：特效在播放完成后自动移除，无需手动管理
- **事件链**：支持在特效结束后触发下一个事件或添加下一个对象
- **灵活放置**：可以在游戏世界的任何位置创建特效
- **参数化**：可以通过参数控制特效的外观和行为

## 二、安全添加子节点

在实现特效类的过程中，我们发现了一个常见的问题：在迭代遍历一个容器的同时修改它可能导致未定义行为。特别是，如果我们在`update`方法中遍历`children_`容器的同时尝试添加或移除子对象，就可能出现问题。

为了解决这个问题，我们实现了一个"安全添加"机制：

```cpp
// object.h
class Object {
protected:
    std::vector<Object*> object_to_add_;
    std::vector<Object*> children_;
    // ... 其他成员

public:
    void safeAddChild(Object* child) { object_to_add_.push_back(child); }
    // ... 其他方法
};
```

然后，在`update`方法中，我们首先处理`object_to_add_`容器中的对象，然后再处理常规的`children_`容器：

```cpp
// object.cpp
void Object::update(float dt) {
    for (auto& child : object_to_add_) {
        addChild(child);
    }
    
    object_to_add_.clear();
    // ... 处理children_容器
}
```

这种设计使得我们可以在任何时候安全地添加子对象，而不用担心在遍历过程中修改容器导致的问题。这对于特效系统特别重要，因为特效往往需要在游戏运行时动态创建和销毁。

同时，我们也改进了对象销毁的过程，确保在删除对象后将指针设置为`nullptr`：

```cpp
// object.cpp
for (auto it = children_.begin(); it != children_.end();) {
    auto child = *it;
    if (child->getNeedRemove()){
        it = children_.erase(it);
        child->clean();
        delete child;
        child = nullptr;  // 避免悬空指针
    } else {
        // ... 处理活跃对象
    }
}
```

这样可以避免悬空指针的问题，提高代码的健壮性。

## 三、给玩家添加死亡特效

现在，我们已经有了特效类和安全添加机制，可以实现玩家死亡时的特效了。首先，我们需要在`Player`类中添加相关成员和方法：

```cpp
// player.h
#include "world/effect.h"

class Player : public Actor
{
    // ... 其他成员
    Effect* effect_ = nullptr;

public:
    // ... 其他方法
    void checkIsDead();
};
```

在`Player::init`方法中，我们初始化死亡特效，但暂时不添加到场景中：

```cpp
// player.cpp
void Player::init()
{
    Actor::init();
    sprite_idle_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-idle.png", 2.0f);
    sprite_move_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-move.png", 2.0f);
    sprite_move_->setActive(false);

    collider_ = Collider::addColliderChild(this, sprite_idle_->getSize() / 2.0f);
    stats_ = Stats::addStatsChild(this);
    effect_ = Effect::addEffectChild(nullptr, "assets/effect/1764.png", glm::vec2(0), 2.0f);
}
```

注意这里我们将`Effect::addEffectChild`的第一个参数设为`nullptr`，这意味着特效不会立即添加到任何父对象中。

然后，在`Player::update`方法中调用`checkIsDead`方法：

```cpp
// player.cpp
void Player::update(float dt)
{
    Actor::update(dt);
    handleInput();
    checkState();
    move(dt);
    syncCamera();
    checkIsDead();
}
```

最后，实现`checkIsDead`方法，在玩家死亡时触发特效：

```cpp
// player.cpp
void Player::checkIsDead()
{
    if (!stats_->getIsAlive()){
        game_.getCurrentScene()->safeAddChild(effect_);
        effect_->setPosition(getPosition());
        setActive(false);
    }
}
```

这个方法检查玩家是否存活，如果不存活，就将死亡特效添加到当前场景，设置特效的位置为玩家位置，并将玩家设为非活跃状态。

<img src="https://theorhythm.top/gamedev/GE/16-特效类截图.png" style='width: 800px;' />

要注意的是，方法名从原来的`isAlive`改为了`getIsAlive`，这是为了保持命名一致性，按照getter方法的命名规范。

### 特效链的应用

特效的`next_object_`功能允许我们在一个特效结束后自动添加另一个对象。这在创建复杂的视觉序列或游戏事件时非常有用。例如，在主场景初始化时，我们使用这个功能来在特效结束后添加敌人：

```cpp
// scene_main.cpp
void SceneMain::init()
{
    Scene::init();
    world_size_ = glm::vec2(1600.0f, 1200.0f);
    
    player_ = new Player();
    player_->init();
    player_->setPosition(world_size_ / 2.0f);
    addChild(player_);

    auto enemy = new Enemy();
    enemy->init();
    enemy->set_target(player_);
    enemy->setPosition(world_size_ / 2.0f + glm::vec2(200.0f));

    Effect::addEffectChild(this, "assets/effect/184_3.png", world_size_ / 2.0f + glm::vec2(200.0f), 1.0f, enemy);
}
```

这里，我们首先创建一个敌人对象，但不立即添加到场景中。然后，我们创建一个特效，将敌人作为`next_object_`参数传递。当特效播放完成后，敌人会自动添加到场景中，创造出敌人在特效中"出现"的视觉效果。

<img src="https://theorhythm.top/gamedev/GE/16-特效类截图2.png" style='width: 800px;' />

## 特效系统的优势

我们实现的特效系统具有以下优势：

1. **简单易用**：通过静态工厂方法可以方便地创建和放置特效
2. **自动管理**：特效会在播放完成后自动移除，无需手动清理
3. **扩展性强**：可以轻松添加新的特效类型和行为
4. **事件链支持**：可以在特效结束后触发下一个事件或添加新对象
5. **安全操作**：通过`safeAddChild`机制避免在遍历过程中修改容器导致的问题

## 应用场景

特效系统可以应用于多种游戏场景：

1. **技能效果**：显示角色技能释放和命中效果
2. **环境交互**：如踩踏地面产生的尘土、破坏物体产生的碎片等
3. **状态变化**：角色受伤、增益、减益状态的视觉提示
4. **转场效果**：场景切换、关卡开始和结束的视觉效果
5. **引导提示**：引导玩家注意特定区域或对象

## 总结

在本课中，我们实现了一个灵活的特效系统：

1. 创建了`Effect`类，支持自动播放和移除的动画特效
2. 实现了`safeAddChild`机制，解决了在游戏循环中安全添加对象的问题
3. 为玩家添加了死亡特效，增强了游戏的视觉体验
4. 通过特效链功能，实现了敌人的出场效果

特效系统是游戏视觉表现的重要组成部分，它不仅能增强游戏的视觉冲击力，还能提供重要的游戏反馈，帮助玩家理解游戏状态和事件。通过本课的学习，我们已经掌握了实现基本特效系统的方法，为游戏增添了更多视觉元素。

## 练习

1. **扩展特效类型**：创建新的特效类型，如爆炸、闪光、烟雾等
2. **特效触发器**：实现一个特效触发器系统，根据游戏事件自动触发相应特效
3. **特效序列**：创建一个特效序列系统，可以按顺序播放多个特效
4. **特效与游戏逻辑的交互**：使特效能影响游戏逻辑，如伤害特效实际造成伤害
5. **加入音效**：为特效添加对应的音效，增强游戏体验