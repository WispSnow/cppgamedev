# 计时器与死亡画面

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/4DIlpEjNiO4?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1uMd8YLE8y&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前面的课程中，我们实现了游戏的暂停/重启机制和事件穿透控制。本课将继续完善游戏体验，实现两个重要功能：计时器组件和死亡结束画面。一个好的游戏需要对玩家的生命周期有完整的管理，包括游戏结束时的体验，而计时器则是游戏中常用的功能组件，可以用于各种计时任务。

## 一、设计通用计时器组件

### 1. 计时器的需求分析

在游戏开发中，计时器是一个非常基础且常用的组件，它可以用于：

- 技能冷却时间控制
- 敌人生成间隔控制
- 动画效果计时
- 无敌时间控制
- 游戏结束后延迟显示界面

一个好的计时器组件应该满足以下要求：

1. **灵活可配置**：可以设置不同的时间间隔
2. **状态控制**：可以启动、停止和重置
3. **进度查询**：可以查询当前计时进度
4. **超时检测**：可以检测计时是否结束
5. **自动管理**：融入对象层次结构，便于管理

### 2. 实现Timer类

首先，我们定义`Timer`类的结构：

```cpp
// timer.h
#ifndef TIMER_H
#define TIMER_H

#include "../core/object.h"

class Timer : public Object         // 创建的时候，默认为 !active
{
protected:
    float timer_ = 0;               // 当前计时值
    float interval_ = 3.0f;         // 计时间隔
    bool time_out_ = false;         // 是否已超时
public:
    static Timer* addTimerChild(Object* parent, float interval = 3.0f);

    virtual void update(float dt) override;

    void start() { is_active_ = true; }     // 开始计时
    void stop() { is_active_ = false; }     // 停止计时
    bool timeOut();                         // 检查是否超时，并重置超时状态
    float getProgress() { return timer_ / interval_; }  // 获取进度（0-1）

    // getters and setters
    float getTimer() const { return timer_; }
    void setTimer(float timer) { timer_ = timer; }
    float getInterval() const { return interval_; }
    void setInterval(float interval) { interval_ = interval; }
};

#endif // TIMER_H
```

`Timer`类继承自`Object`，这使得它可以融入游戏的对象层次结构。它维护了当前的计时值、计时间隔和超时状态，并提供了一系列方法来控制和查询计时器状态。

接下来，我们实现`Timer`类的方法：

```cpp
// timer.cpp
#include "timer.h"

Timer* Timer::addTimerChild(Object* parent, float interval)
{
    Timer* timer = new Timer();
    timer->setInterval(interval);
    if (parent) parent->addChild(timer);
    timer->setActive(false);        // 创建时默认不激活
    return timer;
}

void Timer::update(float dt)
{
    timer_ += dt;                   // 累加时间
    if (timer_ >= interval_) {      // 检查是否达到间隔
        timer_ = 0;                 // 重置计时器
        time_out_ = true;           // 标记为超时
    }
}

bool Timer::timeOut()
{
    if (time_out_) {
        time_out_ = false;          // 读取后重置超时状态
        return true;
    }
    return false;
}
```

`Timer`类的实现非常直接：
- `addTimerChild` 是一个静态工厂方法，用于创建计时器并添加到父对象
- `update` 方法在每一帧更新计时器，当达到指定间隔时重置计时器并标记为超时
- `timeOut` 方法检查是否超时，并在读取后重置超时状态，确保每次超时只被处理一次

### 3. 在项目中应用计时器

我们需要将`Timer`类添加到项目构建系统中：

```cmake
# CMakeLists.txt
add_executable(${TARGET}
    # ... 其他源文件 ...
    src/raw/timer.cpp
    # ... 其他源文件 ...
)
```

## 二、实现闪烁无敌效果

玩家在受到伤害后通常会有一段短暂的无敌时间，我们可以使用计时器和视觉闪烁效果来表示这种状态。

### 1. 扩展Player类

首先，我们在`Player`类中添加一个闪烁计时器：

```cpp
// player.h
#include "world/effect.h"
#include "weapon_thunder.h"

class Timer;    // 前向声明

class Player : public Actor
{
    WeaponThunder* weapon_thunder_ = nullptr;
    SpriteAnim* sprite_idle_ = nullptr;
    SpriteAnim* sprite_move_ = nullptr;
    Effect* effect_ = nullptr;
    Timer* flash_timer_ = nullptr;    // 闪烁计时器
    bool is_moving_ = false;
    
    // ... 已有代码 ...
};
```

### 2. 初始化闪烁计时器

在`Player`类的`init`方法中，我们初始化闪烁计时器：

```cpp
// player.cpp
#include "raw/timer.h"

void Player::init()
{
    Actor::init();
    flash_timer_ = Timer::addTimerChild(this, 0.4f);  // 创建一个周期为0.4秒的计时器
    flash_timer_->start();  // 立即启动计时器
    
    // ... 已有代码 ...
}
```

这里我们创建了一个周期为0.4秒的计时器，用于控制闪烁效果。计时器被设置为循环运行，每0.4秒触发一次。

### 3. 实现闪烁渲染

在`Player`类的`render`方法中，我们根据无敌状态和闪烁计时器决定是否渲染玩家：

```cpp
// player.cpp
void Player::render()
{
    if (stats_->getInvincible() && flash_timer_->getProgress() < 0.5f){
        return;  // 如果处于无敌状态且计时器进度小于50%，则不渲染（实现闪烁效果）
    }
    Actor::render();  // 否则正常渲染
}
```

这里使用了一个简单但有效的技巧：当处于无敌状态时，只在计时器进度大于50%时渲染玩家，这就创造了一个闪烁效果。闪烁效果直观地表示玩家当前处于无敌状态。

## 三、实现死亡结束画面

当玩家死亡时，游戏不应该立即结束，而是应该提供一个死亡画面，让玩家了解游戏结果并决定下一步行动。

### 1. 在SceneMain中添加结束计时器

首先，我们在`SceneMain`类中添加一个结束计时器：

```cpp
// scene_main.h
class Timer;  // 前向声明

class SceneMain: public Scene
{
    // ... 已有成员 ...
    Timer* end_timer_ = nullptr;  // 结束计时器
    
    // ... 已有方法 ...
private:
    // ... 已有方法 ...
    void checkEndTimer();  // 检查结束计时器
};
```

### 2. 初始化结束计时器

在`SceneMain`类的`init`方法中，我们初始化结束计时器：

```cpp
// scene_main.cpp
#include "raw/timer.h"

void SceneMain::init()
{
    Scene::init();
    // ... 已有代码 ...
    
    end_timer_ = Timer::addTimerChild(this);  // 创建一个默认间隔的计时器
    
    // ... 已有代码 ...
}
```

### 3. 检测玩家死亡并启动计时器

在`SceneMain`类的`update`方法中，我们检测玩家是否已死亡，并在死亡时启动结束计时器：

```cpp
// scene_main.cpp
void SceneMain::update(float dt)
{
    Scene::update(dt);
    updateScore();
    checkButtonPause();
    checkButtonRestart();
    checkButtonBack();
    
    // 检查玩家是否已死亡，并启动结束计时器
    if (player_ && !player_->getActive()) end_timer_->start();
    checkEndTimer();  // 检查结束计时器状态
}
```

### 4. 实现死亡画面

接下来，我们实现`checkEndTimer`方法，在计时器超时时显示死亡画面：

```cpp
// scene_main.cpp
void SceneMain::checkEndTimer()
{
    if (!end_timer_->timeOut()) return;  // 如果计时器未超时，直接返回
    
    // 计时器超时，显示死亡画面
    pause();  // 暂停游戏
    
    // 放大并居中重启按钮
    button_restart_->setRenderPosition(game_.getScreenSize() / 2.0f - glm::vec2(200.f, 0.0f));
    button_restart_->setScale(4.0f);
    
    // 放大并居中返回按钮
    button_back_->setRenderPosition(game_.getScreenSize() / 2.0f + glm::vec2(200.f, 0.0f));
    button_back_->setScale(4.0f);
    
    // 隐藏暂停按钮
    button_pause_->setActive(false);
    
    // 停止计时器
    end_timer_->stop();
}
```

这个方法在结束计时器超时时执行以下操作：

1. 暂停游戏，停止所有游戏逻辑
2. 将重启按钮和返回按钮放大并移到屏幕中央
3. 隐藏暂停按钮，因为游戏已经结束
4. 停止结束计时器，避免重复触发

### 5. 为HUDButton添加缩放方法

为了支持按钮的缩放功能，我们需要在`HUDButton`类中添加`setScale`方法：

```cpp
// hud_button.h
void setScale(float scale);
```

```cpp
// hud_button.cpp
void HUDButton::setScale(float scale)
{
    sprite_normal_->setScale(scale);
    sprite_hover_->setScale(scale);
    sprite_press_->setScale(scale);
}
```

这个方法同时设置按钮所有状态精灵的缩放比例，确保按钮在所有状态下的大小一致。

### 6. 重置游戏状态

当玩家点击重启或返回按钮时，我们需要重置游戏状态：

```cpp
// scene_main.cpp
void SceneMain::checkButtonRestart()
{
    if (!button_restart_->getIsTrigger()) return;
    game_.setScore(0);  // 重置分数
    auto scene = new SceneMain();
    game_.safeChangeScene(scene);  // 安全切换到新场景
}

void SceneMain::checkButtonBack()
{
    if (!button_back_->getIsTrigger()) return;
    game_.setScore(0);  // 重置分数
    auto scene = new SceneTitle();
    game_.safeChangeScene(scene);  // 安全切换到标题场景
}
```

在重启和返回标题场景时，我们需要重置游戏分数，确保下一次游戏从零开始。

<img src="https://theorhythm.top/gamedev/GE/31-计时器与死亡画面截图.png" style='width: 800px;' />

## 四、计时器的其他应用场景

我们实现的`Timer`类非常灵活，可以应用于游戏中的许多场景：

### 1. 敌人生成控制

计时器可以用于控制敌人的生成频率：

```cpp
// 伪代码示例
class Spawner
{
    Timer* spawn_timer_ = nullptr;
    
    void init() {
        spawn_timer_ = Timer::addTimerChild(this, 2.0f);  // 每2秒生成一次敌人
        spawn_timer_->start();
    }
    
    void update(float dt) {
        if (spawn_timer_->timeOut()) {
            spawnEnemy();  // 生成敌人
        }
    }
};
```

### 2. 动画效果计时

计时器可以用于控制各种动画效果：

```cpp
// 伪代码示例
class AnimatedEffect
{
    Timer* anim_timer_ = nullptr;
    
    void init() {
        anim_timer_ = Timer::addTimerChild(this, 1.0f);  // 1秒动画周期
        anim_timer_->start();
    }
    
    void update(float dt) {
        float progress = anim_timer_->getProgress();
        // 根据进度设置动画参数
        scale_ = 1.0f + 0.5f * sin(progress * M_PI * 2);
    }
};
```

### 3. 游戏倒计时

计时器可以用于实现游戏倒计时：

```cpp
// 伪代码示例
class GameTimer
{
    Timer* game_timer_ = nullptr;
    float total_time_ = 60.0f;  // 60秒游戏时间
    
    void init() {
        game_timer_ = Timer::addTimerChild(this, total_time_);
        game_timer_->start();
    }
    
    void update(float dt) {
        if (game_timer_->timeOut()) {
            endGame();  // 时间到，结束游戏
        }
        
        // 显示剩余时间
        float remaining = total_time_ * (1.0f - game_timer_->getProgress());
        displayTime(remaining);
    }
};
```

## 总结

在本课中，我们实现了两个重要的游戏功能：

1. **通用计时器组件**：
   - 设计了灵活的`Timer`类，支持各种计时任务
   - 实现了计时器的启动、停止和超时检测功能
   - 提供了进度查询功能，便于创建基于时间的效果

2. **死亡结束画面**：
   - 实现了玩家死亡时的闪烁无敌效果
   - 添加了死亡后的结束计时器
   - 设计了死亡画面，放大并居中显示重启和返回按钮
   - 完善了游戏重启和返回标题的功能，确保游戏状态正确重置

这些功能大大提升了游戏的完整性和用户体验，为玩家提供了更加流畅和直观的游戏结束流程。计时器组件的实现也为游戏中的各种基于时间的功能提供了基础支持。

## 练习

1. 为游戏添加倒计时功能，限制玩家在一定时间内完成游戏
2. 实现一个带有视觉反馈的技能冷却系统，使用计时器控制冷却时间
3. 为敌人添加变色效果，当敌人受伤时闪烁红色
4. 设计一个更丰富的死亡画面，包括显示最终分数、游戏时间等信息
5. 实现一个关卡过渡效果，使用计时器控制淡入淡出