# 背景网格与视窗移动

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/h7RycRYRVOs?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1rvQnYcE9z&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了游戏的基础框架，包括Game类、精确的帧率控制和Scene场景类。这些为我们构建一个完整游戏提供了坚实的基础。然而，目前我们的游戏世界仅限于屏幕范围内，这对于许多游戏类型（如冒险游戏、RPG游戏或策略游戏）来说是远远不够的。

在本课中，我们将扩展我们的框架，实现两个重要功能：
1. 背景网格和边界 - 提供视觉参考和界定游戏世界范围
2. 视窗（相机）移动 - 允许玩家探索比屏幕更大的游戏世界

## 游戏世界与相机系统

在大多数游戏中，游戏世界的范围通常比屏幕显示区域要大得多。玩家通过"相机"或"视窗"来观察这个世界的一部分。这种设计有几个明显的优势：

1. **更大的游戏空间**：玩家可以探索更广阔的世界
2. **空间层次**：可以创建不同区域或场景供玩家探索
3. **游戏节奏控制**：可以通过世界设计来控制玩家的进度
4. **性能优化**：只需渲染玩家当前可见的区域

要实现这一点，我们需要：
- 定义一个比屏幕更大的世界空间
- 创建一个相机系统，决定显示世界的哪一部分
- 实现坐标转换，将世界坐标映射到屏幕坐标

### 世界坐标与屏幕坐标

在实现相机系统之前，我们需要明确两种坐标系：

- **世界坐标系（World Coordinates）**：对象在游戏世界中的实际位置
- **屏幕坐标系（Screen Coordinates）**：对象在屏幕上的渲染位置

它们之间的转换公式非常简单：
```
屏幕坐标X = 世界坐标X - 相机位置X
屏幕坐标Y = 世界坐标Y - 相机位置Y
```

这意味着，相机位置决定了世界中的哪一部分会显示在屏幕上。

## 在Game类中添加绘图工具

为了绘制背景网格和世界边界，我们需要在Game类中添加一些实用的绘图函数。这些函数将使用SDL的渲染功能，并提供一个简单的接口供Scene类使用。

首先，让我们向Game类添加必要的getter方法和绘图工具：

```cpp
// game.h中添加
public:
    // getters and setters
    glm::vec2 getScreenSize() const { return screen_size_; } // 获取屏幕大小

    // 工具函数
    void drawGrid(const glm::vec2& top_left, const glm::vec2& botton_right, float grid_width, SDL_FColor fcolor); // 绘制网格
    void drawBoundary(const glm::vec2& top_left, const glm::vec2& botton_right, float boundary_width, SDL_FColor fcolor); // 绘制边界
```

### 实现背景网格

背景网格是一种视觉辅助工具，可以帮助玩家了解游戏世界的尺度和自己的位置。在许多游戏（尤其是策略游戏）中，网格也是游戏机制的重要组成部分。

我们的`drawGrid`函数实现如下：

```cpp
void Game::drawGrid(const glm::vec2 &top_left, const glm::vec2 &botton_right, float grid_width, SDL_FColor fcolor)
{
    SDL_SetRenderDrawColorFloat(renderer_, fcolor.r, fcolor.g, fcolor.b, fcolor.a);
    for (float x = top_left.x; x <= botton_right.x; x += grid_width){
        SDL_RenderLine(renderer_, x, top_left.y, x, botton_right.y);
    }
    for (float y = top_left.y; y <= botton_right.y; y += grid_width){
        SDL_RenderLine(renderer_, top_left.x, y, botton_right.x, y);
    }
    SDL_SetRenderDrawColorFloat(renderer_, 0, 0, 0, 1);
}
```

这个函数的工作原理是：
1. 设置渲染器的绘制颜色（使用浮点值，范围0-1）
2. 绘制垂直网格线，从左到右等距分布
3. 绘制水平网格线，从上到下等距分布
4. 恢复渲染器颜色为黑色

函数参数解析：
- `top_left`：网格左上角在屏幕上的坐标
- `botton_right`：网格右下角在屏幕上的坐标
- `grid_width`：网格单元的宽度（像素）
- `fcolor`：网格线的颜色（RGBA浮点值）

注意我们使用的是SDL3中的`SDL_SetRenderDrawColorFloat`和`SDL_RenderLine`函数，这些是SDL3的新API，提供了更好的绘图功能。

### 实现世界边界

除了背景网格，我们还需要一种方法来标记游戏世界的边界。这不仅对玩家是有用的视觉提示，也可以作为碰撞检测的一部分。

我们的`drawBoundary`函数实现如下：

```cpp
void Game::drawBoundary(const glm::vec2 &top_left, const glm::vec2 &botton_right, float boundary_width, SDL_FColor fcolor)
{
    SDL_SetRenderDrawColorFloat(renderer_, fcolor.r, fcolor.g, fcolor.b, fcolor.a);
    for (float i = 0; i < boundary_width; i++){
        SDL_FRect rect = {
            top_left.x - i,
            top_left.y - i,
            botton_right.x - top_left.x + 2 * i,
            botton_right.y - top_left.y + 2 * i
        };
        SDL_RenderRect(renderer_, &rect);
    }
    SDL_SetRenderDrawColorFloat(renderer_, 0, 0, 0, 1);
}
```

这个函数的工作原理是：
1. 设置渲染器的绘制颜色
2. 绘制多个同心矩形，从边界向内和向外扩展，形成一定宽度的边界线
3. 恢复渲染器颜色为黑色

函数参数与`drawGrid`类似，但`boundary_width`表示边界线的厚度。

注意到我们使用的是`SDL_FRect`和`SDL_RenderRect`函数，允许绘制浮点精度的矩形，这是SDL3引入的另一个改进。

## 实现相机系统

有了绘图工具后，我们现在需要实现相机系统来控制视窗位置。在我们的框架中，`Scene`类已经包含了一个`camera_position_`成员变量，它表示相机在世界中的位置。

相机位置的实际意义是：**相机左上角在世界坐标系中的位置**。随着相机位置的变化，屏幕显示的世界部分也会相应变化。

### 在SceneMain中设置世界大小

首先，我们需要在`SceneMain`类中定义游戏世界的大小。这通常是屏幕大小的数倍：

```cpp
// scene_main.h
class SceneMain: public Scene
{
    glm::vec2 world_size_ = glm::vec2(0); // 世界大小
    // ... 其他成员 ...
};
```

然后在`init`方法中初始化世界大小：

```cpp
void SceneMain::init()
{
    world_size_ = game_.getScreenSize() * 3.0f; // 世界大小为屏幕的3倍
    camera_position_ = glm::vec2(-100.0f); // 初始相机位置
}
```

在这里，我们将世界大小设置为屏幕大小的3倍，这意味着玩家可以探索比屏幕大得多的区域。我们也将相机初始位置设置为(-100,-100)，这样世界的左上角不会直接与屏幕左上角对齐，给人一种更自然的感觉。

### 实现相机移动

为了演示相机系统的工作原理，我们将添加一个简单的相机移动逻辑：

```cpp
void SceneMain::update(float dt)
{
    camera_position_ += glm::vec2(10.0f, 10.0f) * dt; // 每秒向右下方移动10个单位
}
```

这段代码使相机以每秒10个单位的速度向右下方移动。注意我们使用`dt`（帧间隔时间）来确保移动速度与帧率无关。

### 渲染背景

现在我们已经有了世界大小和相机位置，可以实现背景渲染了：

```cpp
void SceneMain::renderBackground()
{
    auto start = - camera_position_;
    auto end = world_size_ - camera_position_;
    game_.drawGrid(start, end, 80.0f, {0.5, 0.5, 0.5, 1.0});
    game_.drawBoundary(start, end, 5.0f, {1.0, 1.0, 1.0, 1.0});
}

void SceneMain::render()
{
    renderBackground(); // 首先渲染背景
    // 其他渲染代码...
}
```

`renderBackground`方法的工作原理是：
1. 计算世界左上角和右下角在屏幕上的坐标
   - `start`是世界左上角(0,0)在屏幕上的坐标，等于-相机位置
   - `end`是世界右下角在屏幕上的坐标，等于世界大小-相机位置
2. 使用这些坐标调用`drawGrid`和`drawBoundary`函数
3. 网格宽度设为80像素，颜色为半透明灰色
4. 边界宽度为5像素，颜色为白色

这样，随着相机位置的变化，网格和边界的绘制位置也会相应变化，从而实现了视窗移动效果。

## 坐标转换详解

为了更好地理解相机系统，我们来详细解释一下坐标转换的数学原理：

1. **世界到屏幕坐标转换**:
   ```
   屏幕X = 世界X - 相机X
   屏幕Y = 世界Y - 相机Y
   ```

2. **屏幕到世界坐标转换**:
   ```
   世界X = 屏幕X + 相机X
   世界Y = 屏幕Y + 相机Y
   ```

这意味着：
- 当相机位置为(0,0)时，世界坐标和屏幕坐标重合
- 当相机向右移动时，世界在屏幕上向左移动
- 当相机向下移动时，世界在屏幕上向上移动

这与现实中的相机行为是一致的：相机向右移动时，视野中的景物向左移动。

### 示例分析

假设我们有以下设置：
- 屏幕大小: 1280x720
- 世界大小: 3840x2160 (屏幕的3倍)
- 相机位置: (100, 100)

那么：
- 世界坐标(0,0)会被渲染在屏幕坐标(-100,-100)，即屏幕之外
- 世界坐标(100,100)会被渲染在屏幕坐标(0,0)，即屏幕左上角
- 世界坐标(1380,820)会被渲染在屏幕坐标(1280,720)，即屏幕右下角
- 世界坐标(3840,2160)会被渲染在屏幕坐标(3740,2060)，即屏幕之外

这样，玩家只能看到世界的一部分，而相机的移动决定了这个可见部分是哪里。

## 优化与扩展

当前的实现是相机系统的基础版本，在实际游戏中，我们通常会添加更多功能：

### 1. 相机边界检查

当前，我们的相机可以移动到任何位置，甚至可以完全移出游戏世界。在实际应用中，我们通常会添加边界检查：

```cpp
void SceneMain::updateCamera(float dt)
{
    // 相机移动逻辑...
    
    // 边界检查
    camera_position_.x = std::max(0.0f, std::min(camera_position_.x, world_size_.x - game_.getScreenSize().x));
    camera_position_.y = std::max(0.0f, std::min(camera_position_.y, world_size_.y - game_.getScreenSize().y));
}
```

这确保了相机永远不会移出游戏世界，玩家总能看到有效的游戏内容。

### 2. 平滑移动

为了提供更好的用户体验，可以实现相机的平滑移动，而不是直接跳转：

```cpp
void SceneMain::updateCamera(float dt, const glm::vec2& target_position)
{
    // 使用线性插值实现平滑移动
    float smoothness = 5.0f; // 平滑系数，值越大移动越快
    camera_position_ += (target_position - camera_position_) * smoothness * dt;
    
    // 边界检查...
}
```

### 3. 相机跟随

在许多游戏中，相机会自动跟随玩家角色：

```cpp
void SceneMain::updateCamera(float dt)
{
    glm::vec2 target_position = player_position_ - game_.getScreenSize() * 0.5f + player_size_ * 0.5f;
    // 相机平滑移动到目标位置...
}
```

这样相机会将玩家保持在屏幕中央。

### 4. 视口缩放

更高级的相机系统还可以支持缩放功能：

```cpp
float camera_zoom_ = 1.0f; // 相机缩放因子

void SceneMain::render()
{
    // 设置缩放因子
    SDL_SetRenderScale(renderer_, camera_zoom_, camera_zoom_);
    
    // 计算缩放后的坐标...
    auto start = -camera_position_ * camera_zoom_;
    auto end = (world_size_ - camera_position_) * camera_zoom_;
    
    // 渲染...
}
```

## 总结

在本课中，我们实现了：

1. **背景网格和边界绘制**：提供视觉参考和定义游戏世界范围
2. **相机系统**：允许玩家探索比屏幕更大的游戏世界
3. **坐标转换**：将世界坐标正确映射到屏幕坐标

这些功能为构建复杂的2D游戏世界奠定了基础。在下一课中，我们将在此基础上添加游戏对象，开始构建真正的游戏内容。

## 练习

1. **实现键盘控制的相机移动**：修改SceneMain类，使玩家可以使用WASD键控制相机移动。

2. **添加相机边界检查**：确保相机不会移动到世界边界之外。

3. **实现缩放功能**：为相机系统添加缩放功能，允许玩家使用鼠标滚轮缩放视图。

4. **实现相机震动效果**：添加一个函数，可以在特定事件（如爆炸）发生时产生短暂的相机震动效果。