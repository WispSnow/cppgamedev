# 安全切换场景

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/aAkK6J7k8H4?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1RvdNYSE77&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了标题场景的按钮HUD，使玩家可以通过点击按钮与游戏进行交互。本课将着重解决游戏开发中的一个常见问题：如何安全地切换场景。我们将设计并实现一套安全的场景切换机制，避免在不恰当的时机切换场景导致的潜在问题。

## 一、场景切换中的挑战

在游戏开发中，场景切换是一个基本但容易出问题的操作。以下是直接切换场景可能面临的一些挑战：

1. **时机问题**：在游戏循环的某些阶段（如事件处理、更新或渲染过程中）切换场景可能导致不稳定性
2. **内存管理**：切换场景时需要正确释放旧场景的资源，避免内存泄漏
3. **初始化顺序**：新场景的初始化必须在旧场景完全清理后进行
4. **循环中断**：切换过程不应该打断游戏循环的正常执行
5. **异常处理**：若切换过程出现异常，游戏应能够恢复到一个稳定状态

## 二、设计安全的场景切换系统

为了解决上述挑战，我们设计了一个两阶段场景切换系统：

1. **标记阶段**：当需要切换场景时，仅标记需要切换到的新场景，但不立即执行切换
2. **执行阶段**：在游戏循环的安全点（通常是每帧开始时）检查是否有待切换的场景，若有则执行切换

这种方法的优势在于将切换请求与实际执行分离，确保场景切换发生在游戏循环的安全时刻。

## 三、实现安全的场景切换

### 1. 扩展Game类

首先，我们需要在`Game`类中添加一个变量来存储下一个场景：

```cpp
// game.h
class Game
{
    SDL_MouseButtonFlags mouse_buttons_ = 0;
    bool is_running_ = true; // 游戏是否运行
    Scene* current_scene_ = nullptr; // 当前场景
    Scene* next_scene_ = nullptr;    // 下一个场景（待切换）
    
    // ... 其他成员 ...
};
```

然后，添加两个场景切换相关的方法：

```cpp
// game.h
public:
    // ... 其他方法 ...
    
    void safeChangeScene(Scene* scene) { next_scene_ = scene; }  // 安全切换（标记阶段）
    void changeScene(Scene* scene);                              // 直接切换（执行阶段）
```

### 2. 实现直接切换方法

`changeScene`方法负责执行实际的场景切换操作：

```cpp
// game.cpp
void Game::changeScene(Scene *scene)
{
    if (current_scene_){
        current_scene_->clean();     // 清理当前场景
        delete current_scene_;       // 释放内存
    }
    current_scene_ = scene;          // 设置新场景
    current_scene_->init();          // 初始化新场景
}
```

这个方法确保了旧场景在被丢弃前先清理资源，新场景在被使用前先初始化。

### 3. 修改游戏循环

最关键的步骤是修改游戏循环，在每帧开始时检查是否需要切换场景：

```cpp
// game.cpp
void Game::run()
{
    while (is_running_){
        auto start = SDL_GetTicksNS();
        
        // 检查是否需要切换场景（安全点）
        if (next_scene_){
            changeScene(next_scene_);
            next_scene_ = nullptr;   // 重置下一场景指针
        }
        
        handleEvents();
        update(dt_);
        render();
        
        // ... 剩余的游戏循环代码 ...
    }
}
```

这确保了场景切换发生在处理任何游戏逻辑之前，是整个游戏循环中最安全的时刻。

## 四、在标题场景中应用安全切换

现在我们可以更新标题场景，添加"开始游戏"按钮的功能，安全地切换到主游戏场景：

```cpp
// scene_title.h
private:
    // ... 其他成员 ...
    void checkButtonStart();  // 检查开始游戏按钮
```

```cpp
// scene_title.cpp
#include "scene_main.h"  // 引入主游戏场景

void SceneTitle::init()
{
    Scene::init();
    // ... 创建文本显示 ...
    
    // 创建按钮
    button_start_ = HUDButton::addHUDButtonChild(this, 
        game_.getScreenSize() / 2.0f + glm::vec2(-200, 200), 
        "assets/UI/A_Start1.png",   // 正常状态
        "assets/UI/A_Start2.png",   // 悬停状态
        "assets/UI/A_Start3.png",   // 按下状态
        2.0f);                     // 缩放倍数
    // ... 其他按钮 ...
}

void SceneTitle::update(float dt)
{
    Scene::update(dt);
    color_timer_ += dt;
    updateColor();
    checkButtonQuit();
    checkButtonStart();  // 检查开始游戏按钮
}

void SceneTitle::checkButtonStart()
{
    if (button_start_->getIsTrigger()){
        auto scene = new SceneMain();
        game_.safeChangeScene(scene);  // 使用安全切换方法
    }
}
```

当玩家点击"开始游戏"按钮时，我们创建一个新的`SceneMain`实例，并使用`safeChangeScene`方法标记场景切换。实际的切换将在下一帧的开始执行。

## 五、安全切换的优势

这种安全切换场景的方法带来了多项优势：

1. **稳定性**：场景切换在游戏循环的安全点执行，减少错误和崩溃
2. **一致性**：确保场景的清理和初始化操作按顺序执行
3. **灵活性**：可以在游戏中的任何位置请求场景切换，而不必担心执行时机
4. **可预测性**：场景切换行为更加可预测，便于调试和维护
5. **扩展性**：这种机制可以扩展支持场景过渡效果、预加载和其他高级功能

## 总结

在本课中，我们设计并实现了一套安全的场景切换机制：

1. 通过两阶段设计（标记和执行）分离切换请求与实际执行
2. 确保场景切换在游戏循环的安全点（每帧开始时）执行
3. 正确管理场景的清理和初始化顺序
4. 在标题场景中应用安全切换，实现"开始游戏"按钮功能

这种安全的场景切换机制是构建稳定游戏的重要基础，它可以防止许多与时机相关的难以调试的问题，并为扩展更复杂的场景管理功能提供了坚实的基础。

## 练习

1. 实现场景间的淡入淡出过渡效果
2. 设计并实现场景栈，支持"返回上一场景"功能
3. 添加场景预加载功能，减少切换时的加载时间