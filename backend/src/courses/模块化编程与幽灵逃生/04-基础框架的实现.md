# 基础框架的实现

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/A5ZeMlIZC7A?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1WZQGYVEVi&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们设计了游戏框架的整体结构。从本课开始，我们将开始实际编写代码，实现这个框架的基础部分。首先，我们要实现的是Game类，它是整个游戏的核心控制器。

## Game类

Game类是我们游戏框架的中心，负责管理游戏的初始化、主循环和资源清理。在我们的设计中，Game类采用了**单例模式**（Singleton Pattern），确保整个游戏只有一个Game实例。

### 单例模式的实现

首先，我们来看Game类的头文件定义：

```cpp
#include <SDL3/SDL.h>
#include <SDL3_image/SDL_image.h>
#include <SDL3_mixer/SDL_mixer.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <glm/glm.hpp>
#include <string>   

class Game
{
    glm::vec2 screen_size_ = glm::vec2(0); // 屏幕大小
    bool is_running_ = true; // 游戏是否运行

    SDL_Window* window_ = nullptr; // 窗口
    SDL_Renderer* renderer_ = nullptr; // 渲染器

    // 私有构造函数
    Game(){}
    // 禁止拷贝构造函数与赋值操作符
    Game(const Game&) = delete;
    Game& operator=(const Game&) = delete;

public:
    static Game& GetInstance()
    {
        static Game instance;
        return instance;
    }

    void run(); // 运行游戏, 执行游戏主循环
    void init(std::string title, int width, int height); // 初始化游戏
    void handleEvents(); // 处理事件
    void update(float dt); // 更新游戏状态
    void render(); // 渲染游戏
    void clean(); // 清理游戏资源
};
```

实现单例模式的关键点：

1. **私有构造函数**：阻止外部直接创建实例
2. **禁用拷贝和赋值**：防止通过拷贝创建新实例
3. **静态获取实例方法**：提供唯一途径获取Game实例

这种实现方式称为"Meyer's Singleton"，它是线程安全的，并且只在首次调用`GetInstance()`时才创建实例。

### 游戏初始化

Game类的`init`方法负责初始化SDL及其扩展库，创建窗口和渲染器：

```cpp
void Game::init(std::string title, int width, int height)
{
    screen_size_ = glm::vec2(width, height);
    // SDL3初始化
    if (!SDL_Init(SDL_INIT_AUDIO | SDL_INIT_VIDEO)){
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL初始化失败: %s\n", SDL_GetError());
    }
    // 不需要进行SDL_image初始化
    // SDL3_Mixer初始化
    if (Mix_Init(MIX_INIT_MP3 | MIX_INIT_OGG) != (MIX_INIT_MP3 | MIX_INIT_OGG)){
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_Mixer初始化失败: %s\n", SDL_GetError());
    }
    if (!Mix_OpenAudio(0, NULL)){
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_Mixer打开音频失败: %s\n", SDL_GetError());
    }
    Mix_AllocateChannels(16); // 分配16个音频通道
    Mix_VolumeMusic(MIX_MAX_VOLUME / 4); // 设置音乐音量
    Mix_Volume(-1, MIX_MAX_VOLUME / 4); // 设置音效音量

    // SDL3_TTF初始化
    if (!TTF_Init()){
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "SDL_TTF初始化失败: %s\n", SDL_GetError());
    }
    // 创建窗口与渲染器
    SDL_CreateWindowAndRenderer(title.c_str(), width, height, SDL_WINDOW_RESIZABLE, &window_, &renderer_);
    if (!window_ || !renderer_){
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "创建窗口或渲染器失败: %s\n", SDL_GetError());
    }
    // 设置窗口逻辑分辨率
    SDL_SetRenderLogicalPresentation(renderer_, width, height, SDL_LOGICAL_PRESENTATION_LETTERBOX);
}
```

初始化过程的主要步骤：

1. **记录屏幕尺寸**：保存为`glm::vec2`类型，便于后续使用
2. **初始化SDL**：仅启用音频和视频功能
3. **初始化SDL_Mixer**：设置音频格式、分配通道、调整音量
4. **初始化SDL_TTF**：为文本渲染做准备
5. **创建窗口和渲染器**：使用SDL3的`SDL_CreateWindowAndRenderer`函数一次性创建两者
6. **设置逻辑分辨率**：确保在不同尺寸的窗口中维持一致的渲染比例

特别注意`SDL_SetRenderLogicalPresentation`函数是SDL3新增的功能，它允许我们设置渲染器的逻辑分辨率，使得无论窗口如何调整大小，游戏内容都能保持正确的比例。

### 游戏主循环

Game类的`run`方法实现了游戏的主循环：

```cpp
void Game::run()
{
    while (is_running_){
        handleEvents();
        update(0.0f);
        render();
    }
}
```

主循环的基本流程：

1. **事件处理**：调用`handleEvents()`检查用户输入
2. **状态更新**：调用`update()`更新游戏状态（目前传入的时间增量为0）
3. **渲染**：调用`render()`绘制当前帧

游戏会一直运行，直到`is_running_`被设为`false`，这通常发生在用户关闭窗口或退出游戏时。

### 事件处理

`handleEvents`方法负责处理SDL事件：

```cpp
void Game::handleEvents()
{
    SDL_Event event;
    while (SDL_PollEvent(&event)){
        switch (event.type){
        case SDL_EVENT_QUIT:
            is_running_ = false;
            break;
        default:
            break;
        }
    }
}
```

目前的事件处理非常简单，只检测窗口关闭事件（SDL_EVENT_QUIT），并据此设置`is_running_`为`false`来结束游戏。随着游戏开发的深入，我们将在这里添加更多的事件处理逻辑。

### 更新与渲染

`update`和`render`方法当前是空实现，我们将在后续课程中逐步完善它们：

```cpp
void Game::update(float dt)
{
}

void Game::render()
{
}
```

`update`方法将负责更新游戏状态，处理游戏逻辑，而`render`方法将负责绘制游戏画面。

### 使用Game类

在main.cpp中，我们可以看到如何使用Game类：

```cpp
#include "game.h"

int main(int, char**) {
    auto& game = Game::GetInstance();
    game.init("GhostEscape", 1280, 720);
    game.run();
    return 0;
}
```

使用过程非常简洁：

1. 获取Game单例实例
2. 初始化游戏，设置标题和窗口尺寸
3. 启动游戏主循环

### 优势分析

这种设计有以下几个优点：

1. **单一责任**：Game类专注于游戏循环和基础环境的管理
2. **全局访问**：通过单例模式，可以在任何地方访问Game实例
3. **资源集中管理**：窗口、渲染器等核心资源集中在Game类中管理
4. **扩展性好**：为后续添加场景系统和游戏对象做好了准备

### CMake配置

在CMakeLists.txt中，我们可以看到项目的构建配置：

```cmake
# 添加可执行文件
add_executable(${TARGET} 
                src/game.cpp
                src/main.cpp)
```

目前，项目只包含两个源文件：game.cpp和main.cpp。随着项目的发展，我们将添加更多的源文件。

## 更加精确地稳定帧率

在《SDL与太空战机》教程的第12课"让速度不受帧率影响"中，我们已经学习了基于时间的游戏更新的重要性。在那个教程中，我们使用了SDL2的毫秒级时间控制函数（如`SDL_GetTicks()`和`SDL_Delay()`）来实现稳定的帧率。本节课我们将借助SDL3提供的纳秒级精度功能，实现更加精确的帧率控制。

### 回顾：SDL2中的帧率控制

在之前的教程中，我们是这样实现帧率控制的：

```cpp
// SDL2版本（《SDL与太空战机》第12课）
void Game::run()
{
    while (isRunning)
    {
        auto frameStart = SDL_GetTicks();  // 毫秒级时间戳
        
        // 游戏逻辑...
        
        auto frameEnd = SDL_GetTicks();
        auto diff = frameEnd - frameStart;
        
        if (diff < frameTime){
            SDL_Delay(frameTime - diff);  // 毫秒级延迟
            deltaTime = frameTime / 1000.0f;
        }
        else{
            deltaTime = diff / 1000.0f;
        }
    }
}
```

这种方法有几个限制：

1. **时间精度限制**：`SDL_GetTicks()`只提供毫秒级精度（1/1000秒），对于要求高精度的游戏可能不够
2. **延迟精度限制**：`SDL_Delay()`的实际延迟时间可能比请求的时间长，精度受操作系统调度影响
3. **计算精度限制**：毫秒到秒的转换（除以1000）可能引入浮点误差

### SDL3的纳秒级精度

SDL3引入了纳秒级的时间控制函数，将时间精度提高了1,000,000倍（从毫秒到纳秒）：

- **SDL_GetTicksNS()**：返回纳秒级精度的时间戳（10^-9秒）
- **SDL_DelayNS()**：纳秒级精度的延迟函数

这些新函数使我们能够实现更加精确的帧率控制，尤其是对于高帧率游戏（如120FPS或更高）。

### 帧率控制相关变量

首先，我们在Game类中添加几个与帧率控制相关的变量：

```cpp
class Game
{
    // ... 其他代码 ...
    
    Uint64 FPS_ = 60; // 游戏帧率
    Uint64 frame_delay_ = 0; // 帧延迟，单位ns
    float dt_ = 0.0f; // 帧间隔
    
    // ... 其他代码 ...
};
```

这些变量的作用：

- **FPS_**：目标帧率，我们设定为60帧/秒
- **frame_delay_**：每帧应该持续的时间（纳秒），用于控制帧率
- **dt_**：实际的帧间隔时间（秒），用于游戏逻辑更新

注意与SDL2版本的区别：我们现在使用`Uint64`类型来存储纳秒级的时间值，因为纳秒级数值可能非常大。

### 初始化帧率控制

在`init`方法的末尾，我们添加了计算帧延迟的代码：

```cpp
void Game::init(std::string title, int width, int height)
{
    // ... 其他初始化代码 ...
    
    // 计算帧延迟（纳秒级）
    frame_delay_ = 1000000000 / FPS_;
}
```

这里使用`1000000000`（10^9，即1秒的纳秒数）除以目标帧率，得到每帧应该持续的纳秒数。相比SDL2版本中的`frameTime = 1000 / FPS`（毫秒级），精度提高了1,000,000倍。

### 改进游戏主循环

最关键的改进是在游戏主循环中实现纳秒级的时间控制：

```cpp
void Game::run()
{
    while (is_running_){
        auto start = SDL_GetTicksNS();  // 纳秒级时间戳
        handleEvents();
        update(dt_);  // 使用计算出的dt_更新游戏状态
        render();
        auto end = SDL_GetTicksNS();
        auto elapsed = end - start;
        if (elapsed < frame_delay_){
            SDL_DelayNS((frame_delay_ - elapsed));  // 纳秒级延迟
            dt_ = frame_delay_ / 1.0e9;  // 纳秒转换为秒
        }else{
            dt_ = elapsed / 1.0e9;  // 纳秒转换为秒
        }
        SDL_Log("FPS: %f", 1.0 / dt_);
    }
}
```

与SDL2版本相比，主要改进包括：

1. **纳秒级时间测量**：使用`SDL_GetTicksNS()`替代`SDL_GetTicks()`，精度提高1,000,000倍
2. **纳秒级延迟控制**：使用`SDL_DelayNS()`替代`SDL_Delay()`，延迟精度大幅提高
3. **更高精度的dt计算**：纳秒转换为秒（除以1.0e9）比毫秒转换为秒（除以1000.0）更精确
4. **实时将dt传递给update**：确保游戏逻辑使用最新的时间增量

这种实现不仅确保了更稳定的帧率，还提供了更精确的时间控制，对物理模拟和动画尤其重要。

### dt的重要性与应用

虽然我们目前的`update`方法还是空实现，但将`dt_`传递给它是至关重要的。在后续开发中，我们将使用dt来：

1. **控制移动速度**：物体移动距离 = 速度 × dt，确保移动与时间成正比而非帧率
2. **动画播放**：动画帧切换基于累积的时间而非帧数
3. **物理模拟**：使用dt计算物理状态变化，如位置、速度、加速度等
4. **技能冷却**：游戏技能的冷却时间基于实际经过的时间

例如，在未来的代码中，我们可能会这样更新玩家位置：

```cpp
// 速度单位是像素/秒，确保不管帧率如何，移动速度都一致
position.x += velocity.x * dt;
position.y += velocity.y * dt;
```

### 新旧方法的对比与优势

让我们对比SDL2和SDL3的帧率控制方法：

| 特性 | SDL2（毫秒级） | SDL3（纳秒级） |
|------|---------------|--------------|
| 时间精度 | 1/1000秒 | 1/1,000,000,000秒 |
| 适用场景 | 普通游戏（60FPS） | 高帧率游戏、精确物理模拟 |
| 延迟控制精度 | 中等 | 非常高 |
| dt计算精度 | 中等（毫秒→秒） | 高（纳秒→秒） |
| 对高性能设备的适应性 | 一般 | 更好 |

SDL3的纳秒级精度特别适合以下场景：

1. **高帧率游戏**：对于120FPS、144FPS或更高帧率的游戏，每帧时间很短，需要更精确的时间控制
2. **精确物理模拟**：物理引擎通常需要高精度的时间步长
3. **复杂动画**：精确的时间控制可以实现更平滑的动画过渡
4. **性能分析**：纳秒级精度允许更精确地测量代码性能

## Scene场景类

在上一课中，我们设计了一个多层次的游戏框架，其中Scene（场景）是连接Game和游戏对象的重要层次。现在我们将实现这一框架的下一部分：Scene场景类。

### 重构项目结构

首先，我们对项目结构进行了重组，采用了更合理的分层设计：

```
src/
├── core/           # 核心框架类
│   ├── game.h      # 游戏核心类
│   ├── game.cpp    
│   ├── object.h    # 所有对象的基类
│   └── scene.h     # 场景基类
├── scene_main.h    # 主场景类
├── scene_main.cpp  
└── main.cpp        # 程序入口
```

这种结构使得代码组织更加清晰，各个模块的职责划分更加明确。

### Object基类设计

在我们的框架中，所有可交互的游戏元素都继承自`Object`类。它定义了游戏对象的基本行为：

```cpp
#ifndef OBJECT_H
#define OBJECT_H

#include "game.h"

class Object {
protected:
    Game& game_ = Game::GetInstance();
public:
    Object() = default;
    virtual ~Object() = default;    // 所有的类，不在构造函数和析构函数里面做任何事。

    virtual void init() {}      // 需要初始化的事物，在init()函数里面做。
    virtual void handleEvents(SDL_Event& event) {}
    virtual void update(float dt) {}
    virtual void render() {}
    virtual void clean() {}     // 需要清理的资源，在clean()函数里面做。
};

#endif // OBJECT_H
```

`Object`类的关键特点：

1. **游戏引用**：持有Game单例的引用，便于访问游戏资源
2. **生命周期方法**：定义了初始化、更新、渲染和清理等方法
3. **事件处理**：提供了处理SDL事件的接口
4. **虚函数设计**：所有方法都是虚函数，允许子类重写这些行为

特别注意，我们遵循"构造函数和析构函数中不做任何具体工作"的原则，而是将初始化和清理操作分别放在`init()`和`clean()`方法中。这样设计更安全，也便于资源管理。

### Scene类设计

`Scene`类继承自`Object`，并扩展了管理场景中对象的功能：

```cpp
#ifndef SCENE_H
#define SCENE_H

#include "object.h"
#include <glm/glm.hpp>
#include <vector>

class Scene: public Object
{
protected:
    glm::vec2 camera_position_ = glm::vec2(0); // 相机位置
    std::vector<Object*> objects_; // 场景中的物体

public:
    Scene() = default;
    virtual ~Scene() = default;

    virtual void init() override {}
    virtual void handleEvents(SDL_Event& event) override {}
    virtual void update(float dt) override {}
    virtual void render() override {}
    virtual void clean() override {}
};

#endif // SCENE_H
```

`Scene`类的特点：

1. **相机系统**：拥有相机位置属性，未来将用于视口移动和世界坐标转换
2. **对象容器**：通过`std::vector<Object*>`管理场景中的所有游戏对象
3. **继承Object**：继承了Object的所有基本方法，场景本身也是一个游戏对象

### 具体场景：SceneMain

`SceneMain`是继承自`Scene`类的具体场景实现：

```cpp
#ifndef SCENE_MAIN_H
#define SCENE_MAIN_H

#include "core/scene.h"

class SceneMain: public Scene
{

public:
    SceneMain() = default;
    virtual ~SceneMain() = default;

    virtual void init() override;
    virtual void handleEvents(SDL_Event& event) override;
    virtual void update(float dt) override;
    virtual void render() override;
    virtual void clean() override;

};

#endif // SCENE_MAIN_H
```

```cpp
#include "scene_main.h"

void SceneMain::init()
{
}

void SceneMain::handleEvents(SDL_Event& event)
{
}

void SceneMain::update(float dt)
{
}

void SceneMain::render()
{
}

void SceneMain::clean()
{
}
```

现阶段，我们的`SceneMain`实现非常简单，所有方法都是空实现。在后续课程中，我们将逐步添加具体功能，如玩家控制、敌人生成、战斗逻辑等。

### 将Scene集成到Game中

最后，我们需要修改`Game`类，使其能够管理场景：

```cpp
// Game.h 中添加
class Scene;  // 前向声明
class Game
{
    // ... 其他成员 ...
    Scene* current_scene_ = nullptr; // 当前场景
    // ... 其他成员 ...
};
```

```cpp
// Game.cpp 中修改
#include "game.h"
#include "../scene_main.h"

void Game::init(std::string title, int width, int height)
{
    // ... 其他初始化代码 ...
    
    // 创建场景
    current_scene_ = new SceneMain();
    current_scene_->init();
}

void Game::handleEvents()
{
    SDL_Event event;
    while (SDL_PollEvent(&event)){
        switch (event.type){
        case SDL_EVENT_QUIT:
            is_running_ = false;
            break;
        default:
            current_scene_->handleEvents(event);
        }
    }
}

void Game::update(float dt)
{
    current_scene_->update(dt);
}

void Game::render()
{
    SDL_SetRenderDrawColor(renderer_, 0, 0, 0, 255);
    SDL_RenderClear(renderer_);
    current_scene_->render();
    SDL_RenderPresent(renderer_);
}

void Game::clean()
{
    if (current_scene_){
        current_scene_->clean();
        delete current_scene_;
    }
    
    // ... 其他清理代码 ...
}
```

关键的修改点包括：

1. **场景管理**：添加`current_scene_`成员变量持有当前活动场景
2. **创建场景**：在`init()`方法中创建`SceneMain`实例并初始化
3. **事件分发**：将事件分发给当前场景处理
4. **更新与渲染**：调用当前场景的`update()`和`render()`方法
5. **资源清理**：在`clean()`方法中清理场景资源

### 更新CMakeLists.txt

随着项目结构的变化，我们也需要更新CMakeLists.txt：

```cmake
# 添加可执行文件
add_executable(${TARGET} 
                src/core/game.cpp
                src/main.cpp
                src/scene_main.cpp
                )
```

### 设计优势与未来扩展

这种基于Object和Scene的设计有以下优势：

1. **模块化**：每个场景都是独立的模块，便于分工开发和代码管理
2. **易于扩展**：添加新场景只需创建新的Scene子类并实现相应方法
3. **资源管理**：场景可以管理其包含的所有对象，简化了资源分配和回收
4. **层次结构清晰**：Game → Scene → 游戏对象的层次结构简单明了
5. **事件处理灵活**：事件可以按层次传递，场景可以选择处理或忽略事件

在后续课程中，我们将逐步充实Scene的功能：

1. **对象自动挂载**：完善对象容器管理，实现对象自动添加和移除
2. **相机系统**：实现相机跟随和世界坐标与屏幕坐标转换
3. **场景切换**：实现不同场景间的平滑切换
4. **对象分层**：为场景添加分层渲染功能，控制绘制顺序

这种设计思路是现代游戏引擎的核心原则之一，它结合了面向对象和组件化的优点，为我们的游戏框架提供了坚实的基础。

## 练习

1. 扩展Game类，使其能够调整帧率