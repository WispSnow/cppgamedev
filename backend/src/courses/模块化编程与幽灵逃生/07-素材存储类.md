# 素材存储类

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/2mMaW2o-riQ?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1z9Q6YSE1q&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏开发中，资源管理是一个至关重要的部分。随着游戏复杂度的增加，我们需要加载和管理大量的资源，包括图像、音效、音乐和字体等。在上一课中，我们已经实现了玩家角色，但目前的渲染方式还比较简单，只是绘制了一个红色方块。为了实现更丰富的游戏体验，我们需要一个强大的资源管理系统。

## 资源管理的需求

在深入探讨我们的实现之前，让我们首先了解为什么需要资源管理系统，以及它应该具备哪些功能：

1. **避免重复加载** - 同一资源可能在多个地方使用，我们需要确保每个资源只被加载一次
2. **统一接口** - 提供统一的接口来加载和访问不同类型的资源
3. **资源释放** - 在适当的时候（如游戏结束时）释放所有资源，避免内存泄漏
4. **错误处理** - 优雅地处理加载失败的情况
5. **延迟加载** - 只在需要时加载资源，避免一次性加载所有资源导致启动时间过长

## AssetStore类的设计

针对上述需求，我们设计了`AssetStore`类来管理游戏中的所有资源。该类使用无序映射（unordered_map）来存储不同类型的资源，并提供加载和获取资源的方法。

### 类定义

```cpp
// asset_store.h
#ifndef ASSET_STORE_H
#define ASSET_STORE_H
#include <unordered_map>  //无序map
#include <SDL3/SDL.h>
#include <SDL3_image/SDL_image.h>
#include <SDL3_mixer/SDL_mixer.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <string>

class AssetStore
{
    SDL_Renderer *renderer_ = nullptr;
    std::unordered_map<std::string, SDL_Texture*> textures_;
    std::unordered_map<std::string, Mix_Chunk*> sounds_;
    std::unordered_map<std::string, Mix_Music*> music_;
    std::unordered_map<std::string, TTF_Font*> fonts_;

public:
    AssetStore(SDL_Renderer* renderer) { renderer_ = renderer; }
    ~AssetStore() = default;

    void clean();

    // 4个载入函数
    void loadImage(const std::string& file_path);
    void loadSound(const std::string& file_path);
    void loadMusic(const std::string& file_path);
    void loadFont(const std::string& file_path, int font_size);

    // 4个读取函数
    SDL_Texture* getImage(const std::string& file_path);
    Mix_Chunk* getSound(const std::string& file_path);
    Mix_Music* getMusic(const std::string& file_path);
    TTF_Font* getFont(const std::string& file_path, int font_size);
};

#endif // ASSET_STORE_H
```

这个类的核心组件包括：

1. **渲染器指针** - 用于加载图像资源
2. **资源映射表** - 四个不同的映射表，分别用于存储纹理、音效、音乐和字体
3. **资源加载方法** - 用于加载各种类型的资源
4. **资源获取方法** - 用于获取已加载的资源，如果资源尚未加载，则会先加载它
5. **资源清理方法** - 用于释放所有资源

### 为什么使用无序映射？

我们选择使用`std::unordered_map`而不是`std::map`的原因是：

1. **查找效率** - 无序映射的平均查找时间为O(1)，而有序映射为O(log n)
2. **不需要排序** - 我们不需要按照键的顺序访问资源
3. **内存效率** - 无序映射通常比有序映射需要更少的内存开销

## 资源加载的实现

现在让我们看看如何实现资源加载功能：

```cpp
// asset_store.cpp
void AssetStore::loadImage(const std::string &file_path)
{
    SDL_Texture *texture = IMG_LoadTexture(renderer_, file_path.c_str());
    if (texture == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to load image: %s", file_path.c_str());
        return;
    }
    // textures_[file_path] = texture;         // 可行，会覆盖之前的值。
    textures_.emplace(file_path, texture);   // 如果已经存在，则不会插入。
}

void AssetStore::loadSound(const std::string &file_path)
{
    Mix_Chunk *sound = Mix_LoadWAV(file_path.c_str());
    if (sound == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to load sound: %s", file_path.c_str());
        return;
    }
    sounds_.emplace(file_path, sound);
}

void AssetStore::loadMusic(const std::string &file_path)
{
    Mix_Music *music = Mix_LoadMUS(file_path.c_str());
    if (music == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to load music: %s", file_path.c_str());
        return;
    }
    music_.emplace(file_path, music);
}

void AssetStore::loadFont(const std::string &file_path, int font_size)
{
    TTF_Font *font = TTF_OpenFont(file_path.c_str(), font_size);
    if (font == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to load font: %s", file_path.c_str());
        return;
    }
    fonts_.emplace(file_path + std::to_string(font_size), font);
}
```

每个加载函数的工作流程：
1. 调用相应的SDL函数加载资源
2. 检查加载是否成功，如果失败则记录错误信息并返回
3. 将加载的资源添加到相应的映射表中

注意，我们使用`emplace`而不是`operator[]`来插入资源。`emplace`的优点是，如果键已经存在，它不会替换现有的值，从而避免了重复加载和内存泄漏的可能性。

### 字体加载的特殊处理

对于字体资源，我们需要考虑一个额外的参数：字体大小。同一个字体文件可以用不同的大小加载，所以我们使用`file_path + std::to_string(font_size)`作为键，确保可以加载同一字体的不同大小版本。

## 资源获取的实现

资源获取函数实现了"懒加载"模式，即如果请求的资源尚未加载，则会自动加载它：

```cpp
// asset_store.cpp
SDL_Texture *AssetStore::getImage(const std::string &file_path)
{
    auto iter = textures_.find(file_path);
    if (iter == textures_.end())        // 如果没有找到，则载入。
    {
        loadImage(file_path);
        iter = textures_.find(file_path);
    }
    if (iter == textures_.end())        // 如果载入失败，则返回空指针。
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to get image: %s", file_path.c_str());
        return nullptr;
    }
    return iter->second;
}

Mix_Chunk *AssetStore::getSound(const std::string &file_path)
{
    auto iter = sounds_.find(file_path);
    if (iter == sounds_.end())          // 如果没有找到，则载入。
    {
        loadSound(file_path);
        iter = sounds_.find(file_path);
    }
    if (iter == sounds_.end())          // 如果载入失败，则返回空指针。
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to get sound: %s", file_path.c_str());
        return nullptr;
    }
    return iter->second;
}

Mix_Music *AssetStore::getMusic(const std::string &file_path)
{
    auto iter = music_.find(file_path);
    if (iter == music_.end())           // 如果没有找到，则载入。
    {
        loadMusic(file_path);
        iter = music_.find(file_path);
    }
    if (iter == music_.end())           // 如果载入失败，则返回空指针。
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to get music: %s", file_path.c_str());
        return nullptr;
    }
    return iter->second;
}

TTF_Font *AssetStore::getFont(const std::string &file_path, int font_size)
{
    auto iter = fonts_.find(file_path + std::to_string(font_size));
    if (iter == fonts_.end())           // 如果没有找到，则载入。
    {
        loadFont(file_path, font_size);
        iter = fonts_.find(file_path + std::to_string(font_size));
    }
    if (iter == fonts_.end())           // 如果载入失败，则返回空指针。
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to get font: %s", file_path.c_str());
        return nullptr;
    }
    return iter->second;
}
```

每个获取函数的工作流程：
1. 尝试在映射表中查找请求的资源
2. 如果资源不存在，则调用相应的加载函数加载它
3. 再次检查资源是否成功加载，如果仍然失败，则记录错误并返回nullptr
4. 如果资源存在或成功加载，则返回它

这种"懒加载"策略有几个优点：
1. **按需加载** - 资源只在需要时才被加载，减少了初始加载时间
2. **自动检查** - 不需要手动检查资源是否已经加载
3. **统一接口** - 调用者只需要关心获取资源，不需要关心加载过程

## 资源清理

为了避免内存泄漏，我们需要在游戏结束时释放所有资源：

```cpp
// asset_store.cpp
void AssetStore::clean()
{
    for (auto &texture : textures_)
    {
        SDL_DestroyTexture(texture.second);
    }
    textures_.clear();

    for (auto &sound : sounds_)
    {
        Mix_FreeChunk(sound.second);
    }
    sounds_.clear();

    for (auto &music : music_)
    {
        Mix_FreeMusic(music.second);
    }
    music_.clear();

    for (auto &font : fonts_)
    {
        TTF_CloseFont(font.second);
    }
    fonts_.clear();
}
```

`clean`方法遍历每个映射表，释放所有资源，然后清空映射表。这个方法应该在游戏结束时调用，以确保所有资源都被正确释放。

## 与Game类的集成

为了使`AssetStore`成为我们游戏框架的一部分，我们需要将其集成到`Game`类中：

```cpp
// game.h
class Game
{
    AssetStore* asset_store_ = nullptr; // 资源管理器
    // ... 其他成员 ...

public:
    // ... 其他方法 ...
    AssetStore* getAssetStore() const { return asset_store_; } // 获取资源管理器
};
```

并在`Game`类的初始化和清理方法中相应地创建和释放`AssetStore`：

```cpp
// game.cpp
void Game::init(std::string title, int width, int height)
{
    // ... 其他初始化代码 ...

    // 创建资源管理器
    asset_store_ = new AssetStore(renderer_);

    // ... 其他初始化代码 ...
}

void Game::clean()
{
    // ... 其他清理代码 ...

    if (asset_store_){
        asset_store_->clean();
        delete asset_store_;
    }

    // ... 其他清理代码 ...
}
```

通过这种方式，`AssetStore`成为了`Game`类的一个组件，可以通过`Game::getAssetStore()`方法在整个游戏中访问。

## 使用AssetStore

现在我们可以使用`AssetStore`来加载和使用游戏资源。以下是一些使用示例：

### 加载和使用图像

```cpp
void Player::init()
{
    // 设置玩家属性
    max_speed_ = 500.0f;
    
    // 加载玩家纹理
    // 方法1：预先加载
    game_.getAssetStore()->loadImage("assets/player.png");
    
    // 方法2：直接获取（如果不存在会自动加载）
    SDL_Texture* playerTexture = game_.getAssetStore()->getImage("assets/player.png");
}

void Player::render()
{
    // 获取玩家纹理
    SDL_Texture* playerTexture = game_.getAssetStore()->getImage("assets/player.png");
    
    // 创建源和目标矩形
    SDL_Rect srcRect = {0, 0, 32, 32}; // 假设精灵表中的第一帧
    SDL_FRect destRect = {render_position_.x, render_position_.y, 32, 32};
    
    // 渲染纹理
    if (playerTexture) {
        SDL_RenderTexture(game_.getRenderer(), playerTexture, &srcRect, &destRect);
    } else {
        // 如果纹理加载失败，使用备用的渲染方法
        game_.drawBoundary(render_position_, render_position_ + glm::vec2(20.0f), 5.0f, {1.0, 0.0, 0.0, 1.0});
    }
}
```

### 加载和使用音效

```cpp
void Player::init()
{
    // ... 其他初始化代码 ...
    
    // 加载跳跃音效
    game_.getAssetStore()->loadSound("assets/jump.wav");
}

void Player::jump()
{
    // ... 跳跃逻辑 ...
    
    // 播放跳跃音效
    Mix_Chunk* jumpSound = game_.getAssetStore()->getSound("assets/jump.wav");
    if (jumpSound) {
        Mix_PlayChannel(-1, jumpSound, 0);
    }
}
```

### 加载和使用音乐

```cpp
void SceneMain::init()
{
    // ... 其他初始化代码 ...
    
    // 加载背景音乐
    game_.getAssetStore()->loadMusic("assets/background.mp3");
    
    // 播放背景音乐（循环）
    Mix_Music* backgroundMusic = game_.getAssetStore()->getMusic("assets/background.mp3");
    if (backgroundMusic) {
        Mix_PlayMusic(backgroundMusic, -1); // -1表示无限循环
    }
}
```

### 加载和使用字体

```cpp
void ScoreDisplay::render()
{
    // 获取字体
    TTF_Font* font = game_.getAssetStore()->getFont("assets/fonts/arial.ttf", 24);
    
    if (font) {
        // 创建文本表面
        SDL_Color color = {255, 255, 255, 255}; // 白色
        SDL_Surface* surface = TTF_RenderText_Solid(font, ("Score: " + std::to_string(score_)).c_str(), color);
        
        if (surface) {
            // 创建纹理
            SDL_Texture* texture = SDL_CreateTextureFromSurface(game_.getRenderer(), surface);
            
            if (texture) {
                // 渲染纹理
                SDL_FRect destRect = {10.0f, 10.0f, surface->w, surface->h};
                SDL_RenderTexture(game_.getRenderer(), texture, NULL, &destRect);
                
                // 释放纹理（因为这是临时创建的）
                SDL_DestroyTexture(texture);
            }
            
            // 释放表面
            SDL_DestroySurface(surface);
        }
    }
}
```

## 优化与扩展

我们的`AssetStore`类已经提供了基本的资源管理功能，对于本期课程的小型项目来说已经够用了。但它还有很多可以优化和扩展的地方，你可以尝试完成：

### 1. 资源预加载

目前，我们的资源管理系统使用"懒加载"策略，但有时我们可能希望预先加载某些资源，以避免在游戏过程中出现加载延迟。我们可以添加一个方法来一次性加载多个资源：

```cpp
void AssetStore::preloadResources(const std::vector<std::string>& imagePaths, 
                                  const std::vector<std::string>& soundPaths,
                                  const std::vector<std::string>& musicPaths)
{
    // 加载所有图像
    for (const auto& path : imagePaths) {
        loadImage(path);
    }
    
    // 加载所有音效
    for (const auto& path : soundPaths) {
        loadSound(path);
    }
    
    // 加载所有音乐
    for (const auto& path : musicPaths) {
        loadMusic(path);
    }
}
```

### 2. 资源卸载

目前，我们只有一个方法可以清理所有资源，但有时我们可能希望只卸载特定的资源，以释放内存。我们可以为每种资源类型添加单独的卸载方法：

```cpp
void AssetStore::unloadImage(const std::string& file_path)
{
    auto iter = textures_.find(file_path);
    if (iter != textures_.end()) {
        SDL_DestroyTexture(iter->second);
        textures_.erase(iter);
    }
}

// 类似地实现unloadSound, unloadMusic, unloadFont
```

### 3. 资源组管理

在大型游戏中，我们可能希望按照关卡或场景来组织资源，以便可以一次性加载或卸载一组相关的资源。我们可以添加一个资源组管理功能：

```cpp
// 在AssetStore类中添加
std::unordered_map<std::string, std::vector<std::string>> resource_groups_;

void AssetStore::addToGroup(const std::string& group_name, const std::string& resource_path)
{
    resource_groups_[group_name].push_back(resource_path);
}

void AssetStore::loadGroup(const std::string& group_name)
{
    auto iter = resource_groups_.find(group_name);
    if (iter != resource_groups_.end()) {
        for (const auto& path : iter->second) {
            // 根据文件扩展名判断资源类型并加载
            if (path.ends_with(".png") || path.ends_with(".jpg")) {
                loadImage(path);
            } else if (path.ends_with(".wav")) {
                loadSound(path);
            } else if (path.ends_with(".mp3")) {
                loadMusic(path);
            }
            // ... 处理其他资源类型 ...
        }
    }
}

void AssetStore::unloadGroup(const std::string& group_name)
{
    auto iter = resource_groups_.find(group_name);
    if (iter != resource_groups_.end()) {
        for (const auto& path : iter->second) {
            // 类似地，根据文件扩展名卸载资源
            // ...
        }
    }
}
```

## 总结

在本课中，我们实现了`AssetStore`类，它为我们的游戏框架提供了强大的资源管理功能：

1. **统一的资源管理** - 使用统一的接口管理不同类型的资源
2. **避免重复加载** - 确保每个资源只被加载一次
3. **懒加载策略** - 资源只在需要时才被加载
4. **错误处理** - 优雅地处理加载失败的情况
5. **资源清理** - 确保所有资源在游戏结束时被正确释放

这个资源管理系统是我们游戏框架的重要组成部分，它将为我们后续添加更多游戏元素提供便利。在下一课中，我们将使用这个系统来加载和管理游戏中的各种资源，为我们的游戏世界增添更多丰富的内容。

## 练习

1. 尝试完成“优化与扩展”这一节中提到的3种方法。