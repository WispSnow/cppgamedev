# 碰撞盒组件

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/_mkRza0D6-E?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1p6XkYcEcw&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏开发中，碰撞检测是一项核心功能，它使游戏中的对象能够相互交互。无论是检测玩家与敌人的接触、物体间的碰撞，还是判断子弹是否击中目标，碰撞检测都扮演着至关重要的角色。在本课中，我们将设计和实现一个碰撞盒组件，使游戏对象能够进行碰撞检测。

## 碰撞检测的重要性

碰撞检测在游戏中具有多种用途：

1. **物理交互**：当物体相互碰撞时产生反应，如弹跳、推动或破坏
2. **游戏机制触发**：当玩家接触到特定区域或物体时触发事件
3. **AI决策**：敌人可以根据与玩家的距离或碰撞情况做出决策
4. **范围检测**：检测某个范围内是否有特定对象，如技能范围

一个良好的碰撞检测系统应该具备以下特点：

1. **高效**：快速判断物体是否发生碰撞
2. **准确**：正确反映物体的形状和大小
3. **灵活**：支持不同形状的碰撞盒
4. **可调试**：便于开发者查看和调整碰撞盒

## 组件化设计

在我们的游戏中，采用组件化设计，将碰撞检测功能封装成独立的组件。这种方法有以下优势：

1. **解耦**：碰撞逻辑与游戏对象的其他功能分离
2. **复用**：同一碰撞组件可以应用于不同类型的游戏对象
3. **灵活性**：可以根据需要向对象添加或删除碰撞组件
4. **可测试性**：易于单独测试碰撞组件的功能

我们将碰撞盒设计为`ObjectAffiliate`的子类，遵循我们之前建立的对象附属系统。这使得碰撞盒可以附加到任何`ObjectScreen`类型的对象上。

## 碰撞器类设计

首先，我们设计一个`Collider`类，它继承自`ObjectAffiliate`：

```cpp
// collider.h
#ifndef COLLIDER_H
#define COLLIDER_H

#include "../core/object_affiliate.h"

class Collider : public ObjectAffiliate
{
protected:
    enum class Type{
        CIRCLE,         // size_ 的 x 轴为直径, 默认 y=x;
        RECTANGLE
    };
    Type type_ = Type::CIRCLE;

public:
    virtual void render() override;
    
    static Collider* addColliderChild(ObjectScreen* parent, glm::vec2 size, Type type = Type::CIRCLE);
    bool isColliding(Collider* other);

    // getters and setters
    Type type() const { return type_; }
    void setType(Type type) { type_ = type; }
};

#endif // COLLIDER_H
```

这个类定义了以下主要内容：

1. **碰撞器类型枚举**：当前支持圆形和矩形两种碰撞形状
2. **渲染方法**：用于可视化碰撞盒（仅在调试模式下）
3. **创建方法**：静态工厂方法用于创建并附加碰撞器
4. **碰撞检测方法**：检测与其他碰撞器是否相交
5. **访问器和修改器**：用于获取和设置碰撞器属性

## 碰撞器的实现

接下来，我们实现`Collider`类的方法：

```cpp
// collider.cpp
#include "collider.h"

void Collider::render()
{
#ifdef DEBUG_MODE
    ObjectAffiliate::render();
    auto pos = parrent_->getRenderPosition() + offset_;
    game_.renderFillCircle(pos, size_, 0.3);
#endif // DEBUG_MODE
}

Collider *Collider::addColliderChild(ObjectScreen *parent, glm::vec2 size, Type type)
{
    auto collider = new Collider();
    collider->init();
    collider->setParent(parent);
    collider->setSize(size);
    collider->setType(type);
    parent->addChild(collider);
    return collider;
}

bool Collider::isColliding(Collider *other)
{
    if (!other) return false;
    if (type_ == Type::CIRCLE && other->type_ == Type::CIRCLE)      // 两个圆的情况
    {
        auto point1 = parrent_->getPosition() + offset_ + size_ / 2.0f;
        auto point2 = other->parrent_->getPosition() + other->offset_ + other->size_ / 2.0f;
        return glm::length(point1 - point2) < (size_.x + other->size_.x) / 2.0f;
    }
    // TODO： 其它形状的碰撞检测
    return false;
}
```

让我们详细分析每个方法：

### render() 方法

```cpp
void Collider::render()
{
#ifdef DEBUG_MODE
    ObjectAffiliate::render();
    auto pos = parrent_->getRenderPosition() + offset_;
    game_.renderFillCircle(pos, size_, 0.3);
#endif // DEBUG_MODE
}
```

这个方法用于在屏幕上渲染碰撞盒，但只在定义了`DEBUG_MODE`宏的情况下才会执行。它调用`game_.renderFillCircle()`方法绘制一个半透明圆形，表示碰撞盒的位置和大小。这种可视化对于调试碰撞检测问题非常有用。

### addColliderChild() 静态方法

```cpp
Collider *Collider::addColliderChild(ObjectScreen *parent, glm::vec2 size, Type type)
{
    auto collider = new Collider();
    collider->init();
    collider->setParent(parent);
    collider->setSize(size);
    collider->setType(type);
    parent->addChild(collider);
    return collider;
}
```

这是一个静态工厂方法，用于创建碰撞器并将其附加到父对象。它执行以下步骤：

1. 创建一个新的`Collider`对象
2. 初始化碰撞器
3. 设置父对象、大小和类型
4. 将碰撞器添加为父对象的子对象
5. 返回创建的碰撞器

使用工厂方法模式使得创建和配置碰撞器变得简单，用户只需提供必要的参数即可。

### isColliding() 方法

```cpp
bool Collider::isColliding(Collider *other)
{
    if (!other) return false;
    if (type_ == Type::CIRCLE && other->type_ == Type::CIRCLE)      // 两个圆的情况
    {
        auto point1 = parrent_->getPosition() + offset_ + size_ / 2.0f;
        auto point2 = other->parrent_->getPosition() + other->offset_ + other->size_ / 2.0f;
        return glm::length(point1 - point2) < (size_.x + other->size_.x) / 2.0f;
    }
    // TODO： 其它形状的碰撞检测
    return false;
}
```

这个方法实现了碰撞检测逻辑。当前只实现了圆与圆之间的碰撞检测，后续可以扩展支持其他形状。圆与圆碰撞的原理是：

1. 计算两个圆心的位置（父对象位置 + 偏移 + 尺寸的一半）
2. 计算两圆心之间的距离
3. 如果距离小于两圆半径之和，则认为碰撞发生

## 添加调试支持

为了便于调试碰撞系统，我们添加了一些额外功能：

1. 在`defs.h`中定义`DEBUG_MODE`宏：

```cpp
// defs.h
#define DEBUG_MODE
```

2. 在`Game`类中添加渲染圆形的方法：

```cpp
// game.h
void renderFillCircle(const glm::vec2& position, const glm::vec2& size, float alpha);
```

```cpp
// game.cpp
void Game::renderFillCircle(const glm::vec2 &position, const glm::vec2& size, float alpha)
{
    auto texture = asset_store_->getImage("assets/UI/circle.png");
    SDL_FRect dst_rect = {
        position.x, position.y, size.x, size.y
    };
    SDL_SetTextureAlphaModFloat(texture, alpha);
    SDL_RenderTexture(renderer_, texture, NULL, &dst_rect);
}
```

这个方法使用半透明的圆形纹理渲染碰撞盒，使其在游戏中可见但不干扰正常游戏体验。

## 集成到游戏对象

我们需要在游戏对象中添加碰撞器支持。首先，在`ObjectWorld`类中添加碰撞器成员和相关方法：

```cpp
// object_world.h
class ObjectWorld : public ObjectScreen
{
protected:
    glm::vec2 position_ = glm::vec2(0, 0); // 世界位置
    Collider* collider_ = nullptr;

public:
    // ... 其他方法
    virtual glm::vec2 getPosition() const override { return position_; }
    // ... 其他方法
    Collider* getCollider() { return collider_; }
    void setCollider(Collider* collider) { collider_ = collider; }
};
```

我们在`ObjectScreen`类中添加了一个虚拟的`getPosition()`方法，以便`Collider`类可以访问其父对象的位置：

```cpp
// object_screen.h
class ObjectScreen : public Object
{
    // ... 其他成员和方法
    virtual glm::vec2 getPosition() const { return glm::vec2(0); }
};
```

## 应用到游戏对象

现在，我们可以在玩家和敌人中添加碰撞器：

### 在Player中添加碰撞器

```cpp
// player.cpp
void Player::init()
{
    Actor::init();
    sprite_idle_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-idle.png", 2.0f);
    sprite_move_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-move.png", 2.0f);
    sprite_move_->setActive(false);

    collider_ = Collider::addColliderChild(this, sprite_idle_->getSize());
}
```

我们在玩家初始化时创建一个与精灵大小相同的圆形碰撞器。

### 在Enemy中添加碰撞器

```cpp
// enemy.cpp
void Enemy::init()
{
    Actor::init();
    anim_normal_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-Sheet.png", 2.0f);
    anim_hurt_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghostHurt-Sheet.png", 2.0f);
    anim_die_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghostDead-Sheet.png", 2.0f);
    anim_hurt_->setActive(false);
    anim_die_->setActive(false);
    anim_die_->setLoop(false);

    current_anim_ = anim_normal_;
    collider_ = Collider::addColliderChild(this, current_anim_->getSize());
}
```

同样，我们为敌人添加了一个与其当前动画精灵大小相同的碰撞器。

## 实现碰撞交互

有了碰撞检测系统，我们可以实现游戏对象之间的交互。例如，在敌人中添加一个攻击方法，当与玩家碰撞时触发：

```cpp
// enemy.cpp
void Enemy::attack()
{
    if (!collider_ || target_->getCollider() == nullptr) return;
    if (collider_->isColliding(target_->getCollider())) {
        // TODO: attack
        SDL_Log("Circle vs Circle");
    }
}
```

在敌人的`update()`方法中调用这个攻击方法：

```cpp
void Enemy::update(float dt){
    Actor::update(dt);
    aim_target(target_);
    move(dt);
    attack();
}
```

当敌人与玩家发生碰撞时，控制台会输出"Circle vs Circle"信息。在实际游戏中，你可以在这里实现攻击逻辑，如减少玩家生命值、产生击退效果等。

## 命名规范修正

在这次更新中，我们还修正了一些命名问题，使代码更加一致：

1. 将`parrent`改为`parent`（更正拼写错误）：

```cpp
// object_affiliate.h
ObjectScreen *getParent() const { return parrent_; }
void setParent(ObjectScreen *parrent) { parrent_ = parrent; }
```

2. 在`Sprite`和`SpriteAnim`类的静态方法中也做了相应修改：

```cpp
// sprite.cpp
sprite->setParent(parrent);
```

```cpp
// sprite_anim.cpp
sprite_anim->setParent(parrent);
```

虽然成员变量名称仍然是`parrent_`（为了避免大规模代码修改），但接口方法名已更正，未来可以逐步统一。

## 碰撞系统的扩展

当前的碰撞系统只支持圆形碰撞盒和圆-圆碰撞检测，未来可以考虑以下扩展：

1. **矩形碰撞检测**：实现矩形与矩形、矩形与圆之间的碰撞检测
2. **碰撞回调**：在发生碰撞时触发回调函数
3. **碰撞分组**：定义碰撞组，控制哪些对象可以相互碰撞
4. **碰撞响应**：实现物理响应，如弹跳、滑动等
5. **空间分区**：使用四叉树等空间分区技术优化碰撞检测性能

## 调试碰撞盒

碰撞盒可视化对于调试非常重要。在我们的实现中，只要定义了`DEBUG_MODE`宏，碰撞盒就会在游戏中以半透明圆形显示。

<img src="https://theorhythm.top/gamedev/GE/13-碰撞盒组件截图.PNG" style='width: 800px;' />

这种可视化有助于：

1. 检查碰撞盒的大小是否合适
2. 验证碰撞盒是否正确跟随游戏对象
3. 观察碰撞检测是否在预期的位置触发
4. 调整碰撞盒参数以获得最佳游戏体验

## 总结

在本课中，我们实现了一个基本的碰撞检测系统：

1. 设计并实现了`Collider`类，作为游戏对象的附属组件
2. 实现了圆形碰撞盒及其碰撞检测算法
3. 将碰撞器集成到玩家和敌人对象中
4. 添加了碰撞盒可视化调试功能
5. 实现了基于碰撞的简单交互

碰撞检测是游戏开发中的基础功能，它使游戏世界中的对象能够相互感知和交互。通过组件化设计，我们的碰撞系统与游戏对象松耦合，可以灵活地应用于各种场景。

在下一课中，我们将基于这个碰撞系统，实现更复杂的游戏交互，如攻击、受伤和得分系统。

## 练习

1. **扩展碰撞形状**：实现矩形碰撞盒及矩形-矩形、矩形-圆的碰撞检测
2. **优化碰撞检测**：实现一个简单的空间分区系统，减少不必要的碰撞检测
3. **物理响应**：在碰撞发生时实现简单的物理响应，如反弹或推动