# 窗口缩放与游戏变速

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/kyvNg83UiR4?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1hhoNYjEc4&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们学习了如何实现视差滚动星空背景，为游戏添加了美观的视觉效果和空间深度感。本课将介绍两个增强游戏体验和可玩性的功能：窗口缩放适配和游戏变速。这些功能让玩家可以根据自己的喜好调整游戏窗口大小和游戏速度，提供更加个性化和灵活的游戏体验。

## 一、窗口缩放适配

在现代游戏中，窗口缩放是一项基本功能。用户通常希望能够根据自己的屏幕大小和偏好调整游戏窗口。然而，当游戏窗口被缩放时，我们需要解决几个关键问题：

1. **保持宽高比**：游戏画面不应该被拉伸变形
2. **鼠标坐标转换**：鼠标点击在缩放后的窗口中需要正确映射到游戏世界中
3. **UI 元素适配**：确保按钮、文本等 UI 元素在不同窗口尺寸下仍然可用

### 1. 保持宽高比

SDL2 提供了 `SDL_SetWindowAspectRatio` 函数来锁定窗口的宽高比。这样，无论用户如何调整窗口大小，游戏画面都不会变形：

```cpp
// game.cpp
void Game::updateMouse()
{
    mouse_buttons_ = SDL_GetMouseState(&mouse_position_.x, &mouse_position_.y);
    // 限制比例，不要出现黑边的做法
    int w, h;
    SDL_GetWindowSize(window_, &w, &h);
    SDL_SetWindowAspectRatio(window_, screen_size_.x/screen_size_.y, screen_size_.x/screen_size_.y);
    mouse_position_ *= screen_size_ / glm::vec2(w,h);

    // 保持黑边，不限制比例的做法
    // SDL_FRect rect;
    // SDL_GetRenderLogicalPresentationRect(renderer_, &rect);
    // mouse_position_ = (mouse_position_ - glm::vec2(rect.x, rect.y))  * screen_size_ / glm::vec2(rect.w, rect.h);
}
```

在这段代码中，我们：
1. 获取窗口的当前宽度和高度
2. 设置窗口的宽高比为我们游戏的原始宽高比
3. 这确保了无论用户如何拖拽窗口，窗口都会保持原始的宽高比

我们还在注释中提供了另一种处理方法：允许任意宽高比，但在窗口边缘添加黑边（类似于电影的宽屏模式）。这是通过 `SDL_GetRenderLogicalPresentationRect` 函数实现的，它会返回实际渲染内容的矩形区域。

### 2. 鼠标坐标转换

当窗口被缩放时，SDL 报告的鼠标坐标是基于实际窗口尺寸的，而我们的游戏逻辑是基于原始游戏尺寸的。所以我们需要转换鼠标坐标：

```cpp
mouse_position_ *= screen_size_ / glm::vec2(w,h);
```

这一行将鼠标坐标按比例缩放，使其与我们的游戏坐标系统匹配。例如，如果窗口尺寸是游戏原始尺寸的两倍，那么鼠标坐标也会被缩小一半。

### 3. 在游戏循环中使用更新后的鼠标处理

在游戏的主循环中，我们不再直接调用 `SDL_GetMouseState`，而是使用我们新的 `updateMouse` 方法：

```cpp
// game.cpp
void Game::update(float dt)
{
    // 旧代码
    // mouse_buttons_ = SDL_GetMouseState(&mouse_position_.x, &mouse_position_.y);
    
    // 新代码
    updateMouse();
    current_scene_->update(dt);
}
```

这个改变确保了无论窗口如何缩放，鼠标输入都能正确工作。

## 二、自定义鼠标指针

既然我们已经处理了窗口缩放，我们还可以进一步增强用户体验，添加自定义鼠标指针。游戏中使用自定义鼠标指针有几个好处：

1. 增强游戏的视觉一致性和主题感
2. 提供更明确的视觉反馈
3. 可以根据游戏上下文改变鼠标指针（例如，悬停在按钮上、点击时等）

在我们的游戏中，我们创建了一个 `UIMouse` 类来处理自定义鼠标指针：

```cpp
// scene_title.cpp
void SceneTitle::init()
{
    // ... 已有代码 ...
    
    // 隐藏系统鼠标指针
    SDL_HideCursor();
    
    // 创建自定义鼠标指针
    ui_mouse_ = UIMouse::addUIMouseChild(this, "assets/UI/pointer_c_shaded.png", "assets/UI/pointer_c_shaded.png", 1.0f, Anchor::TOP_LEFT);
}
```

我们首先通过 `SDL_HideCursor()` 隐藏系统的鼠标指针，然后创建自己的鼠标指针。这个自定义指针实际上是一个精灵，它会跟随真实鼠标移动。

在场景更新时，我们需要更新这个自定义鼠标指针：

```cpp
// scene_title.cpp
void SceneTitle::update(float dt)
{
    // ... 已有代码 ...
    
    if (credits_text_->getActive()) {
        ui_mouse_->update(dt);
        return;
    }
    
    // ... 已有代码 ...
}
```

通过这种方式，我们可以在游戏中拥有完全自定义的鼠标指针，与游戏风格保持一致。

## 三、游戏变速功能

在某些游戏场景中，玩家可能需要减慢游戏速度以应对复杂的情况或欣赏某些特效。我们实现了一个简单但有效的游戏变速功能：按住右键可以减慢游戏速度。

### 1. 实现减速功能

我们在 `SceneMain` 类中添加了一个 `checkSlowDown` 方法：

```cpp
// scene_main.cpp
void SceneMain::checkSlowDown(float &dt)
{
    if (game_.getMouseButtons() & SDL_BUTTON_RMASK){
        dt *= 0.4;
    }
}
```

这个方法检查玩家是否按下了鼠标右键（`SDL_BUTTON_RMASK`）。如果按下，它会将时间步长 `dt` 乘以 0.4，即减慢游戏速度至原来的 40%。

### 2. 在游戏循环中应用减速

在主场景的 `update` 方法中，我们在一开始就调用 `checkSlowDown`：

```cpp
// scene_main.cpp
void SceneMain::update(float dt)
{
    checkSlowDown(dt);
    Scene::update(dt);
    // ... 其他更新代码 ...
}
```

这样，如果玩家按住右键，传递给所有更新方法的 `dt` 值都会减小，从而使游戏运行速度减慢。

### 3. 注意 dt 的传递方式

注意 `checkSlowDown` 方法中，`dt` 参数是通过引用传递的：

```cpp
void SceneMain::checkSlowDown(float &dt)
```

这意味着对 `dt` 的修改会影响到原始值，而不是创建一个副本。这是必要的，因为我们希望减速效果影响到整个游戏。

## 四、优化按钮触发逻辑

在实现窗口缩放和自定义鼠标指针的过程中，我们还优化了按钮的触发逻辑：

```cpp
// hud_button.cpp
bool HUDButton::getIsTrigger()
{
    if (is_trigger_){
        is_trigger_ = false;
        is_press_ = false;
        is_hover_ = false;
        return true;
    }
    return false;
}
```

在这个优化中，当按钮被触发时，我们不仅重置 `is_trigger_` 状态，还同时重置 `is_press_` 和 `is_hover_` 状态。这确保了按钮在一次点击后完全重置其状态，防止可能的状态混乱，特别是在快速点击或窗口调整大小的情况下。

## 五、其他细节优化

除了主要的窗口缩放和游戏变速功能外，我们还进行了一些其他优化：

### 1. 关闭调试模式

我们注释掉了 `defs.h` 中的 `DEBUG_MODE` 定义，这会关闭游戏中的调试信息显示，使游戏界面更加干净：

```cpp
// defs.h
#ifndef DEFS_H
#define DEFS_H

// #define DEBUG_MODE  // 注释掉，关闭调试模式

enum class ObjectType
{
    // ...
};
```

### 2. 启用背景音乐

我们取消了对背景音乐的注释，使游戏有更好的音效体验：

```cpp
// scene_main.cpp
void SceneMain::init()
{
    Scene::init();
    SDL_HideCursor();
    game_.playMusic("assets/bgm/OhMyGhost.ogg");  // 启用背景音乐
    // ... 其他初始化代码 ...
}
```

### 3. 在游戏结束时恢复音乐

当游戏结束（玩家死亡）时，我们确保恢复音乐播放：

```cpp
// scene_main.cpp
void SceneMain::checkEndTimer()
{
    if (!end_timer_->timeOut()) return;
    pause();
    game_.resumeMusic();  // 恢复音乐播放
    // ... 其他代码 ...
}
```

这有助于维持游戏的音效连续性，即使在游戏暂停或结束时也不会突然安静。

## 总结

在本课中，我们学习了两个增强游戏体验的重要功能：

1. **窗口缩放适配**：
   - 使用 `SDL_SetWindowAspectRatio` 保持游戏画面的宽高比
   - 实现鼠标坐标的正确转换
   - 添加自定义鼠标指针，提升视觉一致性和用户体验

2. **游戏变速**：
   - 实现按住右键减慢游戏速度的功能
   - 学习如何通过修改时间步长 `dt` 来调整游戏运行速度
   - 了解变速对游戏体验的影响

此外，我们还了解了一些优化细节，如关闭调试模式、启用背景音乐和优化按钮触发逻辑等。

这些功能共同提升了游戏的可玩性和用户体验，让玩家有更多的自主控制权，可以根据自己的喜好和硬件情况调整游戏。

## 练习

1. 实现全屏/窗口模式切换功能
2. 添加多个游戏速度选项，如0.5倍、1倍、1.5倍和2倍速
3. 为自定义鼠标指针添加动画效果，如悬停、点击时的变化
4. 实现一个简单的游戏选项菜单，允许玩家调整窗口大小、音量和游戏速度