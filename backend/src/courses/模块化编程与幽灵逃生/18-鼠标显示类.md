# 鼠标显示类

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/h5svg6ai5NM?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1keo9YBESr&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏开发中，自定义鼠标光标是增强游戏视觉风格和用户体验的重要元素。默认的系统光标往往无法与游戏的美术风格相匹配，而自定义光标可以提供更加一致的视觉体验，并能实现特殊效果如动画、状态变化等。在本课中，我们将设计和实现一个自定义鼠标显示类，用来替代系统默认光标。

<img src="https://theorhythm.top/gamedev/GE/18-鼠标显示类.PNG" style='width: 800px;' />

## 游戏中自定义鼠标的意义

在游戏中实现自定义鼠标光标具有以下几个优势：

1. **美术一致性**：自定义光标可以与游戏的整体美术风格保持一致
2. **视觉反馈**：可以通过光标的变化提供直观的交互反馈
3. **动态效果**：实现光标动画、缩放、旋转等系统光标无法实现的效果
4. **功能指示**：根据游戏状态或玩家行为显示不同的光标样式，提示当前可执行的操作
5. **游戏沉浸感**：增强游戏的整体沉浸感和专业度

基于这些需求，我们将设计一个`UIMouse`类来实现自定义鼠标功能。

## 一、获取鼠标状态

为了实现自定义鼠标，我们首先需要能够获取鼠标的当前位置和按键状态。我们在`Game`类中添加相关功能：

```cpp
// game.h
class Game
{
    // ... 其他成员
    
    glm::vec2 mouse_position_ = glm::vec2(0);
    SDL_MouseButtonFlags mouse_buttons_ = 0;

public:
    // ... 其他方法
    
    glm::vec2 getMousePosition() const { return mouse_position_; }
    SDL_MouseButtonFlags getMouseButtons() const { return mouse_buttons_; }
};
```

然后，在游戏循环的每一帧中更新这些信息：

```cpp
// game.cpp
void Game::update(float dt)
{
    mouse_buttons_ = SDL_GetMouseState(&mouse_position_.x, &mouse_position_.y);
    current_scene_->update(dt);
}
```

这里我们使用SDL的`SDL_GetMouseState`函数来获取鼠标的当前位置和按键状态。这个函数将鼠标位置的x和y坐标分别写入提供的变量中，并返回一个表示当前按键状态的位掩码。

有了这些信息，我们就可以在游戏的任何部分获取和使用鼠标状态了。

## 二、设计鼠标显示类

接下来，我们设计一个专门用于显示自定义鼠标的类`UIMouse`。这个类继承自`ObjectScreen`，因为鼠标光标应该相对于屏幕坐标系进行定位，而不受游戏世界坐标系的影响。

```cpp
// ui_mouse.h
#ifndef UI_MOUSE_H
#define UI_MOUSE_H

#include "../core/object_screen.h"
#include "../affiliate/sprite.h"

class UIMouse : public ObjectScreen
{
protected:
    Sprite* sprite1_ = nullptr;
    Sprite* sprite2_ = nullptr;
    float timer_ = 0;
public:
    static UIMouse* addUIMouseChild(Object* parent, const std::string& file_path1, const std::string& file_path2, float scale = 1.0f, Anchor anchor = Anchor::CENTER);
    virtual void update(float dt) override;

    // setters and getters
    Sprite* getSprite1() const { return sprite1_; }
    Sprite* getSprite2() const { return sprite2_; }
    void setSprite1(Sprite* sprite) { sprite1_ = sprite; }
    void setSprite2(Sprite* sprite) { sprite2_ = sprite; }
};

#endif // UI_MOUSE_H
```

`UIMouse`类包含两个精灵组件`sprite1_`和`sprite2_`，它们将用于实现光标的动画效果。我们还添加了一个计时器`timer_`，用于控制精灵之间的切换。

静态方法`addUIMouseChild`用于创建和初始化`UIMouse`实例，而`update`方法则负责更新光标的位置和动画状态。

## 三、实现鼠标显示功能

接下来，我们实现`UIMouse`类的具体功能：

```cpp
// ui_mouse.cpp
#include "ui_mouse.h"

UIMouse *UIMouse::addUIMouseChild(Object *parent, const std::string &file_path1, const std::string &file_path2, float scale, Anchor anchor)
{
    auto ui_mouse = new UIMouse();
    ui_mouse->init();
    ui_mouse->sprite1_ = Sprite::addSpriteChild(ui_mouse, file_path1, scale, anchor);
    ui_mouse->sprite2_ = Sprite::addSpriteChild(ui_mouse, file_path2, scale, anchor);
    if (parent) parent->addChild(ui_mouse);
    return ui_mouse;
}

void UIMouse::update(float dt)
{
    timer_ += dt;
    if (timer_ < 0.3f) {
        sprite1_->setActive(true);
        sprite2_->setActive(false);
    } else if (timer_ < 0.6f) {
        sprite1_->setActive(false);
        sprite2_->setActive(true);
    } else {
        timer_ = 0;
    }
    setRenderPosition(game_.getMousePosition());
}
```

在`addUIMouseChild`方法中，我们创建并初始化了一个`UIMouse`实例，然后为它添加了两个精灵子组件，分别使用提供的两个图像路径。注意我们现在可以为精灵指定锚点，这样可以更精确地控制光标的定位。

在`update`方法中，我们做了两件主要的事情：
1. **更新动画**：通过计时器控制两个精灵的显示/隐藏状态，实现简单的帧动画效果
2. **更新位置**：将鼠标显示对象的渲染位置设置为当前鼠标位置

这样，我们的自定义鼠标光标就能够跟随实际鼠标移动，并显示动画效果。

## 四、集成到游戏场景中

最后，我们需要将自定义鼠标集成到游戏场景中，并隐藏系统默认光标：

```cpp
// scene_main.h
class UIMouse;
class SceneMain: public Scene
{
    Player* player_ = nullptr;
    Spawner* spawner_ = nullptr;
    UIMouse* ui_mouse_ = nullptr;
    // ... 其他成员
};
```

```cpp
// scene_main.cpp
#include "screen/ui_mouse.h"

void SceneMain::init()
{
    SDL_HideCursor(); // 隐藏系统默认光标
    world_size_ = game_.getScreenSize() * 3.0f;
    camera_position_ = world_size_ / 2.0f - game_.getScreenSize() / 2.0f;
    
    player_ = new Player();
    player_->init();
    player_->setPosition(world_size_ / 2.0f);
    addChild(player_);

    spawner_ = new Spawner();
    spawner_->init();
    spawner_->setTarget(player_);
    addChild(spawner_);

    ui_mouse_ = UIMouse::addUIMouseChild(this, "assets/UI/29.png", "assets/UI/30.png", 1.0f, Anchor::CENTER);
    
    // ... 其他初始化代码
}
```

这里我们首先调用SDL的`SDL_HideCursor`函数来隐藏系统默认光标，然后创建并初始化我们的自定义鼠标对象。注意我们使用了两个不同的图像来创建鼠标的动画效果，并指定了中心锚点，使光标精确定位在鼠标位置。

## 五、组件锚点的应用

在本课中，我们也扩展了组件创建方法，添加了锚点参数。这对于鼠标光标特别重要，因为我们通常希望光标的特定部分（如箭头的尖端）精确地定位在鼠标的实际位置。

以下是修改后的组件创建方法：

```cpp
// sprite.cpp
Sprite *Sprite::addSpriteChild(ObjectScreen *parrent, const std::string &file_path, float scale, Anchor anchor)
{
    auto sprite = new Sprite();
    sprite->init();
    sprite->setAnchor(anchor);
    sprite->setTexture(Texture(file_path));
    sprite->setScale(scale);
    sprite->setParent(parrent);
    return sprite;
}

// sprite_anim.cpp
SpriteAnim *SpriteAnim::addSpriteAnimChild(ObjectScreen *parrent, const std::string &file_path, float scale, Anchor anchor)
{
    auto sprite_anim = new SpriteAnim();
    sprite_anim->init();
    sprite_anim->setAnchor(anchor);
    sprite_anim->setTexture(Texture(file_path));
    sprite_anim->setScale(scale);
    sprite_anim->setParent(parrent);
    return sprite_anim;
}

// collider.cpp
Collider *Collider::addColliderChild(ObjectScreen *parent, glm::vec2 size, Type type, Anchor anchor)
{
    auto collider = new Collider();
    collider->init();
    collider->setAnchor(anchor);
    collider->setParent(parent);
    collider->setSize(size);
    collider->setType(type);
    return collider;
}
```

现在，我们可以在创建任何组件时指定锚点，这大大增强了定位的灵活性和精确性。

## 六、动画效果的实现

鼠标光标的动画效果增强了游戏的视觉吸引力和反馈。在我们的实现中，我们通过交替显示两个精灵来创建简单的帧动画：

```cpp
void UIMouse::update(float dt)
{
    timer_ += dt;
    if (timer_ < 0.3f) {
        sprite1_->setActive(true);
        sprite2_->setActive(false);
    } else if (timer_ < 0.6f) {
        sprite1_->setActive(false);
        sprite2_->setActive(true);
    } else {
        timer_ = 0;
    }
    setRenderPosition(game_.getMousePosition());
}
```

这段代码实现了以下动画逻辑：
1. 在0到0.3秒之间显示第一个精灵
2. 在0.3到0.6秒之间显示第二个精灵
3. 当计时器超过0.6秒时重置，形成循环动画

这种简单的动画效果可以使鼠标光标看起来更加生动，提供更好的视觉反馈。

## 总结

在本课中，我们实现了一个自定义鼠标显示系统：

1. 在`Game`类中添加了鼠标位置和按键状态的跟踪功能
2. 设计并实现了`UIMouse`类，用于显示自定义鼠标光标
3. 实现了简单的帧动画效果，使光标更加生动
4. 将自定义光标集成到游戏场景中，并隐藏系统默认光标
5. 扩展了组件创建方法，添加锚点参数以实现精确定位

自定义鼠标显示系统增强了游戏的视觉一致性和交互反馈，是现代游戏用户界面的重要组成部分。通过本课的学习，我们已经掌握了实现基本鼠标显示系统的方法，为游戏增添了更多交互元素。

## 练习

1. **状态光标**：扩展`UIMouse`类，实现根据游戏状态显示不同光标的功能
2. **光标特效**：为鼠标点击添加特效，如点击波纹、粒子效果等
3. **光标拖尾**：实现鼠标移动时的拖尾效果
4. **游戏交互**：实现鼠标与游戏对象的交互，如选择、指令等