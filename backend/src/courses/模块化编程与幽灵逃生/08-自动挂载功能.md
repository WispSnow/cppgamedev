# 自动挂载功能

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/gdljJ9AoB_0?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV14WQaYMEX2&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了资源管理系统，它为游戏对象提供了加载和使用各种资源的能力。然而，随着游戏对象数量的增加，如何有效地管理这些对象之间的关系变得越来越重要。在这一课中，我们将实现游戏对象的自动挂载功能，这是一种强大的设计模式，可以大大简化游戏对象的管理和交互。

## 对象挂载系统的需求

在一个典型的游戏中，对象之间通常存在各种层次关系。例如：

1. **场景包含多个游戏对象**（玩家、敌人、道具等）
2. **复杂对象可能由多个子对象组成**（例如，一个角色可能由身体、武器、装备等组成）
3. **UI系统中的层次结构**（窗口包含按钮，按钮包含文本等）

如果没有一个好的系统来管理这些关系，代码很快就会变得混乱和难以维护。每个对象都需要手动跟踪和更新它的子对象，场景需要维护一个所有对象的列表，还需要确保每个对象的生命周期方法（初始化、更新、渲染、清理）都被正确调用。

为了解决这些问题，我们设计了一个自动挂载系统:

<img src="https://theorhythm.top/gamedev/GE/08-自动挂载功能1.PNG" style='width: 800px;' />

<img src="https://theorhythm.top/gamedev/GE/08-自动挂载功能2.PNG" style='width: 800px;' />

它具有以下特点：

1. **父子关系**：对象可以有父对象和子对象
2. **自动递归**：生命周期方法会自动递归到所有子对象
3. **类型识别**：系统能够识别对象的类型，并进行适当的处理
4. **内存管理**：当父对象被销毁时，它的所有子对象也会被自动清理

## 对象类型系统

首先，我们需要一种方法来区分不同类型的对象，这样我们就可以根据对象的类型对它们进行不同的处理。我们定义了一个`ObjectType`枚举：

```cpp
// defs.h
enum class ObjectType
{
    NONE,
    OBJECT_SCREEN,
    OBJECT_WORLD,
};
```

这个枚举定义了三种基本类型：
- `NONE`：默认类型，没有特殊处理
- `OBJECT_SCREEN`：屏幕对象，在屏幕坐标系中定位
- `OBJECT_WORLD`：世界对象，在世界坐标系中定位

然后，我们在`Object`类中添加了一个`type_`成员变量，以及相应的getter和setter方法：

```cpp
// object.h
class Object {
protected:
    ObjectType type_ = ObjectType::NONE;
    // ...其他成员...
public:
    // ...其他方法...
    ObjectType getType() const { return type_; }
    void setType(ObjectType type) { type_ = type; }
};
```

每个派生类都应该在其初始化方法中设置适当的类型。例如：

```cpp
// object_screen.h
class ObjectScreen : public Object
{
protected:
    // ...其他成员...
    virtual void init() override {type_ = ObjectType::OBJECT_SCREEN;}
};

// object_world.h
class ObjectWorld : public ObjectScreen
{
public:
    virtual void init() override {type_ = ObjectType::OBJECT_WORLD;}
    // ...其他方法...
};
```

## 子对象管理

接下来，我们在`Object`类中添加了一个子对象列表，以及管理子对象的方法：

```cpp
// object.h
class Object {
protected:
    // ...其他成员...
    std::vector<Object*> children_;
public:
    // ...其他方法...
    virtual void addChild(Object* child) { children_.push_back(child); }
    virtual void removeChild(Object* child) {
        children_.erase(std::remove(children_.begin(), children_.end(), child), children_.end());
    }
};
```

这些方法允许我们向对象添加子对象，或者从中移除子对象。默认实现只是简单地修改`children_`列表，但派生类可以覆盖这些方法来提供更复杂的行为，正如我们稍后在`Scene`类中看到的那样。

## 生命周期方法的递归实现

有了子对象列表，我们现在可以实现生命周期方法的递归行为：

```cpp
// object.cpp
void Object::handleEvents(SDL_Event& event) {
    for (auto& child : children_) {
        child->handleEvents(event);
    }
}

void Object::update(float dt) {
    for (auto& child : children_) {
        child->update(dt);
    }
} 

void Object::render() {
    for (auto& child : children_) {
        child->render();
    }
}

void Object::clean() {
    for (auto& child : children_) {
        child->clean();
    }
    children_.clear();
}
```

这些方法的实现确保生命周期事件会自动传播到所有子对象。例如，当一个对象的`update`方法被调用时，它会先更新自己，然后调用每个子对象的`update`方法。

需要注意的是，我们在`clean`方法中不仅调用了每个子对象的`clean`方法，还清空了子对象列表。这确保了当一个对象被清理时，它的所有子对象也会被正确清理。

## 场景中的对象类型管理

场景是一个特殊的对象，它需要管理不同类型的对象。为了更有效地管理，我们在`Scene`类中添加了单独的容器来存储不同类型的对象：

```cpp
// scene.h
class Scene: public Object
{
protected:
    // ...其他成员...
    std::vector<ObjectWorld*> children_world_;
    std::vector<ObjectScreen*> children_screen_;
};
```

我们也覆盖了`addChild`和`removeChild`方法，根据对象的类型将其添加到正确的容器中：

```cpp
// scene.cpp
void Scene::addChild(Object *child)
{
    switch (child->getType())
    {
        case ObjectType::OBJECT_WORLD:
            children_world_.push_back(dynamic_cast<ObjectWorld *>(child));
            break;
        case ObjectType::OBJECT_SCREEN:
            children_screen_.push_back(dynamic_cast<ObjectScreen *>(child));
            break;
        default:
            children_.push_back(child);
            break;
    }
}

void Scene::removeChild(Object *child)
{
    switch (child->getType())
    {
        case ObjectType::OBJECT_WORLD:
            children_world_.erase(std::remove(children_world_.begin(), children_world_.end(), dynamic_cast<ObjectWorld *>(child)), children_world_.end());
            break;
        case ObjectType::OBJECT_SCREEN:
            children_screen_.erase(std::remove(children_screen_.begin(), children_screen_.end(), dynamic_cast<ObjectScreen *>(child)), children_screen_.end());
            break;
        default:
            children_.erase(std::remove(children_.begin(), children_.end(), child), children_.end());
            break;
    }
}
```

同样，我们也修改了生命周期方法，确保所有类型的对象都被正确处理：

```cpp
// scene.cpp
void Scene::handleEvents(SDL_Event &event)
{
    Object::handleEvents(event);
    for (auto &child : children_screen_)
    {
        child->handleEvents(event);
    }
    for (auto &child : children_world_)
    {
        child->handleEvents(event);
    }
}

void Scene::update(float dt)
{
    Object::update(dt);
    for (auto &child : children_world_)
    {
        child->update(dt);
    }
    for (auto &child : children_screen_)
    {
        child->update(dt);
    }
}

void Scene::render()
{
    Object::render();
    for (auto &child : children_world_)
    {
        child->render();
    }
    for (auto &child : children_screen_)
    {
        child->render();
    }
}

void Scene::clean()
{
    Object::clean();
    for (auto &child : children_world_)
    {
        child->clean();
    }
    children_world_.clear();
    for (auto &child : children_screen_)
    {
        child->clean();
    }
    children_screen_.clear();
}
```

注意渲染顺序：世界对象先于屏幕对象渲染，这确保了屏幕对象（如UI元素）会显示在世界对象（如游戏角色）之上。

## 在继承链中调用父类方法

当我们有一个继承链时，每个子类都应该确保调用其父类的生命周期方法，以维持整个系统的正确性。例如，在`Player`类中：

```cpp
// player.cpp
void Player::init()
{
    Actor::init();  // 调用父类的init
    max_speed_ = 500.0f;
}

void Player::handleEvents(SDL_Event& event)
{
    Actor::handleEvents(event);  // 调用父类的handleEvents
}

void Player::update(float dt)
{
    Actor::update(dt);  // 调用父类的update
    keyboardControl();
    velocity_ *= 0.9f;
    move(dt);
    syncCamera();
}

void Player::render()
{
    Actor::render();  // 调用父类的render
    game_.drawBoundary(render_position_, render_position_ + glm::vec2(20.0f), 5.0f, {1.0, 0.0, 0.0, 1.0});
}

void Player::clean()
{
    Actor::clean();  // 调用父类的clean
}
```

这种模式确保了继承链上的所有方法都被调用，无论继承层次有多深。

## 使用自动挂载系统

有了自动挂载系统，我们的场景管理代码变得简洁多了。以`SceneMain`为例：

```cpp
// scene_main.cpp
void SceneMain::init()
{
    world_size_ = game_.getScreenSize() * 3.0f;
    camera_position_ = world_size_ / 2.0f - game_.getScreenSize() / 2.0f;
    player_ = new Player();
    player_->init();
    player_->setPosition(world_size_ / 2.0f);
    addChild(player_);  // 将玩家添加为子对象
}

void SceneMain::handleEvents(SDL_Event& event)
{
    Scene::handleEvents(event);  // 调用父类的handleEvents，它会自动处理所有子对象
}

void SceneMain::update(float dt)
{
    Scene::update(dt);  // 调用父类的update，它会自动处理所有子对象
}

void SceneMain::render()
{
    Scene::render();  // 调用父类的render，它会自动处理所有子对象
    renderBackground();
}

void SceneMain::clean()
{
    Scene::clean();  // 调用父类的clean，它会自动处理所有子对象，包括清理和删除它们
}
```

注意我们如何简化了代码：
1. 我们不再需要显式地调用玩家的生命周期方法，因为这已经在父类的方法中自动处理了
2. 我们不再需要手动删除玩家对象，因为它作为场景的子对象，会在场景清理时自动被清理
3. 渲染背景的代码仍然需要显式调用，因为它是特定于这个场景的功能，不是子对象

## 自动挂载系统的优势

实现自动挂载系统带来了许多优势：

1. **代码简化**：不需要手动调用每个对象的生命周期方法
2. **减少错误**：避免了遗漏调用某个对象的方法的可能性
3. **内存管理**：自动清理子对象，减少了内存泄漏的风险
4. **层次结构**：能够表达对象之间的自然层次关系
5. **可扩展性**：容易添加新的对象类型和处理逻辑
6. **渲染顺序**：可以控制不同类型对象的渲染顺序

## 使用示例

让我们看一个具体的例子，展示如何使用自动挂载系统来创建一个包含多个对象的场景：

```cpp
// 创建一个新的场景
Scene* scene = new Scene();
scene->init();

// 创建一些世界对象（如游戏角色）
Player* player = new Player();
player->init();
player->setPosition({100, 100});
scene->addChild(player);

Enemy* enemy = new Enemy();
enemy->init();
enemy->setPosition({200, 200});
scene->addChild(enemy);

// 创建一些屏幕对象（如UI元素）
Button* button = new Button();
button->init();
button->setRenderPosition({10, 10});
scene->addChild(button);

// 游戏循环中只需要调用场景的方法
while (game_running) {
    // ...
    scene->handleEvents(event);
    scene->update(dt);
    scene->render();
    // ...
}

// 清理时只需要清理场景
scene->clean();
delete scene;
```

在这个例子中，我们创建了一个场景，添加了多个不同类型的对象，然后在游戏循环中只需要调用场景的生命周期方法。场景会自动处理所有子对象，包括调用它们的生命周期方法和最终清理它们。

## 总结

在本课中，我们实现了游戏对象的自动挂载功能，这是一种强大的设计模式，可以大大简化游戏对象的管理和交互。我们实现了对象类型系统、子对象管理、生命周期方法的递归行为，以及在场景中对不同类型对象的特殊处理。

这个系统为我们的游戏框架提供了坚实的基础，使得添加和管理游戏对象变得简单而直观。在接下来的课程中，我们将基于这个系统，添加更多的游戏功能和元素。

## 练习

1. **实现对象标签系统**：为`Object`类添加标签功能，并在`Scene`类中实现按标签查找对象的方法。

2. **创建复合对象**：设计一个由多个子对象组成的复杂游戏对象（如一个由主体和多个附件组成的角色）。

3. **添加对象激活状态**：为`Object`类添加激活/非激活状态，非激活状态的对象不会被更新或渲染。

