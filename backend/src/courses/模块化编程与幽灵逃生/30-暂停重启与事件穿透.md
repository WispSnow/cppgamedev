# 暂停重启与事件穿透

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/-Ch-8m0UGLU?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1pLdUYpEvK&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前面的课程中，我们完善了游戏的标题场景，添加了Credits页面功能。本课程将关注两个重要的游戏功能：游戏暂停/重启机制和事件穿透控制，这些功能对于提升游戏的用户体验至关重要。

<img src="https://theorhythm.top/gamedev/GE/30-暂停重启事件穿透1.PNG" style='width: 800px;' />

## 一、暂停按钮和重启按钮

### 1. 功能需求分析

在游戏运行过程中，玩家可能需要临时暂停游戏或者重新开始游戏。我们需要实现以下功能：

- **暂停功能**：暂停游戏逻辑更新、暂停音频播放，但保持UI响应
- **重启功能**：重置当前场景，从头开始游戏
- **返回功能**：从游戏场景返回到标题场景

### 2. 在Scene类中实现暂停/恢复功能

首先，我们在`Scene`类中添加暂停状态和相关方法：

```cpp
// scene.h
class Scene : public Object
{
protected:
    // ... 已有成员 ...
    bool is_pause_ = false;  // 暂停状态标志

public:
    // ... 已有方法 ...
    void pause();   // 暂停场景
    void resume();  // 恢复场景
};
```

```cpp
// scene.cpp
void Scene::pause()
{
    is_pause_ = true;
    game_.pauseSound();  // 暂停音效
    game_.pauseMusic();  // 暂停音乐
}

void Scene::resume()
{
    is_pause_ = false;
    game_.resumeSound();  // 恢复音效
    game_.resumeMusic();  // 恢复音乐
}
```

在`pause()`方法中，我们设置暂停标志，并调用`Game`类的方法暂停音频播放。在`resume()`方法中，我们清除暂停标志，并恢复音频播放。

### 3. 修改场景更新逻辑

接下来，我们修改`Scene`类的`update`方法，在暂停状态下只更新UI组件：

```cpp
// scene.cpp
void Scene::update(float dt)
{
    if (!is_pause_){
        // 只有在非暂停状态下才更新世界对象
        Object::update(dt);
        for (auto it = children_world_.begin(); it != children_world_.end(); )
        {
            auto child = *it;
            if (child->getNeedRemove()){
                it = children_world_.erase(it);
                child->clean();
                delete child;
                child = nullptr;
            } else {
                if (child->getActive()) {
                    child->update(dt);
                }
                ++it;
            }
        }
    }

    // 屏幕UI对象总是更新，无论是否暂停
    for (auto it = children_screen_.begin(); it != children_screen_.end(); )
    {
        // ... 已有代码 ...
    }
}
```

这种设计确保了即使在游戏暂停时，UI组件仍然可以响应用户交互。

### 4. 在主游戏场景中添加控制按钮

现在，我们在`SceneMain`类中添加暂停、重启和返回按钮：

```cpp
// scene_main.h
class HUDButton;

class SceneMain: public Scene
{
    // ... 已有成员 ...
    HUDButton* button_pause_ = nullptr;
    HUDButton* button_restart_ = nullptr;
    HUDButton* button_back_ = nullptr;

public:
    // ... 已有方法 ...

private:
    // ... 已有方法 ...
    void checkButtonPause();
    void checkButtonRestart();
    void checkButtonBack();
};
```

在场景初始化方法中创建按钮：

```cpp
// scene_main.cpp
void SceneMain::init()
{
    Scene::init();
    // ... 已有代码 ...

    // 添加控制按钮
    button_pause_ = HUDButton::addHUDButtonChild(this, 
        game_.getScreenSize() - glm::vec2(230.f, 30.f),
        "assets/UI/A_Pause1.png", "assets/UI/A_Pause2.png", "assets/UI/A_Pause3.png");
    button_restart_ = HUDButton::addHUDButtonChild(this, 
        game_.getScreenSize() - glm::vec2(140.f, 30.f), 
        "assets/UI/A_Restart1.png", "assets/UI/A_Restart2.png", "assets/UI/A_Restart3.png");
    button_back_ = HUDButton::addHUDButtonChild(this, 
        game_.getScreenSize() - glm::vec2(50.f, 30.f), 
        "assets/UI/A_Back1.png", "assets/UI/A_Back2.png", "assets/UI/A_Back3.png");

    // ... 其他初始化 ...
}
```

在场景更新方法中检查按钮状态：

```cpp
// scene_main.cpp
void SceneMain::update(float dt)
{
    Scene::update(dt);
    updateScore();
    checkButtonPause();
    checkButtonRestart();
    checkButtonBack();
}
```

### 5. 实现按钮响应逻辑

最后，我们实现按钮的响应方法：

```cpp
// scene_main.cpp
void SceneMain::checkButtonPause()
{
    if (!button_pause_->getIsTrigger()) return;
    if (is_pause_) resume();  // 如果当前是暂停状态，则恢复
    else pause();            // 否则暂停
}

void SceneMain::checkButtonRestart()
{
    if (!button_restart_->getIsTrigger()) return;
    auto scene = new SceneMain();
    game_.safeChangeScene(scene);  // 使用安全切换方法创建新场景
}

void SceneMain::checkButtonBack()
{
    if (!button_back_->getIsTrigger()) return;
    auto scene = new SceneTitle();
    game_.safeChangeScene(scene);  // 切换回标题场景
}
```

这样，我们就完成了暂停、重启和返回功能的实现。当玩家点击暂停按钮时，游戏会暂停，但UI仍然可以响应；点击重启按钮时，会创建一个新的游戏场景；点击返回按钮时，会回到标题场景。

## 二、控制事件穿透

<img src="https://theorhythm.top/gamedev/GE/30-暂停重启事件穿透2.PNG" style='width: 800px;' />

事件穿透是一个重要的概念，它决定了当多个UI元素重叠时，哪些元素会接收到事件。在我们的游戏中，需要确保事件按照正确的顺序传递，并且当一个元素处理了事件后，该事件不再继续传递。

### 1. 修改事件处理机制

首先，我们修改基础的`Object`类的事件处理方法，添加返回值来表示事件是否被处理：

```cpp
// object.h
virtual bool handleEvents(SDL_Event& event);  // 处理事件: 事件如果被处理，则返回真，否则继续向下传递（每次传递的时候检查是否已被处理）
```

```cpp
// object.cpp
bool Object::handleEvents(SDL_Event& event) {
    for (auto& child : children_) {
        if(child->getActive()) {
            if (child->handleEvents(event)) return true;  // 如果子对象处理了事件，则不再继续传递
        }
    }
    return false;  // 表示事件未被处理
}
```

这个改动确保了当一个子对象处理了事件后，该事件不会再传递给其他子对象。

### 2. 修改Scene类的事件处理

然后，我们需要修改`Scene`类的事件处理方法，考虑暂停状态和事件穿透：

```cpp
// scene.cpp
bool Scene::handleEvents(SDL_Event &event)
{
    // 先处理屏幕UI元素的事件
    for (auto &child : children_screen_)
    {
        if(child->getActive()) {
            if (child->handleEvents(event)) return true;  // 如果UI元素处理了事件，则不再继续传递
        }
    }
    
    // 如果场景暂停，则不处理世界元素的事件
    if (is_pause_) return false;
    
    // 处理场景自身的事件
    Object::handleEvents(event);
    
    // 处理世界元素的事件
    for (auto &child : children_world_)
    {
        if(child->getActive()) {
            if (child->handleEvents(event)) return true;  // 如果世界元素处理了事件，则不再继续传递
        }
    }
    return false;  // 表示事件未被任何元素处理
}
```

这个实现有几个重要特点：

1. **UI优先**：屏幕UI元素的事件处理优先于世界元素
2. **暂停控制**：暂停状态下，只有UI元素能接收事件
3. **事件截断**：当任何元素成功处理了事件，就不再将事件传递给其他元素

### 3. 修改按钮的事件处理

按钮是最常见的需要拦截事件的UI元素，我们修改`HUDButton`类的事件处理方法：

```cpp
// hud_button.cpp
bool HUDButton::handleEvents(SDL_Event &event)
{
    if (event.type == SDL_EVENT_MOUSE_BUTTON_DOWN) {
        if (event.button.button == SDL_BUTTON_LEFT) {
            if (is_hover_){
                is_press_ = true;
                game_.playSound("assets/sound/UI_button08.wav");
                return true;  // 按钮按下事件被处理
            }
        }
    } else if (event.type == SDL_EVENT_MOUSE_BUTTON_UP) {
        if (event.button.button == SDL_BUTTON_LEFT) {
            is_press_ = false;
            if (is_hover_){
                is_trigger_ = true;
                return true;  // 按钮释放事件被处理
            }
        }
    }
    return false;  // 事件未被处理
}
```

当按钮响应了鼠标按下或释放事件时，返回true表示事件已被处理，这将阻止事件继续传递给其他元素。

### 4. 修改其他事件处理组件

我们需要修改游戏中所有处理事件的组件，使其返回正确的处理结果。例如，`SceneTitle`类的事件处理：

```cpp
// scene_title.cpp
bool SceneTitle::handleEvents(SDL_Event &event)
{
    if (credits_text_->getActive()) {
        if (event.type == SDL_EVENT_MOUSE_BUTTON_UP) { 
            credits_text_->setActive(false);
            return true;  // 关闭Credits事件被处理
        }
    }
    if (Scene::handleEvents(event)) return true;  // 场景处理了事件
    return false;  // 事件未被处理
}
```

同样，技能的事件处理也需要修改：

```cpp
// weapon_thunder.cpp
bool WeaponThunder::handleEvents(SDL_Event &event)
{
    if (event.type == SDL_EVENT_MOUSE_BUTTON_DOWN) {
        if (event.button.button == SDL_BUTTON_LEFT) {
            if (!is_cool_down_){
                is_cool_down_ = true;
                cool_down_timer_ = 0;
                auto pos = game_.getMousePosition() + game_.getCurrentScene()->getCameraPosition();
                auto spell = Spell::addSpellChild(nullptr, "assets/effect/Thunderstrike w blur.png", pos, 40.0f, 3.0f, Anchor::CENTER);
                attack(pos, spell);
                return true;  // 技能施放事件被处理
            }
        }
    }
    return false;  // 事件未被处理
}
```

### 5. 事件穿透的优势

这种设计带来了多项优势：

1. **避免重复处理**：确保每个事件最多只被一个元素处理，避免意外行为
2. **明确处理优先级**：UI元素优先处理事件，符合用户期望
3. **简化暂停逻辑**：暂停状态下，世界元素自然不会接收到事件
4. **减少事件处理负担**：一旦事件被处理，不再遍历剩余元素
5. **增强代码可读性**：明确事件是否被处理，使代码逻辑更清晰

## 总结

在本课中，我们实现了两个重要的游戏功能：

1. **暂停/重启/返回功能**：
   - 添加了暂停状态控制
   - 实现了音频暂停和恢复
   - 添加了重启游戏和返回标题的功能
   - 在主游戏场景中添加了控制按钮

2. **事件穿透控制**：
   - 修改了事件处理机制，支持事件拦截
   - 确保了事件按照UI优先的顺序传递
   - 优化了暂停状态下的事件处理
   - 确保每个事件最多只被一个元素处理

这些功能大大提升了游戏的用户体验，使玩家可以更好地控制游戏流程，同时也为游戏的UI系统提供了更稳定的事件处理机制。

## 练习

1. 添加键盘快捷键暂停游戏（如按ESC键）
2. 实现一个暂停菜单，在游戏暂停时显示
3. 为暂停状态添加视觉反馈（如屏幕变暗或显示"暂停"文字）
4. 添加确认对话框，在重启或返回标题前询问玩家
5. 实现游戏进度保存功能，使玩家可以在暂停菜单中保存进度

