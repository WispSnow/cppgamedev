# 敌方幽灵类

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/joaJU3bz_qs?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1CUXqYJEZZ&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前几课中，我们实现了玩家类、精灵动画系统以及状态切换功能，使得玩家角色能够在游戏世界中移动并展示相应的动画效果。然而，一个游戏通常需要敌人或对手来增加挑战性和互动性。在本课中，我们将设计和实现敌方类，使其能够追踪玩家并与之互动。

敌方类是游戏中重要的组成部分，它可以为游戏增加以下元素：

1. **挑战性**：敌人提供游戏的难度和挑战
2. **互动性**：敌人能够对玩家行为做出反应
3. **游戏策略**：玩家需要制定策略来应对不同类型的敌人
4. **游戏进程**：敌人可以推动游戏情节发展

<img src="https://theorhythm.top/gamedev/GE/12-敌方幽灵类1.PNG" style='width: 800px;' />

## 向玩家移动

首先，我们将实现一个基本的敌方类，它能够识别玩家位置并向其移动。为了实现这一功能，我们需要对之前的代码进行一些调整和扩展。

### 代码重用：提取Actor::move()方法

在之前的实现中，`move()`方法是在`Player`类中定义的。但是，移动行为是所有活动对象（包括玩家和敌人）共有的。为了实现代码重用，我们将这个方法提取到`Actor`基类中：

```cpp
// actor.cpp
#include "actor.h"
#include "scene.h"

void Actor::move(float dt)
{
    setPosition(position_ + velocity_ * dt);
    position_ = glm::clamp(position_, glm::vec2(0), game_.getCurrentScene()->getWorldSize());
}
```

```cpp
// actor.h
class Actor : public ObjectWorld
{
protected:
    glm::vec2 velocity_ = glm::vec2(0); // 速度
    float max_speed_ = 100.0f; // 最大速度大小

public:
    void move(float dt);    // 移动
    // getters and setters
    glm::vec2 getVelocity() const { return velocity_; }
    void setVelocity(const glm::vec2 &velocity) { velocity_ = velocity; }
    float getMaxSpeed() const { return max_speed_; }
    void setMaxSpeed(float max_speed) { max_speed_ = max_speed; }
};
```

这个`move()`方法做了两件事：
1. 根据速度和时间增量更新位置
2. 确保位置不会超出世界边界

通过将这个方法提取到基类中，我们遵循了"不要重复自己"（DRY）的软件设计原则，减少了代码重复，并简化了未来的维护工作。

### 设计Enemy类

现在我们可以设计`Enemy`类了，它继承自`Actor`基类：

```cpp
// enemy.h
#ifndef ENEMY_H
#define ENEMY_H

#include "player.h"

class Enemy : public Actor
{
    Player* target_ = nullptr;

public:
    virtual void init();
    virtual void update(float dt) override;  // override the update function from Actor

    void aim_target(Player* target);

    // getters and setters
    Player* get_target() { return target_; }
    void set_target(Player* target) { target_ = target; }
};

#endif // ENEMY_H
```

`Enemy`类的关键组件和特性：

1. **目标引用**：`target_`成员变量是一个指向`Player`对象的指针，表示敌人的目标
2. **初始化方法**：`init()`方法进行敌人的初始化
3. **更新方法**：`update()`方法在每一帧更新敌人的状态
4. **瞄准方法**：`aim_target()`方法使敌人朝向目标玩家
5. **访问器和修改器**：提供了获取和设置目标的方法

### 实现Enemy类的功能

接下来，我们实现`Enemy`类的方法：

```cpp
// enemy.cpp
#include "enemy.h"
#include "affiliate/sprite_anim.h"

void Enemy::init()
{
    Actor::init();
    SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-Sheet.png", 2.0f);
}

void Enemy::update(float dt){
    Actor::update(dt);
    aim_target(target_);
    move(dt);
}

void Enemy::aim_target(Player *target)
{
    if (target == nullptr) return;
    auto direction = target->getPosition() - this->getPosition();
    direction = glm::normalize(direction);
    velocity_ = direction * max_speed_;
}
```

每个方法的功能：

1. **init()**
   - 调用基类的初始化方法
   - 创建并添加一个动画精灵，使用精灵表图像

2. **update()**
   - 调用基类的更新方法
   - 瞄准目标
   - 移动敌人

3. **aim_target()**
   - 检查目标是否有效
   - 计算从敌人到目标的方向向量
   - 标准化方向向量（使其长度为1）
   - 将敌人的速度设置为方向向量乘以最大速度

这个简单的AI使敌人始终朝着玩家的方向移动，创建了一个基本的追踪行为。

### 在场景中添加敌人

最后，我们需要在游戏场景中添加敌人实例：

```cpp
// scene_main.cpp
#include "scene_main.h"
#include "player.h"
#include "enemy.h"

void SceneMain::init()
{
    Scene::init();
    world_size_ = glm::vec2(1600.0f, 1200.0f);
    
    player_ = new Player();
    player_->init();
    player_->setPosition(world_size_ / 2.0f);
    addChild(player_);

    auto enemy = new Enemy();
    enemy->init();
    enemy->set_target(player_);
    enemy->setPosition(world_size_ / 2.0f + glm::vec2(200.0f));
    addChild(enemy);
}
```

在场景初始化过程中，我们：
1. 创建一个新的`Enemy`对象
2. 初始化敌人
3. 设置玩家作为敌人的目标
4. 设置敌人的初始位置（这里是在玩家右侧200单位处）
5. 将敌人添加为场景的子对象

### 向量运算的应用

在敌人的瞄准算法中，我们使用了向量运算来确定方向：

```cpp
auto direction = target->getPosition() - this->getPosition();
direction = glm::normalize(direction);
```

这个代码段展示了游戏开发中向量运算的重要性：
- 两个点之间的向量可以通过它们的坐标相减得到
- 向量标准化将向量的长度缩放为1，同时保持其方向
- 标准化向量乘以标量（在这里是最大速度）产生一个特定长度的向量

这种向量运算使敌人能够自然地朝着玩家移动，无论它们相对位置如何。

### 运行效果

运行游戏后，你会看到敌人（幽灵）始终追踪玩家的位置。玩家可以通过移动来躲避敌人，但敌人会不断调整方向，始终朝着玩家移动。这创造了一个简单但有效的追逐机制。

### 代码结构优化

注意我们如何通过将共同功能提取到基类中来优化代码结构。通过这种方式：
- `Player`和`Enemy`都使用相同的`move()`方法
- 但它们的移动行为不同：玩家由键盘控制，而敌人由AI控制
- 这种分离允许我们在不修改移动物理的情况下更改行为

这是面向对象设计的一个很好的例子，其中继承用于代码重用，而多态性用于行为定制。


## 动画状态切换

在上一节中，我们实现了基本的敌人移动AI。然而，一个生动的游戏角色通常具有多种状态，例如正常、受伤和死亡。在本节中，我们将扩展敌方类，使其能够根据不同的状态显示不同的动画。

<img src="https://theorhythm.top/gamedev/GE/12-敌方幽灵类2.PNG" style='width: 800px;' />

### 设计敌方状态系统

首先，我们需要定义敌方可能的状态。与玩家不同，敌方除了基本的移动状态外，还需要表现受到伤害和死亡的过程。因此，我们在`Enemy`类中添加了一个状态枚举：

```cpp
// enemy.h
class Enemy : public Actor
{
    enum class State{
        NORMAL,
        HURT,
        DIE
    };
    State current_state_ = State::NORMAL;
    
    // ... 其他成员变量
};
```

这个枚举定义了三种状态：
1. **NORMAL**：正常状态，敌人追踪玩家
2. **HURT**：受伤状态，表示敌人受到攻击
3. **DIE**：死亡状态，表示敌人已经被击败

我们使用`enum class`而不是普通枚举，这是C++11的特性，提供了更好的类型安全和命名空间控制。

### 多动画管理

接下来，我们需要为每个状态准备对应的动画。在`Enemy`类中添加了多个动画精灵指针和一个指向当前活跃动画的指针：

```cpp
// enemy.h
class Enemy : public Actor
{
    // ... 其他成员变量
    SpriteAnim* anim_normal_ = nullptr;
    SpriteAnim* anim_hurt_ = nullptr;
    SpriteAnim* anim_die_ = nullptr;

    SpriteAnim* current_anim_ = nullptr;

    float timer_ = 0.0f;  // 用于演示状态切换的计时器
    
    // ... 其他成员和方法
};
```

这些成员变量的作用：
- `anim_normal_`：正常状态下显示的动画
- `anim_hurt_`：受伤状态下显示的动画
- `anim_die_`：死亡状态下显示的动画
- `current_anim_`：当前激活的动画
- `timer_`：用于演示目的的计时器（在实际游戏中，状态切换通常由游戏事件触发）

### 初始化多个动画

在`init()`方法中，我们需要初始化所有动画精灵，并设置初始状态：

```cpp
// enemy.cpp
void Enemy::init()
{
    Actor::init();
    anim_normal_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-Sheet.png", 2.0f);
    anim_hurt_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghostHurt-Sheet.png", 2.0f);
    anim_die_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghostDead-Sheet.png", 2.0f);
    anim_hurt_->setActive(false);
    anim_die_->setActive(false);

    current_anim_ = anim_normal_;
}
```

这个方法做了以下工作：
1. 调用基类的初始化方法
2. 创建并添加三个动画精灵，分别对应正常、受伤和死亡状态
3. 默认停用受伤和死亡动画（只激活正常动画）
4. 将当前动画指针设置为正常动画

注意，我们使用了三个不同的精灵表图像文件，分别对应三种不同的状态。

### 状态切换机制

与玩家类类似，我们需要添加状态检查和状态切换的方法。然而，与玩家不同的是，敌人的状态通常由游戏逻辑（如受到攻击、生命值低于某个阈值等）触发，而不是由用户输入直接控制。

首先，我们添加一个空的`checkState()`方法作为占位符：

```cpp
// enemy.cpp
void Enemy::checkState()
{
    // 将在实际游戏逻辑中实现
}
```

然后，实现`changeState()`方法来处理状态切换：

```cpp
// enemy.cpp
void Enemy::changeState(State new_state)
{
    if (new_state == current_state_) return;
    current_anim_->setActive(false);
    switch (new_state) {
    case State::NORMAL:
        current_anim_ = anim_normal_;
        current_anim_->setActive(true);
        break;
    case State::HURT:
        current_anim_ = anim_hurt_;
        current_anim_->setActive(true);
        break;
    case State::DIE:
        current_anim_ = anim_die_;
        current_anim_->setActive(true);
        break;
    }
    current_state_ = new_state;
}
```

这个方法的工作流程：
1. 如果新状态与当前状态相同，则直接返回（避免不必要的处理）
2. 停用当前活跃的动画
3. 根据新状态，选择相应的动画并激活它
4. 更新当前状态

不同于玩家状态切换，我们没有在这里复制当前帧和帧计时器值。这是因为敌人的状态通常代表完全不同的行为模式（如从正常到受伤再到死亡），我们通常希望新状态的动画从头开始播放。

### 演示状态切换

为了演示状态切换功能，我们在`update()`方法中添加了一个简单的计时器逻辑：

```cpp
// enemy.cpp
void Enemy::update(float dt){
    Actor::update(dt);
    aim_target(target_);
    move(dt);
    timer_ += dt;
    if (timer_ > 2.0f && timer_ < 4.0f) {
        changeState(State::HURT);
    } else if (timer_ > 4.0f) {
        changeState(State::DIE);
    }
}
```

这个演示逻辑使敌人：
1. 在游戏开始后2秒切换到受伤状态
2. 在游戏开始后4秒切换到死亡状态

在实际游戏中，这些状态切换通常由更复杂的游戏事件触发，如：
- 敌人受到玩家攻击时切换到受伤状态
- 敌人生命值降至零时切换到死亡状态
- 敌人被特定技能击中时切换到眩晕或冰冻状态

### 状态切换的多样性

值得注意的是，敌方的状态切换与玩家的状态切换有一些关键区别：

1. **触发机制**：玩家状态通常由用户输入触发，而敌人状态通常由游戏逻辑触发
2. **状态复杂性**：敌人可能有更多的状态，包括生命周期相关的状态（如出生、死亡）
3. **行为变化**：状态切换可能完全改变敌人的行为模式，而不仅仅是动画
4. **状态持续时间**：某些状态（如受伤）可能是临时的，需要在一定时间后自动回到正常状态
5. **状态转换规则**：可能存在复杂的状态转换规则，如某些状态之间不能直接切换

这种多样性使得敌方的状态系统通常比玩家的状态系统更加复杂。在更大型的游戏中、可能需要设计一个复杂的状态机来处理各种状态之间的转换关系。

## 动画结束与删除

在前两节中，我们实现了敌人的移动AI和状态切换系统。然而，游戏对象（尤其是敌人）通常有一个生命周期：它们被创建、在游戏中活动一段时间，然后被销毁。特别是对于敌人，当它们被击败后，通常会播放死亡动画，然后从游戏世界中移除。

在本节中，我们将实现动画结束检测和对象自动移除的功能，使敌人能够在死亡动画播放完毕后自动从游戏中删除。

### 动画的循环与完成状态

首先，我们需要对精灵动画系统进行扩展，使其能够支持非循环动画和检测动画完成：

```cpp
// sprite.h 的修改
class Sprite : public ObjectAffiliate
{
protected:
    Texture texture_;
    bool is_finish_ = false;  // 新增：标记动画是否完成

public:
    // ... 其他方法
    bool getFinish() const { return is_finish_; }
    void setFinish(bool is_finish) { is_finish_ = is_finish; }
};
```

```cpp
// sprite_anim.h 的修改
class SpriteAnim : public Sprite
{
    // ... 其他成员
    bool is_loop_ = true;  // 新增：是否循环播放

public:
    // ... 其他方法
    bool getLoop() const { return is_loop_; }
    void setLoop(bool is_loop) { is_loop_ = is_loop; }
};
```

这些修改增加了两个关键功能：
1. 动画完成标志（`is_finish_`）：用于标记动画是否已完成播放
2. 循环控制标志（`is_loop_`）：用于控制动画是否循环播放

接下来，我们需要修改`Sprite::render()`方法，使其检查完成状态：

```cpp
// sprite.cpp
void Sprite::render()
{
    if (!texture_.texture || !parrent_ || is_finish_) return;
    
    auto pos = parrent_->getRenderPosition() + offset_;
    game_.renderTexture(texture_, pos, size_);
}
```

这个修改确保了当动画被标记为完成时，它不会再被渲染。

最重要的是，我们需要修改`SpriteAnim::update()`方法，使它能够检测动画何时完成：

```cpp
// sprite_anim.cpp
void SpriteAnim::update(float dt)
{
    if (is_finish_) return;  // 如果已完成，不再更新
    
    frame_timer_ += dt;
    if (frame_timer_ >= 1.0f / fps_)
    {
        current_frame_++;
        if (current_frame_ >= total_frames_)
        {
            current_frame_ = 0;
            if (!is_loop_) is_finish_ = true;  // 如果不循环，则标记为完成
        }
        frame_timer_ = 0.0f;
    }
    texture_.src_rect.x = texture_.src_rect.w * current_frame_;
}
```

这个修改做了两件重要的事：
1. 如果动画已标记为完成，不再继续更新
2. 当动画播放到最后一帧时，如果设置为不循环，则标记动画为完成状态

### 对象的自动删除机制

现在我们有了动画完成的检测机制，接下来需要一个系统来自动删除完成死亡动画的对象。为此，我们向`Object`类添加了一个"需要删除"标志：

```cpp
// object.h
class Object
{
protected:
    // ... 其他成员
    bool need_remove_ = false;  // 新增：标记对象是否需要删除

public:
    // ... 其他方法
    bool getNeedRemove() const { return need_remove_; }
    void setNeedRemove(bool need_remove) { need_remove_ = need_remove; }
};
```

然后，我们需要修改`Object::update()`和`Scene::update()`方法，使它们能够检测和处理需要删除的对象：

```cpp
// object.cpp
void Object::update(float dt) {
    for (auto it = children_.begin(); it != children_.end();) {
        auto child = *it;
        if (child->getNeedRemove()){
            it = children_.erase(it);
            child->clean();
            delete child;
        } else {
            if(child->getActive()) {
                child->update(dt);
            }
            ++it;
        }
    }
}
```

这个修改将之前的简单循环替换为使用迭代器的循环，以便安全地在迭代过程中删除元素。它做了以下工作：

1. 检查子对象是否被标记为需要删除
2. 如果是，从容器中移除它，调用其`clean()`方法，并释放内存
3. 如果否，继续正常更新对象

类似地，`Scene::update()`方法也进行了相应的修改，以便处理世界对象和屏幕对象中需要删除的元素。

### 死亡后自动删除敌人

现在，我们可以使用这些新功能来实现敌人死亡后的自动删除。首先，在`Enemy::init()`方法中，我们设置死亡动画为不循环：

```cpp
// enemy.cpp
void Enemy::init()
{
    Actor::init();
    anim_normal_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-Sheet.png", 2.0f);
    anim_hurt_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghostHurt-Sheet.png", 2.0f);
    anim_die_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghostDead-Sheet.png", 2.0f);
    anim_hurt_->setActive(false);
    anim_die_->setActive(false);
    anim_die_->setLoop(false);  // 设置死亡动画不循环

    current_anim_ = anim_normal_;
}
```

然后，我们添加一个`remove()`方法来检查死亡动画是否完成，并在完成时标记敌人为需要删除：

```cpp
// enemy.cpp
void Enemy::remove()
{
    if (anim_die_->getFinish()) {
        need_remove_ = true;
    }
}
```

最后，在`Enemy::update()`方法中调用这个新方法：

```cpp
// enemy.cpp
void Enemy::update(float dt){
    Actor::update(dt);
    aim_target(target_);
    move(dt);
    timer_ += dt;
    if (timer_ > 1.0f && timer_ < 2.0f) {
        changeState(State::HURT);
    } else if (timer_ > 2.0f) {
        changeState(State::DIE);   
    }
    remove();  // 检查是否需要删除
}
```

现在，敌人会在播放完死亡动画后自动从游戏中删除，释放内存资源。

### 优化演示时间

我们还对演示逻辑进行了优化，使状态切换更快，便于观察：

```cpp
// enemy.cpp
void Enemy::update(float dt){
    // ... 其他代码
    timer_ += dt;
    if (timer_ > 1.0f && timer_ < 2.0f) {  // 从2秒改为1秒
        changeState(State::HURT);
    } else if (timer_ > 2.0f) {  // 从4秒改为2秒
        changeState(State::DIE);   
    }
    // ... 其他代码
}
```

### 内存管理的重要性

这个自动删除机制解决了游戏开发中的一个常见问题：内存泄漏。如果我们创建对象但不删除它们，随着游戏运行时间的增长，内存使用会不断增加，最终可能导致游戏崩溃。

特别是对于敌人这样的对象，它们可能会频繁地创建和销毁，有效的内存管理尤为重要。我们的自动删除机制确保了以下几点：

1. **资源释放**：对象使用的资源（如内存）在不再需要时被释放
2. **清理关联**：通过调用`clean()`方法，对象有机会清理其关联（如引用、连接等）
3. **自动化**：删除过程是自动的，减少了手动内存管理的错误风险
4. **安全删除**：使用迭代器模式确保在容器迭代过程中安全地删除元素

## 总结

在本课中，我们实现了一个基本的敌方类系统，包括：

1. **向玩家移动**：敌人能够识别玩家位置并向其移动
2. **动画状态切换**：敌人能够根据状态（正常、受伤、死亡）显示不同的动画
3. **动画结束与删除**：敌人在完成死亡动画后能够自动从游戏中删除

这些功能为我们的游戏增加了更多的交互性和挑战性。特别是，我们实现的对象生命周期管理机制是游戏开发中的重要组成部分，能够确保游戏长时间运行时不会出现内存泄漏问题。

在下一课中，我们将继续扩展游戏功能，添加更多的游戏机制和交互方式。

## 练习
1. **更多状态**：添加一个“发怒”状态，当血量低于30%时增加移动速度。

2. **添加武器**：让敌人定时向玩家发射子弹
