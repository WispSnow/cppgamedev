# SDL3新的文本绘制与数学库

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/4pUNCBMiCv8?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1ivRYY8EFA&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们完成了项目的环境配置，包括SDL3和GLM的安装。在这一课中，我们将主要介绍三个方面的内容：GLM数学库的基础使用、SDL3中新的文本绘制方法，以及如何获取和处理鼠标状态。

>本课以《SDL与太空战机》中的[SDL3的变化](https://cppgamedev.top/courses/sdl-space-shooter/parts/sd3-changes)为基础进行，建议先完成该课程。

## 1. GLM数学库基础

GLM (OpenGL Mathematics) 是一个基于OpenGL着色语言(GLSL)的C++数学库。它提供了向量、矩阵运算等功能，对于游戏开发中的数学计算非常有用。

### 引入GLM库

首先，我们需要在代码中引入GLM库：

```cpp
#include <glm/glm.hpp>
```

### 基本使用方法

GLM提供了向量和矩阵类型，以及对应的数学运算函数。以下是一些基本用法：

```cpp
// 创建二维向量
glm::vec2 a = glm::vec2(1.0f, 2.0f);
glm::vec2 b = glm::vec2(3.0f, 4.0f);

// 向量乘法（分量相乘）
auto c = a * b;  // 结果: (3.0, 8.0)

// 计算向量间距离
auto d = glm::distance(a, b);

// 打印结果
SDL_Log("d = (%f)", d);
SDL_Log("c = (%f, %f)", c.x, c.y);
```

在游戏开发中，我们将使用GLM库来处理玩家和敌人的位置、移动方向、距离计算等，从而实现更精确的游戏逻辑控制。

## 2. SDL3新的文本绘制方法

<img src="https://theorhythm.top/gamedev/GE/02-SDL基础-文本.PNG" style='width: 800px;' />

在上期教程中，我们使用了SDL2的传统文本渲染方法。而SDL3引入了新的文本渲染API，使得文本处理更加灵活和高效。

### 传统方法（仍然支持）

```cpp
// 创建文本纹理
SDL_Color color = {255, 255, 255, 255};
SDL_Surface *surface = TTF_RenderText_Solid(font, "Hello, SDL! 中文也可以", 0, color);
SDL_Texture *textTexture = SDL_CreateTextureFromSurface(renderer, surface);

// 渲染文本
SDL_FRect textRect = {300, 300, static_cast<float>(surface->w), static_cast<float>(surface->h)};
SDL_RenderTexture(renderer, textTexture, NULL, &textRect);
```

这种方法需要我们手动创建Surface和Texture，然后在每一帧中渲染它们。

### SDL3新方法

SDL3引入了TextEngine的概念，简化了文本渲染流程：

```cpp
// 创建文本引擎和文本对象
TTF_TextEngine *textEngine = TTF_CreateRendererTextEngine(renderer);
TTF_Text *text = TTF_CreateText(textEngine, font, "SDL3 新的文本渲染方式", 0);

// 设置文本属性
TTF_SetTextColor(text, 255, 0, 0, 255);  // 红色文本
TTF_SetTextWrapWidth(text, 50);          // 设置文本换行宽度

// 在渲染循环中直接绘制文本
TTF_DrawRendererText(text, 400, 400);
```

新的文本渲染方法有以下优点：
- 代码更简洁，不需要手动管理Surface和Texture
- 可以直接设置文本属性，如颜色、换行宽度等
- 渲染更高效，特别是对于频繁变化的文本

## 3. SDL中的鼠标状态处理

<img src="https://theorhythm.top/gamedev/GE/02-SDL基础-鼠标.PNG" style='width: 800px;' />

游戏中，获取和处理鼠标输入是常见需求。SDL提供了简便的API来处理鼠标状态。

### 获取鼠标位置

在SDL3中，我们可以使用`SDL_GetMouseState`函数获取鼠标的当前位置和按钮状态：

```cpp
glm::vec2 mousePos = glm::vec2(0.0f, 0.0f);
auto state = SDL_GetMouseState(&mousePos.x, &mousePos.y);
SDL_Log("Mouse Pos: (%f, %f)", mousePos.x, mousePos.y);
```

这段代码结合了GLM向量和SDL鼠标状态获取，将鼠标位置存储在`mousePos`向量中。

### 检测鼠标按钮状态

`SDL_GetMouseState`函数返回的状态值包含了鼠标按钮的信息，我们可以通过位掩码操作来检查特定按钮是否被按下：

```cpp
if (state & SDL_BUTTON_LMASK) {
    SDL_Log("Left Button Down");
}
if (state & SDL_BUTTON_RMASK) {
    SDL_Log("Right Button Down");
}
```

此外，还有`SDL_BUTTON_MMASK`表示中键，`SDL_BUTTON_X1MASK`和`SDL_BUTTON_X2MASK`表示额外的鼠标按钮。

## 完整代码

结合以上三个方面的内容，我们的`main.cpp`文件如下（注意：此代码仅展示了本课新增的内容）：

```cpp
#include <iostream>
#include <SDL3/SDL.h>
#include <SDL3_image/SDL_image.h>
#include <SDL3_mixer/SDL_mixer.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <glm/glm.hpp>

int main(int, char**) {
    // GLM基础使用
    glm::vec2 a = glm::vec2(1.0f, 2.0f);
    glm::vec2 b = glm::vec2(3.0f, 4.0f);
    auto c = a * b;
    auto d = glm::distance(a, b);
    SDL_Log("d = (%f)", d);
    SDL_Log("c = (%f, %f)", c.x, c.y);

    // SDL初始化、窗口创建等代码...
    
    // SDL3 新的绘制文本方法
    TTF_TextEngine *textEngine = TTF_CreateRendererTextEngine(renderer);
    TTF_Text *text = TTF_CreateText(textEngine, font, "SDL3 新的文本渲染方式", 0);
    TTF_SetTextColor(text, 255, 0, 0, 255);
    TTF_SetTextWrapWidth(text, 50);
    
    // 渲染循环
    glm::vec2 mousePos = glm::vec2(0.0f, 0.0f);
    while (true) {
        // 事件处理...
        
        // 获取鼠标状态
        auto state = SDL_GetMouseState(&mousePos.x, &mousePos.y);
        // SDL_Log("Mouse Pos: (%f, %f)", mousePos.x, mousePos.y);
        if (state & SDL_BUTTON_LMASK) {
            SDL_Log("Left Button Down");
        }
        if (state & SDL_BUTTON_RMASK) {
            SDL_Log("Right Button Down");
        }
        
        // 渲染代码...
        
        // 新的画文本方法：
        TTF_DrawRendererText(text, 400, 400);
        
        // 更新屏幕...
    }
    
    // 资源清理代码...
    
    return 0;
}
```

## 总结

在这一课中，我们学习了三个重要内容：

1. **GLM数学库基础**：使用向量类型和数学函数进行游戏中的数学计算
2. **SDL3新的文本渲染方法**：使用TextEngine简化文本渲染流程
3. **SDL鼠标状态处理**：获取鼠标位置和按钮状态

这些技术将为我们构建幽灵逃生游戏奠定基础。在接下来的课程中，我们将进一步扩展这些知识，构建更复杂的游戏功能。

## 练习

1. 尝试使用GLM创建一个2D向量，并计算两个向量的点积和叉积
2. 使用SDL3的新文本渲染方法，创建一个能够动态改变颜色的文本
3. 实现一个简单的功能：当鼠标悬停在屏幕上的某个区域时，显示特定文本

