# 战斗属性组件

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/KLzKAZB5mj4?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1VEo2YiEtB&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏开发中，角色属性是构建战斗系统的基础。生命值、魔法值、攻击力等属性不仅定义了角色的能力，还影响着游戏的平衡性和玩家体验。在本课中，我们将设计和实现一个战斗属性组件，使游戏角色能够具备基本的战斗能力。

## 战斗属性组件的意义

在游戏中，战斗属性组件负责管理角色的各种状态和能力数值。它具有以下重要作用：

1. **定义角色状态**：通过生命值、魔法值等属性定义角色的当前状态
2. **实现战斗机制**：提供受伤、恢复、魔法消耗等基本机制
3. **平衡游戏性**：通过调整不同角色的属性值实现游戏平衡
4. **支持角色成长**：为角色升级、装备系统等提供基础
5. **增强游戏反馈**：通过属性变化提供游戏反馈，增强游戏体验

## 设计战斗属性组件

我们将设计一个名为`Stats`的类作为战斗属性组件。该组件需要管理的主要属性包括：

1. 生命值（Health）和最大生命值
2. 魔法值（Mana）和最大魔法值
3. 攻击力（Damage）
4. 魔法恢复速率
5. 无敌状态及其时间控制

此外，组件还需要提供基础的功能，如受伤、魔法消耗、状态检查等。

让我们来看看`Stats`类的基本定义：

```cpp
// stats.h
#ifndef STATS_H
#define STATS_H

#include "../core/actor.h"

class Stats : public Object
{
protected:
    Actor* parent_ = nullptr;
    float health_ = 100.0f;
    float max_health_ = 100.0f;
    float mana_ = 100.0f;
    float max_mana_ = 100.0f;
    float damage_ = 40.0f;
    float mana_regen_ = 10.0f;

    float invincible_time_ = 1.5f;      // 受伤后，无敌时间有多长
    float invincible_timer_ = 0.0f;     // 无敌计时器
    bool is_alive_ = true;
    bool is_invincible_ = false;

public:
    static Stats* addStatsChild(Actor* parent, float max_health = 100.0f, float max_mana = 100.0f, float damage = 40.0f, float mana_regen = 10.0f);
    virtual void update(float dt) override;

    bool canUseMana(float mana_cost);
    void useMana(float mana_cost);
    void regenMana(float dt);
    void takeDamage(float damage);

    // getters and setters
    float getHealth() const { return health_; }
    float getMaxHealth() const { return max_health_; }
    float getMana() const { return mana_; }
    float getMaxMana() const { return max_mana_; }
    float getDamage() const { return damage_; }
    float getManaRegen() const { return mana_regen_; }
    bool isAlive() const { return is_alive_; }
    // ... 更多getter和setter方法
};

#endif // STATS_H
```

这个类继承自`Object`，这使得它可以被添加为其他对象的子对象，并参与游戏循环。它包含了各种属性变量，以及管理这些属性的方法。

## 组件的创建和初始化

与我们之前实现的组件类似，`Stats`类使用静态工厂方法来创建和初始化实例：

```cpp
// stats.cpp
Stats *Stats::addStatsChild(Actor *parent, float max_health, float max_mana, float damage, float mana_regen)
{
    Stats *stats = new Stats();
    stats->parent_ = parent;
    stats->max_health_ = max_health;
    stats->health_ = max_health;
    stats->max_mana_ = max_mana;
    stats->mana_ = max_mana;
    stats->damage_ = damage;
    stats->mana_regen_ = mana_regen;
    parent->addChild(stats);
    return stats;
}
```

这个方法创建一个新的`Stats`对象，设置其属性，并将其添加为父Actor的子对象。注意这里我们将组件的初始生命值设置为最大生命值，魔法值也是如此，这确保了角色初始状态是满血满魔的。

## 实现核心功能

接下来，我们需要实现`Stats`类的核心功能，包括伤害处理、魔法消耗和恢复等。

### 伤害处理

当角色受到攻击时，需要减少其生命值，并可能触发其他效果（如无敌时间）：

```cpp
// stats.cpp
void Stats::takeDamage(float damage)
{
    if (is_invincible_) return;

    health_ -= damage;
    if (health_ < 0) {
        health_ = 0;
        is_alive_ = false;
    }
    SDL_Log("Health: %f", health_);
    is_invincible_ = true;
    invincible_timer_ = 0.0f;
}
```

这个方法首先检查角色是否处于无敌状态，如果是则忽略伤害。否则，减少生命值，并检查是否生命值归零（角色死亡）。最后，设置角色进入无敌状态，并重置无敌计时器。

### 魔法系统

魔法系统包括魔法消耗和自动恢复两部分：

```cpp
// stats.cpp
bool Stats::canUseMana(float cost)
{
    return mana_ >= cost;
}

void Stats::useMana(float cost)
{
    mana_ -= cost;
    if (mana_ < 0) mana_ = 0;
}

void Stats::regenMana(float dt)
{
    mana_ += mana_regen_ * dt;
    if (mana_ > max_mana_) mana_ = max_mana_;
}
```

`canUseMana`方法检查角色是否有足够的魔法值，`useMana`方法消耗指定量的魔法值，而`regenMana`方法则根据时间增量和恢复速率自动恢复魔法值。

### 更新逻辑

在每一帧，`Stats`组件需要更新其状态，如处理无敌时间和恢复魔法值：

```cpp
// stats.cpp
void Stats::update(float dt)
{
    Object::update(dt);
    regenMana(dt);
    if (is_invincible_) {
        invincible_timer_ += dt;
        if (invincible_timer_ >= invincible_time_) {
            is_invincible_ = false;
            invincible_timer_ = 0;
        }
    }
}
```

这个方法首先调用基类的`update`方法，然后执行魔法值恢复，最后处理无敌状态的计时和结束。

## 集成到Actor类

为了使Actor能够使用战斗属性，我们需要修改Actor类，添加对Stats组件的支持：

```cpp
// actor.h
class Stats;
class Actor : public ObjectWorld
{
protected:
    Stats *stats_ = nullptr; // 角色属性
    glm::vec2 velocity_ = glm::vec2(0, 0); // 速度
    float max_speed_ = 100.0f; // 最大速度大小

public:
    // ... 其他方法
    Stats *getStats() const { return stats_; }
    void setStats(Stats *stats) { stats_ = stats; }
    void takeDamage(float damage);
    bool isAlive() const;
};
```

我们在Actor类中添加了一个`stats_`指针和相关的方法，使Actor能够管理其战斗属性。

接下来，我们实现`takeDamage`和`isAlive`方法，这些方法将调用Stats组件的对应方法：

```cpp
// actor.cpp
void Actor::takeDamage(float damage)
{
    if (!stats_) return;
    stats_->takeDamage(damage);
}

bool Actor::isAlive() const
{
    if (!stats_) return true;
    return stats_->isAlive();
}
```

这些方法首先检查Stats组件是否存在，然后委托给它进行具体操作。这种设计使得Actor类本身不需要关心战斗属性的具体实现，只需要知道如何与Stats组件交互。

## 为游戏角色添加属性

现在，我们可以为游戏中的角色（如玩家和敌人）添加战斗属性了。首先是玩家：

```cpp
// player.cpp
#include "raw/stats.h"

void Player::init()
{
    Actor::init();
    sprite_idle_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-idle.png", 2.0f);
    sprite_move_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-move.png", 2.0f);
    sprite_move_->setActive(false);

    collider_ = Collider::addColliderChild(this, sprite_idle_->getSize() / 2.0f);
    stats_ = Stats::addStatsChild(this);
}
```

然后是敌人：

```cpp
// enemy.cpp
#include "raw/stats.h"

void Enemy::init()
{
    Actor::init();
    anim_normal_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-Sheet.png", 2.0f);
    anim_hurt_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghostHurt-Sheet.png", 2.0f);
    anim_die_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghostDead-Sheet.png", 2.0f);
    anim_hurt_->setActive(false);
    anim_die_->setActive(false);
    anim_die_->setLoop(false);

    current_anim_ = anim_normal_;
    collider_ = Collider::addColliderChild(this, current_anim_->getSize());
    stats_ = Stats::addStatsChild(this);
}
```

在这两个例子中，我们都使用默认参数创建了Stats组件。在实际游戏中，可能需要根据角色类型或难度级别调整这些参数。

## 实现战斗交互

有了战斗属性组件，我们可以实现角色之间的战斗交互。例如，当敌人与玩家碰撞时造成伤害：

```cpp
// enemy.cpp
void Enemy::attack()
{
    if (!collider_ || target_->getCollider() == nullptr) return;
    if (collider_->isColliding(target_->getCollider())) {
        // 检测到碰撞，进行攻击
        if (stats_ && target_->getStats()) {
            target_->takeDamage(stats_->getDamage());
        }
    }
}
```

在这个方法中，敌人首先检查自己和目标（玩家）是否都有碰撞器。如果有，则检查碰撞器是否相交。如果相交，并且双方都有Stats组件，敌人就会对玩家造成伤害。

## 生命周期检查

在游戏循环中，我们需要检查角色是否仍然存活，以便处理死亡逻辑：

```cpp
// player.cpp
void Player::update(float dt)
{
    Actor::update(dt);
    handleInput();
    checkState();
    move(dt);
    syncCamera();
    // isAlive(); // check if player is alive
}
```

目前这只是一个注释，但在实际游戏中，我们可能需要根据玩家是否存活来执行不同的逻辑，如游戏结束、重生等。

## 战斗属性组件的优势

实现独立的战斗属性组件有以下优势：

1. **分离关注点**：将战斗属性管理与角色的其他功能（如移动、渲染）分离
2. **代码复用**：多种类型的角色可以共用相同的属性管理逻辑
3. **灵活配置**：可以为不同角色配置不同的属性值和行为
4. **易于扩展**：可以方便地添加新属性或修改现有属性的行为
5. **状态管理**：集中管理角色的状态（如无敌状态），减少代码重复

## 无敌时间机制

在游戏中，"无敌时间"是一种常见的机制，用于防止角色在短时间内受到多次伤害。我们的Stats组件实现了这一机制：

```cpp
if (is_invincible_) {
    invincible_timer_ += dt;
    if (invincible_timer_ >= invincible_time_) {
        is_invincible_ = false;
        invincible_timer_ = 0;
    }
}
```

当角色受到伤害后，会进入无敌状态一段时间（默认为1.5秒）。在这段时间内，角色不会受到额外的伤害。这一机制可以防止角色被敌人"连击致死"，给玩家更好的游戏体验。

## 魔法系统的意义

虽然当前游戏中还没有使用魔法的功能，但我们已经实现了基础的魔法系统：

1. **资源管理**：魔法值作为一种资源，限制了特殊能力的使用频率
2. **战略选择**：玩家需要决定何时使用魔法，增加了游戏的战略深度
3. **平衡机制**：强大的能力消耗更多魔法值，保持游戏平衡
4. **自动恢复**：魔法值会随时间自动恢复，鼓励玩家积极使用能力

在后续课程中，我们可以基于这个系统实现各种魔法技能或特殊能力。

## 扩展可能性

当前的战斗属性系统还有很多扩展可能：

1. **更多属性**：添加防御力、暴击率、闪避率等属性
2. **状态效果**：实现缓慢、中毒、燃烧等状态效果
3. **装备系统**：通过装备提升或修改角色属性
4. **技能系统**：基于当前属性实现各种主动和被动技能
5. **升级系统**：随着游戏进程提升角色属性
6. **多样化伤害**：实现物理伤害、魔法伤害、真实伤害等不同类型

## 总结

在本课中，我们设计并实现了一个战斗属性组件：

1. 创建了`Stats`类，管理生命值、魔法值、攻击力等属性
2. 实现了受伤、魔法消耗、状态检查等基本功能
3. 添加了无敌时间机制，提升游戏体验
4. 集成Stats组件到Actor类，并为玩家和敌人添加属性
5. 实现了基本的战斗交互逻辑

这个战斗属性系统为我们的游戏提供了基础的战斗功能，使角色能够相互造成伤害，并管理自身状态。在后续课程中，我们将基于这个系统，实现更复杂的游戏机制，如技能系统、升级系统等。

## 练习

1. **暴击系统**：扩展Stats类，添加暴击率和暴击伤害属性
2. **状态效果**：实现一个简单的状态效果系统，如"中毒"效果每秒造成伤害
3. **属性成长**：实现一个简单的升级系统，使角色属性随等级提升