# 游戏框架设计

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/oA65chlE_G4?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV14HRjYNEez&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前两课中，我们已经熟悉了SDL3的基本使用方法和GLM数学库。从本课开始，我们将踏入更深层次的游戏开发领域——设计一个灵活、可扩展的游戏框架。这节课我们不会编写实际代码，而是重点讨论框架设计思路和结构。这种前期的架构规划将为后续的开发工作奠定坚实基础。

## 传统的Game类与Scene类设计

<img src="https://theorhythm.top/gamedev/GE/03-游戏框架设计1.PNG" style='width: 800px;' />

在传统的游戏架构中，我们通常会设计两个核心类：Game类和Scene类。

### Game类的职责

Game类是整个游戏的控制中心，负责：
- 存储当前活动场景（currentScene）
- 初始化游戏环境（init()）
- 运行主循环，处理游戏逻辑
- 管理场景切换（changeScene()）
- 清理资源（clean()）

### Scene类及其子类

Scene类是一个抽象基类，定义了所有场景都应具备的基本功能：
- 初始化场景（init()）
- 处理输入事件（handleEvent()）
- 更新游戏状态（update()）
- 渲染画面（render()）
- 清理资源（clean()）

具体的场景（如Scene Class 1、Scene Class 2等）通过继承Scene基类并实现这些方法来创建。Game类的主循环会调用当前活动场景的相应方法。

## 新的游戏框架：模块化与分层设计

<img src="https://theorhythm.top/gamedev/GE/03-游戏框架设计3.PNG" style='width: 800px;' />

对于更复杂的游戏，我们需要一个更加模块化的框架。新设计有以下几层：

### 1. 游戏层（Game Class）

- 负责主循环逻辑
- 在主循环中执行handleEvent()、update()和render()
- 管理当前活动场景，并将这些调用转发给场景

### 2. 场景层（Scene Class）

- 接收来自Game的handleEvent()、update()和render()调用
- 管理该场景中的所有游戏物体
- 将这些调用进一步转发给各个游戏物体

### 3. 物体层（Player Class、Enemy Class、Effect Class等）

- 实现各自的handleEvent()、update()和render()方法
- 每个物体类负责自己特定的游戏逻辑
- 可以持有和管理各种组件

### 4. 组件层（Sprite Class等）

- 提供可重用的功能模块
- 附加到游戏物体上，增强其功能
- 例如，Sprite组件处理精灵图的渲染

这种设计的核心思想是：**层层嵌套，每个类自己管理自己的逻辑与渲染**。这种分层设计使得代码更加模块化，各部分之间的耦合度降低，便于扩展和维护。

## 继承关系设计

<img src="https://theorhythm.top/gamedev/GE/03-游戏框架设计4.PNG" style='width: 800px;' />

在我们的框架中，通过精心设计的继承关系来组织不同类型的游戏对象：

### 1. Object（基类）

- 所有游戏对象的基类
- 提供基本的功能：handleEvent()、update()、render()、clean()

### 2. 继承自Object的三种主要类型

#### ObjectAffiliate（组件）
- 添加了偏移量和尺寸属性
- 用于实现各种组件，如精灵图、碰撞盒等

#### ObjectScreen（屏幕对象）
- 添加了屏幕坐标属性
- 进一步派生出ObjectWorld（世界对象）
- 适用于需要在屏幕特定位置显示的对象

#### Scene（场景）
- 添加了摄像机功能
- 作为游戏场景的基类

这种继承设计形成了一个清晰的对象层次结构，从抽象的Object基类到具体的游戏实体。特别是"主体+组件"的设计方式，使得游戏对象可以通过组合不同的组件来获得各种功能，而不必通过复杂的继承关系。

## 自动挂载及清理机制

<img src="https://theorhythm.top/gamedev/GE/03-游戏框架设计5.PNG" style='width: 800px;' />

为了简化对象生命周期的管理，我们设计了自动挂载和清理机制：

### 场景容器和对象管理

- Scene类维护一个Object*类型的容器
- 每当场景中创建新的游戏对象，它会自动添加到这个容器中
- 场景的handleEvent()、update()、render()方法会遍历容器，调用每个对象的相应方法
- 在clean()方法中，场景会遍历容器，调用每个对象的clean()，然后删除对象

### 自动生命周期管理的优势

- 对象创建后自动纳入场景管理
- 无需手动调用每个对象的方法
- 场景销毁时自动清理所有对象，避免内存泄漏
- 开发者可以专注于游戏逻辑，而不必担心对象生命周期管理

这种设计遵循了"加入容器即可自动执行功能，且无需手动delete"的原则，极大地简化了游戏编程中常见的资源管理问题。

## 游戏框架设计总结

<img src="https://theorhythm.top/gamedev/GE/03-游戏框架设计6.PNG" style='width: 800px;' />

我们的游戏框架设计基于三个核心原则：

### 1. 模块化

- 每个类的功能独立，职责明确
- 降低了类之间的依赖，提高了代码的可维护性
- 便于团队协作和功能扩展

### 2. 继承+组件的设计方式

- 利用继承建立清晰的对象层次结构
- 通过组件系统实现功能的灵活组合
- 结合了继承和组合两种设计模式的优点

### 3. 自动挂载与清理

- 简化对象生命周期管理
- 自动化的资源管理，减少内存泄漏风险
- 让开发者能够专注于游戏逻辑实现

这种设计框架汲取了现代游戏引擎的设计理念，特别是组件化设计在Unity、Unreal等主流引擎中的应用。通过这种方式，我们可以构建一个既灵活又可维护的游戏系统。

## 下一步

在理解了游戏框架的整体设计后，我们将在后续的课程中逐步实现这个框架的各个部分。从基础的Object类开始，逐步构建起完整的游戏系统，最终实现我们的"幽灵逃生"游戏。

## 思考题

1. 为什么我们选择组件化设计而不是纯粹的继承体系？
2. 自动挂载与清理机制如何简化游戏开发？传统的管理方式有哪些缺点？
3. 如果你要扩展这个框架，添加物理系统或粒子系统，你会如何设计它们与现有框架的集成方式？
