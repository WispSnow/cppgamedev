# 精灵动画类

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/mKTGzWp4LJc?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1gdXLYKEX6&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了基本的精灵图系统，使得游戏对象能够显示图像纹理，让游戏更加生动。然而，静态的图像并不足以表现角色的各种动作和状态变化。在本课中，我们将在精灵图类的基础上实现精灵动画类，使得游戏角色能够具有更加生动的表现形式。

## 精灵动画的需求

在2D游戏中，角色动画通常使用精灵表（Sprite Sheet）实现，这是一种将多个动画帧排列在一起的大图像。例如，一个角色的行走动画可能由8个连续的帧组成，这些帧水平排列在一张图像中。要实现动画效果，我们需要：

1. **帧管理**：管理动画的当前帧、总帧数和帧率
2. **时间控制**：控制动画的播放速度
3. **循环控制**：支持循环播放或单次播放
4. **纹理剪裁**：从精灵表中选择当前要显示的帧
5. **便捷使用**：提供简单的接口来创建和控制动画

## 精灵类的优化

在实现精灵动画类之前，我们先对基础的精灵类（`Sprite`）进行一些优化，使其更便于使用：

```cpp
// sprite.h
class Sprite : public ObjectAffiliate
{
protected:
    Texture texture_;

public:
    static Sprite* addSpriteChild(ObjectScreen* parrent, const std::string& file_path, float scale = 1.0f);

    virtual void render() override;

    void setScale(float scale) { size_ *= scale; }

    // getters and setters
    Texture getTexture() const { return texture_; }
    virtual void setTexture(const Texture &texture);
};
```

我们在精灵类中添加了两个主要改进：

1. **工厂方法**：添加了一个静态方法`addSpriteChild`，用于简化精灵的创建过程
2. **缩放功能**：添加了`setScale`方法，允许调整精灵的大小

工厂方法的实现如下：

```cpp
// sprite.cpp
Sprite *Sprite::addSpriteChild(ObjectScreen *parrent, const std::string &file_path, float scale)
{
    auto sprite = new Sprite();
    sprite->init();
    sprite->setTexture(Texture(file_path));
    sprite->setScale(scale);
    sprite->setParrent(parrent);
    parrent->addChild(sprite);
    return sprite;
}
```

这个方法大大简化了创建精灵的过程，将之前需要多行代码完成的操作封装在一个方法中。它完成以下任务：

1. 创建一个新的精灵对象
2. 初始化精灵
3. 设置纹理（从文件路径创建）
4. 应用缩放
5. 设置父对象
6. 将精灵添加为父对象的子对象
7. 返回创建的精灵，以便进一步配置

另外，我们将`setTexture`方法修改为虚函数，这样派生类可以重写它来提供特定的行为：

```cpp
virtual void setTexture(const Texture &texture);
```

## 实现精灵动画类

有了这些基础，我们现在可以实现精灵动画类（`SpriteAnim`）：

```cpp
// sprite_anim.h
class SpriteAnim : public Sprite
{
    int current_frame_ = 0;
    int total_frames_ = 0;
    int fps_ = 10;
    float frame_timer_ = 0.0f;

public:
    static SpriteAnim* addSpriteAnimChild(ObjectScreen* parrent, const std::string& file_path, float scale = 1.0f);
    virtual void update(float dt) override;

    // getters and setters
    virtual void setTexture(const Texture &texture) override;

    int getCurrentFrame() const { return current_frame_; }
    void setCurrentFrame(int current_frame) { current_frame_ = current_frame; }
    int getTotalFrames() const { return total_frames_; }
    void setTotalFrames(int total_frames) { total_frames_ = total_frames; }
    int getFps() const { return fps_; }
    void setFps(int fps) { fps_ = fps; }
};
```

`SpriteAnim`类继承自`Sprite`类，并添加了以下成员：

1. **当前帧**：`current_frame_`表示当前显示的动画帧
2. **总帧数**：`total_frames_`表示动画的总帧数
3. **帧率**：`fps_`表示每秒播放的帧数
4. **帧计时器**：`frame_timer_`用于控制帧的切换时间

同样，我们为`SpriteAnim`类提供了一个工厂方法，类似于精灵类：

```cpp
// sprite_anim.cpp
SpriteAnim *SpriteAnim::addSpriteAnimChild(ObjectScreen *parrent, const std::string &file_path, float scale)
{
    auto sprite_anim = new SpriteAnim();
    sprite_anim->init();
    sprite_anim->setTexture(Texture(file_path));
    sprite_anim->setScale(scale);
    sprite_anim->setParrent(parrent);
    parrent->addChild(sprite_anim);
    return sprite_anim;
}
```

### 动画更新

精灵动画的核心是`update`方法，它负责根据经过的时间更新当前帧：

```cpp
// sprite_anim.cpp
void SpriteAnim::update(float dt)
{
    frame_timer_ += dt;
    if (frame_timer_ >= 1.0f / fps_)
    {
        current_frame_++;
        if (current_frame_ >= total_frames_)
        {
            current_frame_ = 0;
        }
        frame_timer_ = 0.0f;
    }
    texture_.src_rect.x = texture_.src_rect.w * current_frame_;
}
```

这个方法的工作流程：

1. 累加经过的时间到帧计时器
2. 检查是否达到了下一帧的时间（根据帧率计算）
3. 如果是，则增加当前帧索引
4. 如果当前帧超出了总帧数，则回到第一帧（循环播放）
5. 重置帧计时器
6. 更新纹理的源矩形，以显示当前帧

### 纹理设置

我们重写了`setTexture`方法，使其能够自动计算精灵表中的帧数：

```cpp
// sprite_anim.cpp
void SpriteAnim::setTexture(const Texture &texture)
{
    texture_ = texture;
    total_frames_ = texture.src_rect.w / texture.src_rect.h;
    texture_.src_rect.w = texture.src_rect.h;
    size_ = glm::vec2(texture_.src_rect.w, texture_.src_rect.h);
}
```

这个方法假设精灵表是水平排列的，每个帧的宽度等于其高度（即帧是正方形的）。它做了以下工作：

1. 复制传入的纹理
2. 计算总帧数（原始宽度除以高度）
3. 将源矩形的宽度设置为一个帧的宽度（等于高度）
4. 更新精灵的大小以匹配一个帧的大小

## 在Player类中使用精灵动画

有了精灵动画类，我们可以大大简化玩家角色的初始化代码：

```cpp
// player.cpp
void Player::init()
{
    Actor::init();
    max_speed_ = 500.0f;
    SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-idle.png", 2.0f);
}
```

与之前相比，这段代码更加简洁，使用了工厂方法创建并配置了动画精灵，并将其附加到玩家对象上。

另外，我们移除了绘制红色边界的代码，因为现在我们有了真正的精灵图形：

```cpp
// player.cpp（之前的代码）
void Player::render()
{
    Actor::render();
    game_.drawBoundary(render_position_, render_position_ + glm::vec2(20.0f), 5.0f, {1.0, 0.0, 0.0, 1.0});
}

// player.cpp（当前的代码）
void Player::render()
{
    Actor::render();
}
```

## 渲染顺序优化

为了确保背景在游戏对象之前渲染，我们还调整了`SceneMain`类的`render`方法：

```cpp
// scene_main.cpp（之前的代码）
void SceneMain::render()
{
    Scene::render();
    renderBackground();
}

// scene_main.cpp（当前的代码）
void SceneMain::render()
{
    renderBackground();
    Scene::render();
}
```

这确保了背景首先被渲染，而游戏对象（包括玩家和其精灵）会在背景之上渲染，避免了背景覆盖角色的问题。

## 精灵动画的工作原理

精灵动画的原理是通过快速切换显示图像的不同部分（帧）来创造运动的错觉。这类似于传统动画的工作原理。

<img src="https://theorhythm.top/gamedev/GE/10-精灵动画类.PNG" style='width: 800px;' />

在我们的实现中，整个过程如下：

1. **精灵表加载**：从文件加载包含多个动画帧的大图像
2. **帧计算**：根据图像尺寸自动计算总帧数
3. **帧显示**：通过调整源矩形（`src_rect`）选择当前要显示的帧
4. **时间控制**：根据设定的帧率和经过的时间决定何时切换到下一帧
5. **循环播放**：当达到最后一帧时，回到第一帧开始新的循环

## 总结

在本课中，我们实现了精灵动画类，它扩展了基本的精灵图系统，使游戏角色能够表现更加生动的动画效果。我们还优化了精灵类，添加了工厂方法和缩放功能，简化了精灵的创建和使用。

这些改进使得我们的游戏框架在视觉表现上更加丰富和灵活，为构建更加生动和有吸引力的游戏提供了基础。

## 练习

1. **支持多行精灵表**：修改`SpriteAnim`类，使其能够处理包含多行帧的精灵表。
2. **添加动画控制**：为`SpriteAnim`类添加方法，如`play()`、`pause()`、`stop()`等，以控制动画的播放。
3. **播放模式**：实现不同的播放模式，如单次播放、循环播放、往返播放等。