# 武器类

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/l8V1GJXl6r0?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1QpZrYHELY&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏中，武器系统是角色战斗能力的核心组成部分。一个设计良好的武器系统不仅能够提供多样化的攻击方式，还能为游戏增添策略深度和成长空间。在本课中，我们将设计和实现一个基础的武器系统，为不同类型的攻击提供统一的框架，同时支持特定武器的个性化行为。

<img src="https://theorhythm.top/gamedev/GE/20-武器类.png" style='width: 800px;' />

## 武器系统的意义

武器系统在游戏中具有以下几个关键作用：

1. **攻击多样化**：不同武器提供不同的攻击方式、范围和效果
2. **角色成长**：通过获取新武器或升级现有武器，实现角色能力的提升
3. **资源管理**：武器通常有冷却时间和资源消耗，玩家需要合理管理这些资源
4. **战略选择**：不同场景或敌人类型可能适合使用不同的武器
5. **游戏平衡**：通过调整武器的伤害、冷却时间和消耗，实现游戏的平衡性

在上一课中，我们实现了法术系统，允许玩家通过点击鼠标释放法术攻击敌人。然而，这种实现方式有几个局限性：

1. 法术释放逻辑直接在场景类中处理，不易扩展
2. 没有冷却时间和资源消耗机制
3. 无法实现多种类型的攻击方式

为了解决这些问题，我们将设计一个武器系统，将法术释放的逻辑封装在武器类中，并添加冷却时间和魔法消耗机制。

## 一、设计基础武器类

首先，我们设计一个基础的`Weapon`类作为所有武器类型的父类：

```cpp
// weapon.h
#ifndef WEAPON_H
#define WEAPON_H

#include "../core/object.h"

class Spell;
class Actor;
class Weapon : public Object
{
protected:
    Actor* parent_ = nullptr;
    float cool_down_ = 1.0f;
    float mana_cost_ = 0.0f;
    float cool_down_timer_ = 0.0f;
public:
    virtual void update(float dt) override;
    
    void attack(glm::vec2 position, Spell* spell);  // 确保调用这个函数的时候，一定执行了attack()
    bool canAttack();
    // getters and setters
    float getCoolDown() const { return cool_down_; }
    void setCoolDown(float cool_down) { cool_down_ = cool_down; }
    float getManaCost() const { return mana_cost_; }
    void setManaCost(float mana_cost) { mana_cost_ = mana_cost; }
    void setParent(Actor* parent) { parent_ = parent; }
    Actor* getParent() const { return parent_; }
};

#endif // WEAPON_H
```

`Weapon`类继承自`Object`，这使得它可以作为游戏对象的一部分被添加到场景中。它具有以下关键属性：

- `parent_`：拥有此武器的角色（通常是玩家）
- `cool_down_`：技能冷却时间
- `mana_cost_`：释放技能所需的魔法值
- `cool_down_timer_`：当前冷却计时器

此外，我们声明了三个重要方法：

- `update`：更新武器状态，主要是更新冷却计时器
- `attack`：执行攻击，创建法术并消耗资源
- `canAttack`：检查是否可以攻击（冷却完成且有足够魔法值）

## 二、实现基础武器功能

接下来，我们实现`Weapon`类的具体功能：

```cpp
// weapon.cpp
#include "weapon.h"
#include "../core/actor.h"
#include "../world/spell.h"
#include "stats.h"
#include "../core/scene.h"

void Weapon::update(float dt)
{
    Object::update(dt);
    cool_down_timer_ += dt;
}

void Weapon::attack(glm::vec2 position, Spell* spell)
{
    if (spell == nullptr) return;
    parent_->getStats()->useMana(mana_cost_);
    cool_down_timer_ = 0.0f;
    spell->setPosition(position);
    game_.getCurrentScene()->safeAddChild(spell);
}

bool Weapon::canAttack()
{
    if (cool_down_timer_ < cool_down_) return false;
    if (!parent_->getStats()->canUseMana(mana_cost_)) return false;
    return true;
}
```

让我们详细分析这些方法：

1. **update**：在每一帧更新冷却计时器，使武器逐渐冷却完成。
   
2. **attack**：执行攻击操作。它消耗魔法值，重置冷却计时器，设置法术的位置，并将法术安全地添加到当前场景中。注意我们使用`safeAddChild`而不是直接`addChild`，这是为了避免在遍历对象列表的过程中修改列表导致的问题。

3. **canAttack**：检查武器是否可以攻击。它会检查两个条件：冷却是否完成，以及角色是否有足够的魔法值。只有当两个条件都满足时，才返回`true`。

这种设计使得我们可以为不同类型的武器设置不同的冷却时间和魔法消耗，从而实现多样化的攻击方式。

## 三、设计特定武器类型

有了基础武器类后，我们可以创建特定类型的武器，例如雷电武器：

```cpp
// weapon_thunder.h
#ifndef WEAPON_THUNDER_H
#define WEAPON_THUNDER_H

#include "raw/weapon.h"

class WeaponThunder : public Weapon
{
public:
    static WeaponThunder* addWeaponThunderChild(Actor* parent, float cool_down, float mana_cost);

    virtual void handleEvents(SDL_Event& event) override;
};

#endif // WEAPON_THUNDER_H
```

`WeaponThunder`类继承自`Weapon`，专门用于释放雷电类型的法术。它重写了`handleEvents`方法，以便可以响应特定的输入事件（如鼠标点击）来释放法术。

## 四、实现特定武器功能

接下来，我们实现`WeaponThunder`类的具体功能：

```cpp
// weapon_thunder.cpp
#include "weapon_thunder.h"
#include "world/spell.h"
#include "core/scene.h"
#include "core/actor.h"

WeaponThunder *WeaponThunder::addWeaponThunderChild(Actor *parent, float cool_down, float mana_cost)
{
    auto weapon = new WeaponThunder();
    weapon->init();
    weapon->setParent(parent);
    weapon->setCoolDown(cool_down);
    weapon->setManaCost(mana_cost);
    parent->addChild(weapon);
    return weapon;
}

void WeaponThunder::handleEvents(SDL_Event &event)
{
    if (event.type == SDL_EVENT_MOUSE_BUTTON_DOWN) {
        if (event.button.button == SDL_BUTTON_LEFT) {
            if (canAttack()) {
                auto pos = game_.getMousePosition() + game_.getCurrentScene()->getCameraPosition();
                auto spell = Spell::addSpellChild(nullptr, "assets/effect/Thunderstrike w blur.png", pos, 40.0f, 3.0f, Anchor::CENTER);
                attack(pos, spell);
            }
        }
    }
}
```

这里我们实现了两个方法：

1. **addWeaponThunderChild**：工厂方法，用于创建和初始化一个`WeaponThunder`实例。它设置了父对象、冷却时间和魔法消耗，并将武器添加为父对象的子对象。

2. **handleEvents**：处理输入事件。当检测到鼠标左键点击时，它首先检查是否可以攻击，如果可以，就创建一个雷电法术，并调用基类的`attack`方法执行攻击。

注意这里我们在创建法术时设置了伤害值为40.0f，这与之前直接在场景中创建法术时设置的120.0f有所不同。这种调整可以让我们为不同武器设置不同的伤害值，实现游戏平衡。

## 五、集成到玩家类中

最后，我们需要将武器添加到玩家类中：

```cpp
// player.h
#include "weapon_thunder.h"

class Player : public Actor
{
    WeaponThunder* weapon_thunder_ = nullptr;
    // ... 其他成员
};
```

```cpp
// player.cpp
void Player::init()
{
    Actor::init();
    // ... 其他初始化代码
    weapon_thunder_ = WeaponThunder::addWeaponThunderChild(this, 2.0f, 40.0f);
}
```

这里我们在玩家类中添加了一个`weapon_thunder_`成员，并在初始化时创建了一个雷电武器实例。我们设置了2.0秒的冷却时间和40.0的魔法消耗，这些参数可以根据游戏平衡需求进行调整。

## 六、从场景中移除直接法术创建

由于现在法术的创建和释放由武器负责，我们需要从场景类中移除之前直接创建法术的代码：

```cpp
// scene_main.cpp (之前的代码)
void SceneMain::handleEvents(SDL_Event& event)
{
    Scene::handleEvents(event);
    if (event.type == SDL_EVENT_MOUSE_BUTTON_DOWN)
    {
        if (event.button.button == SDL_BUTTON_LEFT)
        {
            auto pos = game_.getMousePosition() + camera_position_;
            Spell::addSpellChild(this, "assets/effect/Thunderstrike w blur.png", pos, 120.0f, 3.0f, Anchor::CENTER);
        }
    }
}
```

```cpp
// scene_main.cpp (现在的代码)
void SceneMain::handleEvents(SDL_Event& event)
{
    Scene::handleEvents(event);
}
```

这种改变使得攻击逻辑从场景类移到了武器类，实现了更好的责任分离和代码组织。


## 总结

在本课中，我们实现了一个基础的武器系统：

1. 设计并实现了基础`Weapon`类，包含冷却时间和魔法消耗机制
2. 创建了特定的`WeaponThunder`类，实现雷电攻击功能
3. 将武器集成到玩家类中，替代之前直接在场景中创建法术的方式
4. 优化了代码结构，实现了更好的责任分离和扩展性

武器系统的引入使得我们的游戏具备了更丰富的战斗机制和策略深度。玩家现在需要考虑武器的冷却时间和魔法消耗，而不是无限制地释放法术。同时，这一系统也为未来添加更多武器类型和效果奠定了基础。

## 练习

1. **近战武器**：实现一个近战武器类，在玩家周围创建伤害区域
2. **武器切换**：实现一个武器切换系统，允许玩家通过按键切换不同的武器
3. **武器升级**：设计一个武器升级系统，通过收集经验值或资源升级武器
4. **多武器组合**：让玩家可以同时装备多个武器，并实现它们的协同效果
5. **武器特殊效果**：为武器添加特殊效果，如减速、点燃、击退等