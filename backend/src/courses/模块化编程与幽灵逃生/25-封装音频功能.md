# 封装音频功能

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/Vjhnvbs2Cg8?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1suR6YhEwh&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

音频是游戏体验中至关重要的一部分，它能够增强游戏的沉浸感、提供即时反馈，并为玩家创造更加丰富的感官体验。在本课中，我们将设计并实现一个简单而强大的音频系统，使得在游戏中播放背景音乐和音效变得简单直观。

<img src="https://theorhythm.top/gamedev/GE/25-封装音频功能.PNG" style='width: 800px;' />

## 一、音频系统的设计需求

在设计游戏音频系统时，我们需要考虑以下几个关键需求：

1. **类型划分**：清晰区分背景音乐(BGM)和音效(SFX)，它们有不同的使用场景和控制需求
2. **资源管理**：高效管理音频资源，避免重复加载，确保内存使用合理
3. **控制灵活**：提供灵活的播放、暂停、恢复和停止功能
4. **易于集成**：简化接口，使开发者能够轻松地在游戏中添加音频
5. **性能优化**：确保音频处理不会影响游戏的整体性能

## 二、音频系统的基本概念

在深入实现之前，我们先了解一下游戏音频的两个主要类型：

### 1. 背景音乐(BGM)

- **特点**：通常较长，循环播放，音量较低
- **用途**：营造游戏氛围，增强情感体验
- **控制**：通常一次只播放一首，需要支持淡入淡出等过渡效果

### 2. 音效(SFX)

- **特点**：短小精悍，触发即播放，可同时播放多个
- **用途**：提供即时反馈，如攻击、受伤、跳跃等行为的声音
- **控制**：通常需要多通道支持，允许同时播放多个不同的音效

## 三、在Game类中封装音频功能

我们在Game类中添加一组方法来封装SDL_mixer提供的音频功能，使其更易于使用：

```cpp
// game.h（添加音频相关方法）
public:
    // 音频函数
    void playMusic(const std::string& music_path, bool loop = true) { Mix_PlayMusic(asset_store_->getMusic(music_path), loop ? -1 : 0); } //-1代表无限循环
    void playSound(const std::string& sound_path) { Mix_PlayChannel(-1, asset_store_->getSound(sound_path), 0); }
    void stopMusic() { Mix_HaltMusic(); }
    void stopSound() { Mix_HaltChannel(-1); }       // 停止所有音效
    void pauseMusic() { Mix_PauseMusic(); }
    void pauseSound() { Mix_Pause(-1); }
    void resumeMusic() { Mix_ResumeMusic(); }
    void resumeSound() { Mix_Resume(-1); }
```

这些方法提供了以下功能：

1. **playMusic**：播放背景音乐，可选择是否循环
2. **playSound**：播放音效
3. **stopMusic/stopSound**：停止背景音乐/所有音效
4. **pauseMusic/pauseSound**：暂停背景音乐/所有音效
5. **resumeMusic/resumeSound**：恢复背景音乐/所有音效

注意，这些方法都是对SDL_mixer库函数的简单封装，但它们使用了`asset_store_`来获取音频资源，这确保了音频文件只被加载一次，从而优化了内存使用。

## 四、AssetStore中的音频资源管理

在实现音频系统时，我们利用了已有的`AssetStore`类来管理音频资源。让我们来看看`AssetStore`是如何处理音频资源的：

```cpp
// asset_store.h（音频相关部分）
class AssetStore
{
    SDL_Renderer *renderer_ = nullptr;
    std::unordered_map<std::string, SDL_Texture*> textures_;
    std::unordered_map<std::string, Mix_Chunk*> sounds_;
    std::unordered_map<std::string, Mix_Music*> music_;
    std::unordered_map<std::string, TTF_Font*> fonts_;

public:
    // ...
    void loadSound(const std::string& file_path);
    void loadMusic(const std::string& file_path);
    // ...
    Mix_Chunk* getSound(const std::string& file_path);
    Mix_Music* getMusic(const std::string& file_path);
    // ...
};
```

`AssetStore`类使用哈希表（`std::unordered_map`）来存储音频资源，这提供了快速的查找性能。它为音效（Sound）和背景音乐（Music）分别提供了加载和获取方法：

```cpp
// asset_store.cpp (音效加载与获取)
void AssetStore::loadSound(const std::string &file_path)
{
    Mix_Chunk *sound = Mix_LoadWAV(file_path.c_str());
    if (sound == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to load sound: %s", file_path.c_str());
        return;
    }
    sounds_.emplace(file_path, sound);
}

Mix_Chunk *AssetStore::getSound(const std::string &file_path)
{
    auto iter = sounds_.find(file_path);
    if (iter == sounds_.end())          // 如果没有找到，则载入。
    {
        loadSound(file_path);
        iter = sounds_.find(file_path);
    }
    if (iter == sounds_.end())          // 如果载入失败，则返回空指针。
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to get sound: %s", file_path.c_str());
        return nullptr;
    }
    return iter->second;
}
```

```cpp
// asset_store.cpp (背景音乐加载与获取)
void AssetStore::loadMusic(const std::string &file_path)
{
    Mix_Music *music = Mix_LoadMUS(file_path.c_str());
    if (music == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to load music: %s", file_path.c_str());
        return;
    }
    music_.emplace(file_path, music);
}

Mix_Music *AssetStore::getMusic(const std::string &file_path)
{
    auto iter = music_.find(file_path);
    if (iter == music_.end())           // 如果没有找到，则载入。
    {
        loadMusic(file_path);
        iter = music_.find(file_path);
    }
    if (iter == music_.end())           // 如果载入失败，则返回空指针。
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to get music: %s", file_path.c_str());
        return nullptr;
    }
    return iter->second;
}
```

`AssetStore`还负责在游戏结束时释放这些资源：

```cpp
// asset_store.cpp (资源清理部分)
void AssetStore::clean()
{
    // ... 纹理清理 ...

    for (auto &sound : sounds_)
    {
        Mix_FreeChunk(sound.second);
    }
    sounds_.clear();

    for (auto &music : music_)
    {
        Mix_FreeMusic(music.second);
    }
    music_.clear();

    // ... 字体清理 ...
}
```

这种设计有几个关键优势：

1. **懒加载**：资源只在第一次被请求时才会加载，避免了不必要的内存使用
2. **资源复用**：同一个音频文件只会被加载一次，多次使用同一个资源实例，节省内存
3. **统一管理**：所有资源在游戏结束时被统一释放，避免了内存泄漏
4. **封装**：游戏代码不需要直接处理SDL_mixer资源，而是通过AssetStore间接操作

通过将音频资源管理集成到AssetStore中，我们确保了游戏中的音频文件得到了高效、安全的管理，这是一个良好的音频系统的基础。

## 五、在游戏中应用音频系统

有了封装好的音频功能，我们可以在游戏的各个部分轻松地添加声音。让我们看一些具体的应用示例：

### 1. 添加背景音乐

在游戏场景初始化时，我们可以添加背景音乐：

```cpp
// scene_main.cpp
void SceneMain::init()
{
    SDL_HideCursor();
    game_.playMusic("assets/bgm/OhMyGhost.ogg");  // 播放背景音乐
    // ... 其他初始化代码
}
```

这里我们在主场景初始化时播放了一个名为"OhMyGhost.ogg"的背景音乐，默认设置为循环播放，这样音乐会一直伴随玩家的游戏过程。

### 2. 添加角色音效

为了使游戏角色更加生动，我们可以为各种行为添加音效：

```cpp
// player.cpp
void Player::takeDamage(float damage)
{
    if (!stats_ || stats_->getInvincible()) return;
    Actor::takeDamage(damage);
    game_.playSound("assets/sound/hit-flesh-02-266309.mp3");  // 播放受伤音效
}

void Player::checkIsDead()
{
    if (stats_ && stats_->getHealth() <= 0 && !effect_)
    {
        effect_ = Effect::addEffectChild(nullptr, "assets/effect/184_1.png", getPosition(), 1.0f, nullptr);
        game_.getCurrentScene()->safeAddChild(effect_);
        effect_->setPosition(getPosition());
        setActive(false);
        game_.playSound("assets/sound/female-scream-02-89290.mp3");  // 播放死亡音效
    }
}
```

这里我们为玩家角色添加了两种音效：
- 受伤时播放"hit-flesh-02-266309.mp3"
- 死亡时播放"female-scream-02-89290.mp3"

这些音效提供了即时的听觉反馈，增强了玩家的沉浸感。

### 3. 添加敌人生成音效

当敌人生成时，播放音效可以提醒玩家注意：

```cpp
// spawner.cpp
void Spawner::update(float dt)
{
    timer_ += dt;
    if (timer_ >= interval_)
    {
        timer_ = 0;
        game_.playSound("assets/sound/silly-ghost-sound-242342.mp3");  // 播放敌人生成音效
        for (int i = 0; i < num_; i++)
        {
            // spawn enemy
            // ... 敌人生成代码
        }
    }
}
```

每当敌人生成器创建新敌人时，我们播放"silly-ghost-sound-242342.mp3"音效，这不仅增加了游戏的氛围，还为玩家提供了敌人即将出现的提示。

### 4. 添加武器音效

武器攻击时的音效可以增强攻击的力量感：

```cpp
// weapon_thunder.cpp
void WeaponThunder::handleEvents(SDL_Event &event)
{
    if (event.type == SDL_EVENT_MOUSE_BUTTON_DOWN) {
        if (event.button.button == SDL_BUTTON_LEFT) {
            if (canAttack()) {
                game_.playSound("assets/sound/big-thunder.mp3");  // 播放雷电攻击音效
                auto pos = game_.getMousePosition() + game_.getCurrentScene()->getCameraPosition();
                auto spell = Spell::addSpellChild(nullptr, "assets/effect/Thunderstrike w blur.png", pos, 40.0f, 3.0f, Anchor::CENTER);
                attack(pos, spell);
            }
        }
    }
}
```

当玩家使用雷电武器攻击时，我们播放"big-thunder.mp3"音效，这与视觉效果相配合，使攻击感觉更加震撼。

## 总结

在本课中，我们实现了一个基础的游戏音频系统：

1. 设计并封装了音频功能，包括背景音乐和音效的播放、暂停、恢复和停止
2. 通过AssetStore类实现了高效的音频资源管理
3. 在游戏的各个部分集成了音频，增强了游戏体验
4. 讨论了系统的进一步改进和扩展可能性

音频系统的实现使得我们的游戏更加生动和沉浸式，玩家不仅可以看到游戏世界，还可以听到它。从背景音乐营造的氛围到即时反馈的音效，声音为游戏添加了全新的维度。

## 练习

1. **音量控制**：实现音量控制功能，允许玩家调整背景音乐和音效的音量
2. **环境音效**：添加环境音效，如风声、波纹声等，增强游戏的沉浸感