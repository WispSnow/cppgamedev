# 设置组件的锚点

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/vo_RirZvktk?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1PdX8YaEGU&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏开发中，精确定位游戏元素是一项常见但重要的任务。无论是UI元素、精灵还是碰撞盒，它们都需要相对于某个参考点进行定位。在上一课中，我们实现了碰撞盒组件，但可能注意到所有组件都是以左上角为基准点进行定位的，这在某些情况下并不直观或方便。在本课中，我们将实现一个锚点系统，使组件能够根据不同的参考点进行定位。

## 锚点系统的意义

锚点（Anchor）是一个指定组件如何相对于其父对象定位的参考点。它解决了以下问题：

1. **直观定位**：使用自然的参考点（如中心、底部中心等）定位组件
2. **一致性**：确保不同大小的组件可以使用相同的定位逻辑
3. **适应性**：当组件大小改变时，保持相对位置关系不变
4. **精确对齐**：轻松实现元素之间的对齐（如居中对齐、底部对齐）

## 设计锚点系统

首先，我们需要定义可用的锚点位置。在我们的设计中，我们定义了九个基本锚点，覆盖了组件边界框的主要参考点：

```cpp
// defs.h
enum class Anchor
{
    NONE,
    TOP_LEFT,
    TOP_CENTER,
    TOP_RIGHT,
    CENTER_LEFT,
    CENTER,
    CENTER_RIGHT,
    BOTTOM_LEFT,
    BOTTOM_CENTER,
    BOTTOM_RIGHT,
};
```

这些锚点代表了组件边界框上的9个关键点：四个角、四个边的中点和中心点。`NONE`是一个特殊值，表示不应用任何自动偏移计算。

## 在基类中实现锚点系统

为了使所有组件都能利用锚点系统，我们在`ObjectAffiliate`基类中实现它：

```cpp
// object_affiliate.h
class ObjectAffiliate : public Object
{
protected:
    ObjectScreen *parrent_ = nullptr;
    glm::vec2 offset_ = glm::vec2(0, 0);
    glm::vec2 size_ = glm::vec2(0, 0);
    Anchor anchor_ = Anchor::CENTER; // 默认使用中心点作为锚点

public:
    void setOffsetByAnchor(Anchor anchor);

    // getters and setters
    ObjectScreen *getParent() const { return parrent_; }
    void setParent(ObjectScreen *parrent) { parrent_ = parrent; }
    glm::vec2 getOffset() const { return offset_; }
    void setOffset(const glm::vec2 &offset) { offset_ = offset; }
    glm::vec2 getSize() const { return size_; }
    void setSize(const glm::vec2 &size);
    void setScale(float scale);
    Anchor getAnchor() const { return anchor_; }
    void setAnchor(Anchor anchor) { anchor_ = anchor; }
};
```

注意我们添加了三个新的方法：
1. `setOffsetByAnchor`：根据锚点更新偏移值
2. 修改了`setSize`：设置大小后更新锚点偏移
3. 新增`setScale`：缩放大小并更新锚点偏移

## 根据锚点计算偏移

锚点系统的核心是根据选定的锚点自动计算偏移值。我们在`ObjectAffiliate`类中实现了这个功能：

```cpp
// object_affiliate.cpp
void ObjectAffiliate::setOffsetByAnchor(Anchor anchor)
{
    anchor_ = anchor;
    switch (anchor)
    {
        case Anchor::TOP_LEFT:
            offset_ = glm::vec2(0.0f, 0.0f);
            break;
        case Anchor::TOP_CENTER:
            offset_ = glm::vec2(-size_.x / 2.0f, 0);
            break;
        case Anchor::TOP_RIGHT:
            offset_ = glm::vec2(-size_.x, 0.0f);
            break;
        case Anchor::CENTER_LEFT:
            offset_ = glm::vec2(0.0f, -size_.y / 2.0f);
            break;
        case Anchor::CENTER:
            offset_ = glm::vec2(-size_.x / 2.0f, -size_.y / 2.0f);
            break;
        case Anchor::CENTER_RIGHT:
            offset_ = glm::vec2(-size_.x, -size_.y / 2.0f);
            break;
        case Anchor::BOTTOM_LEFT:
            offset_ = glm::vec2(0.0f, -size_.y);
            break;
        case Anchor::BOTTOM_CENTER:
            offset_ = glm::vec2(-size_.x / 2.0f, -size_.y);
            break;
        case Anchor::BOTTOM_RIGHT:
            offset_ = glm::vec2(-size_.x, -size_.y);
            break;
        default:
            break;
    }
}
```

这个方法根据不同的锚点位置计算相应的偏移值。让我们分析几个例子：

1. **TOP_LEFT (左上角)**：
   - 偏移为(0,0)，意味着组件的左上角与父对象的位置重合

2. **CENTER (中心点)**：
   - 偏移为(-size.x/2, -size.y/2)，意味着组件的中心与父对象的位置重合

3. **BOTTOM_RIGHT (右下角)**：
   - 偏移为(-size.x, -size.y)，意味着组件的右下角与父对象的位置重合

这些偏移值的计算基于组件大小和所选锚点，确保组件相对于父对象的位置符合预期。

## 支持大小和比例的变化

当组件的大小改变时，我们需要重新计算偏移值以保持锚点位置的一致性。为此，我们修改了`setSize`和添加了`setScale`方法：

```cpp
// object_affiliate.cpp
void ObjectAffiliate::setSize(const glm::vec2 &size) 
{
    size_ = size;
    setOffsetByAnchor(anchor_); // 更新大小后重新计算偏移
}

void ObjectAffiliate::setScale(float scale)
{
    size_ *= scale; // 缩放大小
    setOffsetByAnchor(anchor_); // 更新偏移
}
```

这样，无论组件大小如何变化，它都能保持正确的定位关系。

## 应用锚点系统

现在，所有组件创建方法都支持指定锚点。我们修改了`Sprite`、`SpriteAnim`和`Collider`类的工厂方法：

```cpp
// sprite.h
static Sprite* addSpriteChild(ObjectScreen* parrent, const std::string& file_path, float scale = 1.0f, Anchor anchor = Anchor::CENTER);

// sprite_anim.h
static SpriteAnim* addSpriteAnimChild(ObjectScreen* parrent, const std::string& file_path, float scale = 1.0f, Anchor anchor = Anchor::CENTER);

// collider.h
static Collider* addColliderChild(ObjectScreen* parent, glm::vec2 size, Type type = Type::CIRCLE, Anchor anchor = Anchor::CENTER);
```

这些方法现在允许在创建组件时指定锚点，默认为中心点。

## 优化碰撞盒大小

锚点系统的一个实际应用是优化碰撞盒。之前，我们的碰撞盒与精灵大小相同，这可能导致碰撞检测不够精确。现在，我们可以调整碰撞盒大小，同时使用中心锚点确保它居中对齐：

```cpp
// player.cpp
void Player::init()
{
    Actor::init();
    sprite_idle_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-idle.png", 2.0f);
    sprite_move_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-move.png", 2.0f);
    sprite_move_->setActive(false);

    // 使用精灵大小的一半作为碰撞盒大小，使碰撞更精确
    collider_ = Collider::addColliderChild(this, sprite_idle_->getSize() / 2.0f);
}
```

在这个例子中，我们将玩家的碰撞盒大小设置为精灵大小的一半，使碰撞检测更加精确。由于使用了中心锚点，这个碰撞盒仍然完美地居中于玩家对象。

## 锚点系统的原理分析

为了更好地理解锚点系统的工作原理，让我们分析当一个组件使用不同锚点时会发生什么：

### 使用TOP_LEFT锚点（左上角）

```
+------+
|      |
|      |   组件
|      |
+------+
^
|
父对象位置
```

- 偏移量：(0, 0)
- 组件的左上角与父对象位置重合

### 使用CENTER锚点（中心）

```
     父对象位置
        |
        v
     +------+
     |      |
     |   X  |   组件（X表示中心）
     |      |
     +------+
```

- 偏移量：(-width/2, -height/2)
- 组件的中心与父对象位置重合

### 使用BOTTOM_RIGHT锚点（右下角）

```
        父对象位置
        |
        v
+------+
|      |
|      |   组件
|      |
+------+
```

- 偏移量：(-width, -height)
- 组件的右下角与父对象位置重合

这种方法允许组件相对于父对象的任何关键点进行定位，提供了极大的灵活性。

## 锚点系统的优势

实现锚点系统带来了以下优势：

1. **简化定位**：不需要手动计算偏移量，只需选择合适的锚点
2. **适应性强**：当组件大小变化时，位置关系自动保持
3. **一致性**：所有组件使用相同的定位逻辑
4. **更直观**：使用自然的参考点进行定位
5. **减少错误**：避免手动计算偏移时的错误

## 锚点系统的应用场景

锚点系统在游戏开发中有多种应用场景：

1. **UI元素定位**：不同屏幕分辨率下保持UI元素的相对位置
2. **精灵定位**：确保角色的特定部位（如脚部）对齐地面
3. **碰撞盒优化**：为不同形状的物体创建精确的碰撞盒
4. **特效定位**：将粒子效果定位在角色的特定位置（如手中的武器）
5. **相机跟随**：设置相机锚点来决定跟随目标的哪个部分

## 命名一致性的改进

在这次更新中，我们还修正了一些命名一致性问题：

1. 将方法名从`getParrent`/`setParrent`改为`getParent`/`setParent`，更正了拼写错误
2. 在组件创建方法中统一使用`parent`参数名

虽然为了向后兼容，我们保留了`parrent_`成员变量名，但接口方法已经更正，未来可以逐步统一。

## 总结

在本课中，我们实现了一个灵活的锚点系统：

1. 定义了九个基本锚点位置，覆盖了组件边界的关键点
2. 在`ObjectAffiliate`基类中实现了锚点系统，使所有组件都能受益
3. 添加了自动计算偏移的逻辑，简化了组件定位
4. 确保了大小和比例变化时位置关系的一致性
5. 应用锚点系统优化了碰撞盒的定位

锚点系统是一个简单但强大的工具，它大大简化了游戏开发中的元素定位工作。通过使用锚点，我们可以更直观、更精确地控制游戏元素的位置关系，无论它们的大小如何变化。

在下一课中，我们将继续改进游戏引擎，添加更多功能和优化现有系统。

## 练习

1. **自定义锚点**：扩展锚点系统，支持自定义百分比锚点（如25%宽度，75%高度）
2. **锚点动画**：实现一个功能，允许组件在不同锚点之间平滑过渡
3. **相对锚点**：创建一个系统，允许组件相对于另一个组件的锚点进行定位
4. **网格定位**：使用锚点系统实现一个简单的网格布局系统，自动排列元素