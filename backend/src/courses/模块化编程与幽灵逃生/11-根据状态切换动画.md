# 11-根据状态切换动画

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/Uqgj1gLpSo8?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1hPXFYRESo&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了精灵动画类，使游戏角色能够显示动态的图像。然而，一个游戏角色通常有多种状态，例如站立、行走、跳跃等，每种状态都应该有对应的动画。本课将介绍如何根据角色状态自动切换不同的动画，使我们的游戏更加生动。

## 游戏对象的活跃状态控制

在实现动画状态切换之前，我们首先需要一种机制来控制游戏对象的显示与隐藏。一种简单的方法是为每个游戏对象添加一个"活跃"状态标志。

### 为Object类添加活跃状态标志

我们在基础`Object`类中添加了一个布尔成员变量和相应的方法：

```cpp
// object.h
class Object
{
protected:
    // ... 其他成员变量
    bool is_active_ = true;

public:
    // ... 其他方法
    void setActive(bool active) { is_active_ = active; }
    bool getActive() const { return is_active_; }
};
```

`is_active_`变量默认为`true`，表示对象处于活跃状态。

### 修改生命周期方法

接下来，我们需要修改对象的生命周期方法（`handleEvents`、`update`、`render`），使它们只处理活跃的对象：

```cpp
// object.cpp
void Object::handleEvents(SDL_Event& event) {
    for (auto& child : children_) {
        if(child->getActive()) {
            child->handleEvents(event);
        }
    }
}

void Object::update(float dt) {
    for (auto& child : children_) {
        if(child->getActive()) {
            child->update(dt);
        }
    }
} 

void Object::render() {
    for (auto& child : children_) {
        if(child->getActive()) {
            child->render();
        }
    }
}
```

类似地，我们也需要修改`Scene`类的相应方法，确保只处理活跃的子对象。

这些修改使我们能够通过简单地设置`is_active_`属性来控制对象是否参与游戏循环。对于动画切换，我们可以让一个对象拥有多个动画精灵，但在任何时候只激活其中一个。

## 精灵类的增强

为了更好地支持动画状态切换，我们扩展了`Sprite`类的功能：

```cpp
// sprite.h
class Sprite : public ObjectAffiliate
{
    // ... 其他成员和方法
public:
    // ... 其他方法
    void setFlip(bool is_flip) { texture_.is_flip = is_flip; }
    void setAngle(float angle) { texture_.angle = angle; }
    bool getFlip() const { return texture_.is_flip; }
    float getAngle() const { return texture_.angle; }
};
```

这些新方法允许我们：
- 控制精灵的水平翻转（通过`setFlip`）
- 设置精灵的旋转角度（通过`setAngle`）
- 获取当前的翻转和旋转状态

同时，我们在`SpriteAnim`类中也添加了一些方法，用于在动画切换时保持连续性：

```cpp
// sprite_anim.h
class SpriteAnim : public Sprite
{
    // ... 其他成员和方法
public:
    // ... 其他方法
    float getFrameTimer() const { return frame_timer_; }
    void setFrameTimer(float frame_timer) { frame_timer_ = frame_timer; }
};
```

这些新方法允许我们：
- 获取当前帧计时器的值（通过`getFrameTimer`）
- 设置帧计时器的值（通过`setFrameTimer`）

## 玩家角色的多状态动画

现在，我们可以为玩家角色实现多状态动画。首先，我们需要在`Player`类中添加相关的成员变量：

```cpp
// player.h
class Player : public Actor
{
    SpriteAnim* sprite_idle_ = nullptr;
    SpriteAnim* sprite_move_ = nullptr;
    bool is_moving_ = false;

public:
    // ... 其他方法
    void checkState();
    void changeState(bool is_moving);
};
```

我们添加了：
- 两个动画精灵：`sprite_idle_`（静止动画）和`sprite_move_`（移动动画）
- 一个状态标志：`is_moving_`（表示玩家是否在移动）
- 两个新方法：`checkState`（检查并更新状态）和`changeState`（根据状态切换动画）

### 初始化动画精灵

在`Player::init`方法中，我们创建并初始化两个动画精灵：

```cpp
// player.cpp
void Player::init()
{
    Actor::init();
    max_speed_ = 500.0f;
    sprite_idle_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-idle.png", 2.0f);
    sprite_move_ = SpriteAnim::addSpriteAnimChild(this, "assets/sprite/ghost-move.png", 2.0f);
    sprite_move_->setActive(false);
}
```

注意，我们初始化时只激活了静止动画精灵，移动动画精灵设置为非活跃状态。

### 状态检查和动画切换

在每一帧的更新过程中，我们需要根据玩家的状态决定显示哪个动画：

```cpp
// player.cpp
void Player::update(float dt)
{
    Actor::update(dt);
    keyboardControl();
    velocity_ *= 0.9f;
    checkState();
    move(dt);
    syncCamera();
}
```

`checkState`方法检查玩家的移动状态，并根据移动方向设置精灵的翻转：

```cpp
// player.cpp
void Player::checkState()
{
    if (velocity_.x < 0){
        sprite_move_->setFlip(true);
        sprite_idle_->setFlip(true);
    }else{
        sprite_move_->setFlip(false);
        sprite_idle_->setFlip(false);
    }
    
    bool new_is_moving = (glm::length(velocity_) > 0.1f);
    if (new_is_moving != is_moving_){
        is_moving_ = new_is_moving;
        changeState(is_moving_);
    }
}
```

这个方法做了两件事：
1. 根据水平速度方向设置精灵的翻转状态（向左移动时翻转）
2. 检测玩家是否在移动（速度大小超过阈值），如果状态发生变化，则调用`changeState`方法

`changeState`方法负责切换动画状态：

```cpp
// player.cpp
void Player::changeState(bool is_moving)
{
    if (is_moving){
        sprite_idle_->setActive(false);
        sprite_move_->setActive(true);
        sprite_move_->setCurrentFrame(sprite_idle_->getCurrentFrame());
        sprite_move_->setFrameTimer(sprite_idle_->getFrameTimer());
        
    }else{
        sprite_idle_->setActive(true);
        sprite_move_->setActive(false);
        sprite_idle_->setCurrentFrame(sprite_move_->getCurrentFrame());
        sprite_idle_->setFrameTimer(sprite_move_->getFrameTimer());
    }
}
```

这个方法做了以下工作：
1. 根据状态激活对应的动画精灵，停用另一个
2. 将当前帧索引和帧计时器值从旧动画复制到新动画

最后一步很重要，它确保了动画切换的平滑性。如果不保持当前帧和计时器值，每次切换动画时都会从第一帧开始，这会导致动画看起来不连贯。

## 动画切换的工作原理

让我们更详细地了解动画切换的工作原理：

1. **状态检测**：在每一帧，我们都会检查玩家的状态（如移动状态）。
2. **状态变化处理**：如果状态发生变化（如从静止变为移动），我们需要切换动画。
3. **动画切换**：切换动画包括停用当前动画精灵，激活新的动画精灵。
4. **保持连续性**：为了使切换看起来平滑，我们需要保持动画的连续性，这包括：
   - 复制当前帧索引
   - 复制帧计时器值
   - 保持精灵的翻转状态

通过这种方式，玩家不会察觉到动画的突然跳跃，切换会看起来很自然。

## 状态切换机制的可扩展性

我们目前实现的状态切换机制很简单，只有两种状态：静止和移动。但这种机制非常容易扩展到更多状态：

1. 添加更多的动画精灵成员变量（如`sprite_jump_`、`sprite_attack_`等）
2. 在`init`方法中初始化这些精灵
3. 扩展`checkState`方法，检测更多的状态
4. 扩展`changeState`方法，处理更多的状态切换

例如，我们可以添加一个跳跃状态：

```cpp
// player.h
class Player : public Actor
{
    SpriteAnim* sprite_idle_ = nullptr;
    SpriteAnim* sprite_move_ = nullptr;
    SpriteAnim* sprite_jump_ = nullptr;
    
    enum State { IDLE, MOVING, JUMPING };
    State current_state_ = IDLE;
    
    // ... 其他成员和方法
};
```

然后修改`checkState`和`changeState`方法来处理这个新状态。

## 总结

在本课中，我们学习了如何根据游戏对象的状态自动切换不同的动画。我们实现了：

1. 游戏对象的活跃状态控制机制，使我们能够轻松地显示或隐藏对象
2. 精灵类的扩展功能，包括翻转、旋转控制，以及动画帧和计时器的访问
3. 玩家角色的多状态动画系统，能够根据移动状态自动切换动画
4. 保持动画连续性的机制，确保切换时不会有明显的跳跃

这些功能使我们的游戏角色更加生动，响应玩家的输入和游戏状态的变化。在实际游戏中，我们可以扩展这个系统，添加更多的状态和动画，使角色表现更加丰富。

## 练习

1. **添加跳跃状态**：为玩家角色添加跳跃状态和对应的动画。当玩家按下空格键时，应该切换到跳跃动画。

2. **受伤状态效果**：添加一个受伤状态，当玩家受到伤害时触发。受伤时精灵应该短暂闪烁（可以通过快速切换精灵的可见性实现）。

3. **优化翻转逻辑**：改进翻转逻辑，使精灵的翻转更加平滑，例如添加一个小延迟，避免角色在快速变换方向时频繁翻转。

