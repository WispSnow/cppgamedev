# 玩家角色与摄像机跟随

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/tyDdl8dAA7s?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1MVQNYcEtX&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了背景网格和相机系统，这使得我们可以创建一个比屏幕更大的游戏世界。然而，一个只有网格和边界的世界显然是不够有趣的。在这一课中，我们将添加游戏中最重要的元素之一：玩家角色。

同时，我们还将实现一个重要的游戏特性：摄像机跟随。这将使得玩家角色始终保持在屏幕的中心区域，提供更好的游戏体验。

## 设计游戏对象层次结构

在我们的框架中，所有游戏对象都继承自`Object`基类。但为了构建复杂的游戏系统，我们需要一个更精细的对象层次结构，特别是对于需要在世界和屏幕坐标系中定位的对象。

### 继承关系图

我们设计了以下继承层次：

```
Object → ObjectScreen → ObjectWorld → Actor → Player
```

这种层次结构的每一层都添加了特定的功能：

1. **Object**：基础类，提供生命周期方法（init, update, render等）
2. **ObjectScreen**：添加屏幕渲染位置
3. **ObjectWorld**：添加世界坐标系中的位置
4. **Actor**：添加速度和最大速度等运动属性
5. **Player**：实现具体的玩家逻辑

### ObjectScreen类

首先，我们创建了`ObjectScreen`类，用于处理屏幕上的渲染位置：

```cpp
// object_screen.h
#ifndef OBJECT_SCREEN_H
#define OBJECT_SCREEN_H

#include "object.h"

class ObjectScreen : public Object
{
protected:
    glm::vec2 render_position_ = glm::vec2(0, 0); // 渲染(屏幕)位置

public:
    // getters and stters
    glm::vec2 getRenderPosition() const { return render_position_; }
    virtual void setRenderPosition(const glm::vec2 &render_position) { render_position_ = render_position; }
};

#endif // OBJECT_SCREEN_H
```

`ObjectScreen`类的主要作用是管理对象在屏幕上的渲染位置，这对于UI元素或者直接在屏幕坐标系中定位的对象非常有用。

### ObjectWorld类

接下来，我们创建了`ObjectWorld`类，它继承自`ObjectScreen`，并添加了世界坐标系中的位置：

```cpp
// object_world.h
#ifndef OBJECT_WORLD_H
#define OBJECT_WORLD_H

#include "object_screen.h"

class ObjectWorld : public ObjectScreen
{
protected:
    glm::vec2 position_ = glm::vec2(0, 0); // 世界位置

public:
    virtual void update(float dt) override;
    // getters and stters
    glm::vec2 getPosition() const { return position_; }
    void setPosition(const glm::vec2 &position);
    virtual void setRenderPosition(const glm::vec2 &render_position) override;
};

#endif // OBJECT_WORLD_H
```

`ObjectWorld`类的实现部分：

```cpp
// object_world.cpp
#include "object_world.h"
#include "scene.h"

void ObjectWorld::update(float dt)
{
    ObjectScreen::update(dt);
    render_position_ = game_.getCurrentScene()->worldToScreen(position_);
}

void ObjectWorld::setPosition(const glm::vec2 &position)
{
    position_ = position;
    render_position_ = game_.getCurrentScene()->worldToScreen(position_);
}

void ObjectWorld::setRenderPosition(const glm::vec2 &render_position)
{
    render_position_ = render_position;
    position_ = game_.getCurrentScene()->screenToWorld(render_position);
}
```

`ObjectWorld`类的关键功能：

1. **双向坐标转换**：当设置世界位置时，自动更新渲染位置；反之亦然
2. **自动同步**：在update方法中自动同步世界位置和渲染位置
3. **场景关联**：通过Game类获取当前场景进行坐标转换

### Actor类

为了支持有移动能力的角色，我们创建了`Actor`类：

```cpp
// actor.h
#ifndef ACTOR_H
#define ACTOR_H

#include "object_world.h"

class Actor : public ObjectWorld
{
protected:
    glm::vec2 velocity_ = glm::vec2(0, 0); // 速度
    float max_speed_ = 100.0f; // 最大速度大小

public:
    // getters and setters
    glm::vec2 getVelocity() const { return velocity_; }
    void setVelocity(const glm::vec2 &velocity) { velocity_ = velocity; }
    float getMaxSpeed() const { return max_speed_; }
    void setMaxSpeed(float max_speed) { max_speed_ = max_speed; }
};

#endif // ACTOR_H
```

`Actor`类添加了：

1. **速度向量**：表示角色在x和y方向上的移动速度
2. **最大速度**：限制角色移动的最大速度
3. **相关的getter和setter**：用于访问和修改这些属性

## 实现Player类

有了这个继承结构，我们可以实现具体的`Player`类：

```cpp
// player.h
#ifndef PLAYER_H
#define PLAYER_H

#include "core/actor.h"

class Player : public Actor
{
public:
    virtual void init() override;
    virtual void handleEvents(SDL_Event& event) override;
    virtual void update(float dt) override;
    virtual void render() override;
    virtual void clean() override;

    void keyboardControl();
    void move(float dt);
    void syncCamera();
};

#endif // PLAYER_H
```

`Player`类的实现：

```cpp
// player.cpp
#include "player.h"
#include "core/scene.h"

void Player::init()
{
    max_speed_ = 500.0f;
}

void Player::handleEvents(SDL_Event& event)
{
}

void Player::update(float dt)
{
    keyboardControl();
    velocity_ *= 0.9f;
    move(dt);
    syncCamera();
}

void Player::render()
{
    game_.drawBoundary(render_position_, render_position_ + glm::vec2(20.0f), 5.0f, {1.0, 0.0, 0.0, 1.0});
}

void Player::clean()
{
}

void Player::keyboardControl()
{
    auto currentKeyStates = SDL_GetKeyboardState(NULL);
    if (currentKeyStates[SDL_SCANCODE_W]){
        velocity_.y = -max_speed_;
    }
    if (currentKeyStates[SDL_SCANCODE_S]){
        velocity_.y = max_speed_;
    }
    if (currentKeyStates[SDL_SCANCODE_A]){
        velocity_.x = -max_speed_;
    }
    if (currentKeyStates[SDL_SCANCODE_D]){
        velocity_.x = max_speed_;
    }
}

void Player::move(float dt)
{
    setPosition(position_ + velocity_ * dt);
    SDL_Log("dt: %f, position: (%f, %f), velocity: (%f, %f)", dt, position_.x, position_.y, velocity_.x, velocity_.y);
    position_ = glm::clamp(position_, glm::vec2(0), game_.getCurrentScene()->getWorldSize());
}

void Player::syncCamera()
{
    game_.getCurrentScene()->setCameraPosition(position_ - game_.getScreenSize() / 2.0f);
}
```

`Player`类的核心功能：

1. **初始化**：设置最大速度为500
2. **键盘控制**：使用WASD键控制玩家移动
3. **速度衰减**：每帧减少10%的速度，实现逐渐停止的效果
4. **移动和边界检查**：基于速度更新位置，并确保玩家不会移出世界边界
5. **相机同步**：使相机跟随玩家，保持玩家在屏幕中心
6. **渲染**：将玩家绘制为一个红色方块

### 相机跟随实现

相机跟随功能是在`Player`类的`syncCamera`方法中实现的：

```cpp
void Player::syncCamera()
{
    game_.getCurrentScene()->setCameraPosition(position_ - game_.getScreenSize() / 2.0f);
}
```

这个方法计算的相机位置，使得玩家位于屏幕中心。计算方法是：
- 相机位置 = 玩家位置 - 屏幕尺寸的一半

## Scene类的改进

为了支持玩家角色和相机跟随，我们对Scene类进行了一些改进：

### 添加world_size_属性

```cpp
// scene.h中添加
protected:
    glm::vec2 world_size_ = glm::vec2(0); // 世界大小
```

### 添加坐标转换方法

```cpp
// scene.h中添加
public:
    glm::vec2 worldToScreen(const glm::vec2 &world_position) const {return world_position - camera_position_; }
    glm::vec2 screenToWorld(const glm::vec2 &screen_position) const {return screen_position + camera_position_; }
```

### 相机位置限制实现

```cpp
// scene.cpp
void Scene::setCameraPosition(const glm::vec2 &camera_position)
{
    camera_position_ = camera_position;
    camera_position_ = glm::clamp(camera_position_, glm::vec2(-30), world_size_ - game_.getScreenSize() + glm::vec2(30));
}
```

这个方法确保相机不会显示世界边界外的区域，添加了30像素的边距以避免边缘处看起来过于生硬。

## SceneMain类的更新

最后，我们更新SceneMain类以支持玩家角色：

```cpp
// scene_main.h
class SceneMain: public Scene
{
    Player* player_ = nullptr; // 玩家
public:
    // ...
};
```

### 初始化场景和玩家

```cpp
void SceneMain::init()
{
    world_size_ = game_.getScreenSize() * 3.0f;
    camera_position_ = world_size_ / 2.0f - game_.getScreenSize() / 2.0f;
    player_ = new Player();
    player_->init();
    player_->setPosition(world_size_ / 2.0f);
}
```

### 更新和渲染

```cpp
void SceneMain::update(float dt)
{
    player_->update(dt);
}

void SceneMain::render()
{
    renderBackground();
    player_->render();
}

void SceneMain::clean()
{
    player_->clean();
    delete player_;
}
```

## 关键实现讲解

### 1. 对象坐标系统

我们的框架中有两种坐标系：

1. **世界坐标系**(`position_`)：表示对象在游戏世界中的实际位置
2. **屏幕坐标系**(`render_position_`)：表示对象在屏幕上的渲染位置

坐标转换的数学关系：
- 屏幕坐标 = 世界坐标 - 相机位置
- 世界坐标 = 屏幕坐标 + 相机位置

### 2. 玩家移动机制

玩家移动使用的是物理模型：

1. **速度控制**：键盘输入设置速度向量
2. **运动更新**：位置 += 速度 × 帧时间
3. **衰减**：速度每帧衰减10%，模拟摩擦
4. **边界碰撞**：使用`glm::clamp`限制玩家在世界范围内

### 3. 相机跟随

相机跟随的实现分为两部分：

1. **位置计算**：在`Player::syncCamera`中计算理想的相机位置
2. **边界检查**：在`Scene::setCameraPosition`中限制相机不会超出世界范围

## 优化与扩展

虽然我们已经实现了基本功能，但还有很多可以改进的地方：

### 1. 添加纹理渲染

```cpp
// 在Player类中添加
SDL_Texture* texture_ = nullptr;

void Player::init()
{
    max_speed_ = 500.0f;
    texture_ = TextureManager::LoadTexture("assets/player.png");
}

void Player::render()
{
    if (texture_) {
        SDL_Rect src = {0, 0, 32, 32};
        SDL_FRect dest = {render_position_.x, render_position_.y, 32, 32};
        SDL_RenderTexture(game_.getRenderer(), texture_, &src, &dest);
    } else {
        game_.drawBoundary(render_position_, render_position_ + glm::vec2(20.0f), 5.0f, {1.0, 0.0, 0.0, 1.0});
    }
}
```

### 2. 添加平滑相机跟随

```cpp
void Player::syncCamera()
{
    glm::vec2 targetPos = position_ - game_.getScreenSize() / 2.0f;
    glm::vec2 currentPos = game_.getCurrentScene()->getCameraPosition();
    float smoothFactor = 0.1f; // 较小的值移动更平滑
    glm::vec2 newPos = currentPos + (targetPos - currentPos) * smoothFactor;
    game_.getCurrentScene()->setCameraPosition(newPos);
}
```

### 3. 添加动画系统

```cpp
// 在Player类中添加
int current_frame_ = 0;
int frame_count_ = 4;
float frame_time_ = 0.1f;
float animation_timer_ = 0.0f;

void Player::update(float dt)
{
    // ... 现有代码 ...
    
    // 更新动画
    animation_timer_ += dt;
    if (animation_timer_ >= frame_time_) {
        animation_timer_ = 0;
        current_frame_ = (current_frame_ + 1) % frame_count_;
    }
}

void Player::render()
{
    if (texture_) {
        SDL_Rect src = {current_frame_ * 32, 0, 32, 32};
        SDL_FRect dest = {render_position_.x, render_position_.y, 32, 32};
        SDL_RenderTexture(game_.getRenderer(), texture_, &src, &dest);
    }
}
```

### 4. 添加冲刺能力

```cpp
// 在Player类中添加
bool is_dashing_ = false;
float dash_timer_ = 0.0f;
float dash_duration_ = 0.2f;

void Player::keyboardControl()
{
    // ... 现有代码 ...
    
    if (currentKeyStates[SDL_SCANCODE_SPACE] && !is_dashing_) {
        is_dashing_ = true;
        dash_timer_ = 0.0f;
        velocity_ *= 3.0f; // 冲刺时速度乘以3
    }
}

void Player::update(float dt)
{
    // ... 现有代码 ...
    
    // 处理冲刺
    if (is_dashing_) {
        dash_timer_ += dt;
        if (dash_timer_ >= dash_duration_) {
            is_dashing_ = false;
        }
    }
}
```

## 总结

在本课中，我们实现了：

1. **完整的对象层次结构**：从基础的Object到具体的Player，为不同类型的游戏对象提供了合适的基类
2. **玩家角色控制**：基于键盘输入和物理模型实现了玩家移动
3. **世界和屏幕坐标转换**：在Scene类中实现了坐标系统转换方法
4. **相机跟随功能**：使玩家始终保持在屏幕中心，并考虑了世界边界限制

这些功能构成了游戏引擎的核心部分，为后续添加更多游戏元素奠定了基础。通过良好的类层次设计，我们可以轻松扩展更复杂的游戏对象和行为。

## 练习

1. **实现平滑相机跟随**：修改`Player::syncCamera`方法，使用线性插值实现平滑的相机跟随效果。

2. **添加冲刺功能**：实现一个冲刺机制，按下空格键时，玩家短时间内移动速度加快，并添加冷却时间。

3. **实现相机死区**：修改相机跟随算法，添加一个"死区"，只有当玩家移出这个区域时，相机才会跟随移动。