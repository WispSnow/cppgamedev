# 储存与读取二进制存档

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/Ph9V8chTDIw?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV17noEYhE4P&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前面的课程中，我们实现了计时器组件和死亡结束画面，使游戏体验更加完整。然而，当玩家退出游戏后，所有游戏进度和成就都会丢失，无法保存玩家的游戏记录。本课将介绍如何实现游戏存档功能，通过二进制文件保存和读取游戏数据。

<img src="https://theorhythm.top/gamedev/GE/32-储存与读取二进制存档.PNG" style='width: 800px;' />

## 一、游戏存档的意义

游戏存档是几乎所有现代游戏的标准功能，它具有以下重要意义：

1. **保存游戏进度**：玩家可以在任意时刻保存游戏状态，稍后继续游戏
2. **记录游戏成就**：保存玩家的高分、解锁的内容和其他成就
3. **提高游戏粘性**：玩家的游戏数据被保存，增加了再次打开游戏的动力
4. **支持多存档**：允许多个玩家使用同一设备，或一个玩家尝试不同游戏路线

根据游戏类型和需求，存档内容可能包括玩家的位置、生命值、装备、已完成的关卡、游戏设置、高分记录等。

## 二、存档系统设计

为了实现存档功能，我们需要考虑以下几个方面：

1. **存档格式**：文本格式或二进制格式
2. **存档位置**：存档文件的保存路径
3. **存档内容**：需要保存哪些数据
4. **存档时机**：何时触发存档操作

在本课中，我们将使用二进制格式保存存档，因为它具有以下优势：

- **体积小**：二进制数据通常比文本数据占用更少的空间
- **读写速度快**：二进制读写操作通常比文本更高效
- **直接映射**：可以直接将内存中的数据结构写入文件

## 三、在Scene类中添加存档接口

首先，我们在基础的`Scene`类中添加存档和读档的虚函数接口：

```cpp
// scene.h
#include <string>

class Scene: public Object
{
    // ... 已有代码 ...
public:
    // ... 已有方法 ...
    
    // 存档和读档接口
    virtual void saveData(const std::string& file_path) {}
    virtual void loadData(const std::string& file_path) {}
    
    // ... 已有方法 ...
};
```

这两个虚函数在`Scene`类中只有空实现，由具体的场景类根据需要重写。这种设计符合面向对象的多态原则，不同场景可以有不同的存档内容和格式。

## 四、实现高分存档功能

在我们的游戏中，最基本的需要保存的数据是玩家的最高分数。我们将在以下情况下保存高分：

1. 玩家死亡时
2. 玩家重新开始游戏时
3. 玩家返回标题界面时

### 1. 在主游戏场景中实现存档功能

首先，我们需要在`SceneMain`类中重写`saveData`方法：

```cpp
// scene_main.h
class SceneMain: public Scene
{
    // ... 已有代码 ...
public:
    // ... 已有方法 ...
    virtual void saveData(const std::string& file_path) override;
    // ... 已有方法 ...
};
```

```cpp
// scene_main.cpp
#include <fstream>

void SceneMain::saveData(const std::string &file_path)
{
    auto score = game_.getHighScore();  // 获取最高分
    std::ofstream file(file_path, std::ios::binary);  // 以二进制模式打开文件
    if (file.is_open()) {
        // 将score变量的内存表示直接写入文件
        file.write(reinterpret_cast<const char*>(&score), sizeof(score));
        file.close();  // 关闭文件
    }
}
```

在`saveData`方法中，我们使用C++的`std::ofstream`类以二进制模式打开文件，然后使用`write`方法将分数数据直接写入文件。`reinterpret_cast`用于将整型数据的内存地址转换为`char*`类型，这是二进制写入所需要的。

### 2. 在适当时机触发存档

接下来，我们需要在适当的时机调用`saveData`方法：

```cpp
// scene_main.cpp
void SceneMain::update(float dt)
{
    // ... 已有代码 ...
    
    // 玩家死亡时保存数据
    if (player_ && !player_->getActive()) 
    {
        end_timer_->start();
        saveData("assets/score.dat");  // 保存分数
    }
    
    // ... 已有代码 ...
}

void SceneMain::checkButtonRestart()
{
    if (!button_restart_->getIsTrigger()) return;
    saveData("assets/score.dat");  // 重新开始游戏时保存分数
    game_.setScore(0);
    auto scene = new SceneMain();
    game_.safeChangeScene(scene);
}

void SceneMain::checkButtonBack()
{
    if (!button_back_->getIsTrigger()) return;
    saveData("assets/score.dat");  // 返回标题界面时保存分数
    game_.setScore(0);
    auto scene = new SceneTitle();
    game_.safeChangeScene(scene);
}
```

我们在三个关键时刻保存游戏数据：
1. 玩家死亡时
2. 玩家点击"重新开始"按钮时
3. 玩家点击"返回"按钮时

这确保了玩家的最高分数在任何情况下都能被正确保存。

## 五、实现存档读取功能

存档的另一半是读取存档。我们需要在游戏启动时或进入标题界面时读取之前保存的高分数据。

### 1. 在标题场景中实现读档功能

首先，我们在`SceneTitle`类中重写`loadData`方法：

```cpp
// scene_title.h
class SceneTitle : public Scene
{
    // ... 已有代码 ...
public:
    // ... 已有方法 ...
    virtual void loadData(const std::string& file_path) override;
    // ... 已有方法 ...
};
```

```cpp
// scene_title.cpp
#include <fstream>

void SceneTitle::loadData(const std::string &file_path)
{
    int score = 0;  // 初始分数为0
    std::ifstream file(file_path, std::ios::binary);  // 以二进制模式打开文件
    if (file.is_open()) {
        // 从文件中读取数据到score变量
        file.read(reinterpret_cast<char*>(&score), sizeof(score));
        file.close();  // 关闭文件
    }
    game_.setHighScore(score);  // 设置最高分
}
```

在`loadData`方法中，我们使用C++的`std::ifstream`类以二进制模式打开文件，然后使用`read`方法将文件中的数据读入`score`变量。同样，我们使用`reinterpret_cast`进行类型转换。

### 2. 在游戏启动时读取存档

接下来，我们需要在标题场景初始化时读取存档：

```cpp
// scene_title.cpp
void SceneTitle::init()
{
    Scene::init();
    loadData("assets/score.dat");  // 读取存档数据
    SDL_ShowCursor();
    // ... 已有代码 ...
}
```

这样，当游戏启动并进入标题界面时，会自动读取之前保存的高分数据并显示在界面上。

## 六、理解二进制存档的原理

在我们的实现中，我们使用了C++的二进制I/O功能来保存和读取游戏数据。这里简要介绍其工作原理：

### 1. 二进制模式与文本模式

C++文件操作有两种模式：文本模式和二进制模式。

- **文本模式**：文件内容被解释为文本，可能进行换行符转换等处理
- **二进制模式**：文件内容被视为原始字节序列，不做任何转换

通过在文件打开时指定`std::ios::binary`标志，我们选择了二进制模式。

### 2. 内存布局与字节序列

当我们使用`write`方法时，实际上是将变量在内存中的字节序列直接写入文件。例如，对于`int`类型的变量：

```cpp
int score = 1000;
file.write(reinterpret_cast<const char*>(&score), sizeof(score));
```

这行代码将`score`变量的4个字节（假设`int`是4字节）直接写入文件，而不关心这些字节代表什么内容。同样，`read`方法会将文件中的字节序列直接读入变量的内存区域。

### 3. 二进制存档的优缺点

**优点**：
- 文件体积小：直接存储内存表示，没有额外的格式化字符
- 读写速度快：无需解析文本格式
- 可存储复杂数据：可直接写入结构体、类等复杂数据（需注意对齐和填充）

**缺点**：
- 不可跨平台：不同系统的字节序可能不同（大端vs小端）
- 不可直接编辑：二进制文件不便于人工查看和修改
- 版本兼容性：数据结构变化后可能无法读取旧版存档

### 4. 处理复杂数据结构

在本例中，我们只保存了一个整数值。对于更复杂的数据结构，有几种常见的处理方式：

- **顺序写入成员**：将结构体的每个成员依次写入文件
- **整体写入**：将整个结构体一次性写入（需注意内存对齐问题）
- **序列化**：将数据转换为特定格式，如JSON、XML等，然后写入文件

## 七、扩展存档系统

我们当前的存档系统非常基础，只保存了最高分数。在实际游戏中，存档系统通常需要处理更多数据和更复杂的情况。

### 1. 保存更多游戏数据

可以扩展存档内容，包括：

```cpp
// 示例：扩展的存档结构
struct GameSave {
    int high_score;            // 最高分
    int unlocked_levels;       // 已解锁关卡
    float player_hp;           // 玩家生命值
    float player_position_x;   // 玩家X坐标
    float player_position_y;   // 玩家Y坐标
    bool has_weapon;           // 是否拥有武器
    // ... 其他数据 ...
};

// 保存数据
void saveData(const std::string &file_path) {
    GameSave save;
    save.high_score = game_.getHighScore();
    save.unlocked_levels = game_.getUnlockedLevels();
    // ... 设置其他字段 ...
    
    std::ofstream file(file_path, std::ios::binary);
    if (file.is_open()) {
        file.write(reinterpret_cast<const char*>(&save), sizeof(save));
        file.close();
    }
}
```

### 2. 多存档系统

允许玩家创建多个存档：

```cpp
// 示例：多存档系统
void saveToSlot(int slot) {
    std::string file_path = "assets/save_" + std::to_string(slot) + ".dat";
    saveData(file_path);
}

void loadFromSlot(int slot) {
    std::string file_path = "assets/save_" + std::to_string(slot) + ".dat";
    loadData(file_path);
}
```

### 3. 存档加密

为防止玩家篡改存档，可以添加简单的加密：

```cpp
// 示例：简单的异或加密
void saveEncrypted(const std::string &file_path, const char* key) {
    int score = game_.getHighScore();
    
    // 加密分数
    char* bytes = reinterpret_cast<char*>(&score);
    for (size_t i = 0; i < sizeof(score); i++) {
        bytes[i] ^= key[i % strlen(key)];  // 异或加密
    }
    
    std::ofstream file(file_path, std::ios::binary);
    if (file.is_open()) {
        file.write(bytes, sizeof(score));
        file.close();
    }
}
```

### 4. 版本兼容性处理

为处理游戏更新后的存档兼容性：

```cpp
// 示例：添加版本号
struct GameSaveHeader {
    int version;       // 存档版本号
    size_t data_size;  // 数据大小
};

void saveWithVersion(const std::string &file_path) {
    GameSaveHeader header{1, sizeof(int)};  // 版本1，数据大小为int
    int score = game_.getHighScore();
    
    std::ofstream file(file_path, std::ios::binary);
    if (file.is_open()) {
        file.write(reinterpret_cast<const char*>(&header), sizeof(header));
        file.write(reinterpret_cast<const char*>(&score), sizeof(score));
        file.close();
    }
}

void loadWithVersion(const std::string &file_path) {
    GameSaveHeader header;
    std::ifstream file(file_path, std::ios::binary);
    
    if (file.is_open()) {
        file.read(reinterpret_cast<char*>(&header), sizeof(header));
        
        // 根据版本号处理数据
        if (header.version == 1) {
            int score;
            file.read(reinterpret_cast<char*>(&score), sizeof(score));
            game_.setHighScore(score);
        } else if (header.version == 2) {
            // 处理版本2格式的存档
        }
        
        file.close();
    }
}
```

## 总结

在本课中，我们学习了如何实现基本的二进制存档系统：

1. **存档系统设计**：在基础类中添加存档接口，由具体场景类实现
2. **保存游戏数据**：使用C++的二进制I/O将游戏数据写入文件
3. **读取存档数据**：在游戏启动时读取之前保存的数据
4. **触发存档时机**：在适当时机（如玩家死亡、重启游戏或退出游戏）触发存档操作
5. **理解二进制存档**：了解二进制存档的工作原理、优缺点及注意事项
6. **扩展存档系统**：探讨了如何扩展存档系统，包括保存更多数据、多存档支持、加密与版本兼容性

通过添加存档功能，我们的游戏更加完整，玩家的游戏成就可以被保存和记录，增强了游戏的长期吸引力。

## 练习

1. 扩展存档系统，保存玩家的生命值、位置等信息，实现游戏进度的保存和恢复
2. 实现多存档功能，允许玩家创建多个存档并在它们之间切换
3. 为存档添加简单的加密功能，防止玩家直接修改存档文件
4. 实现存档预览功能，显示每个存档的基本信息（如保存时间、玩家等级等）
5. 设计一个自动存档系统，定期自动保存游戏进度