# 法术类

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/Sqz6BcHO9Vk?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1fco9YcE6p&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏中，法术系统是增强游戏交互性和策略性的重要元素。无论是魔法攻击、治疗能力还是特殊效果，法术都能丰富游戏的战斗体验，为玩家提供多样的战略选择。在本课中，我们将设计和实现一个基础的法术系统，允许玩家通过鼠标点击释放强大的法术攻击敌人。

<img src="https://theorhythm.top/gamedev/GE/19-法术类.PNG" style='width: 800px;' />

## 法术系统的意义

法术系统在游戏中具有以下几个关键作用：

1. **战斗多样性**：提供多种攻击方式，超越基础的近战或远程攻击
2. **策略深度**：不同法术有不同的效果、消耗和冷却时间，玩家需要战略性地决定何时使用哪种法术
3. **视觉效果**：法术通常伴随华丽的视觉效果，增强游戏的视觉体验
4. **游戏平衡**：通过调整法术的伤害、范围和冷却时间，可以实现游戏的平衡性
5. **角色成长**：随着游戏进程，玩家可以获得新的法术或增强现有法术，形成角色成长系统

基于这些需求，我们将设计一个基础的`Spell`类作为法术系统的核心。

## 一、对象类型的扩展

为了更好地支持法术系统，我们首先需要扩展游戏中的对象类型。在`defs.h`文件中，我们添加了一个专门的敌人类型：

```cpp
// defs.h
enum class ObjectType
{
    NONE,
    OBJECT_SCREEN,
    OBJECT_WORLD,
    ENEMY,  // 新增的敌人类型
};
```

这样可以在游戏引擎级别区分敌人和其他游戏对象，为法术的目标筛选提供便利。然后，我们在Enemy类的初始化方法中设置其类型：

```cpp
// enemy.cpp
void Enemy::init()
{
    Actor::init();
    // ... 其他初始化代码
    setType(ObjectType::ENEMY);  // 设置对象类型为敌人
}
```

## 二、伤害机制的优化

为了支持法术对敌人造成伤害，我们需要优化现有的伤害机制。首先，我们将`Actor`类中的`takeDamage`方法声明为虚函数，允许子类自定义处理伤害的方式：

```cpp
// actor.h
class Actor : public ObjectWorld
{
    // ... 其他成员

public:
    virtual void takeDamage(float damage);  // 声明为虚函数
    // ... 其他方法
};
```

同时，我们在`ObjectWorld`基类中也添加了一个虚函数`takeDamage`，这样所有继承自`ObjectWorld`的类都可以响应伤害：

```cpp
// object_world.h
class ObjectWorld : public Object
{
    // ... 其他成员

public:
    // ... 其他方法
    virtual void takeDamage(float damage) {return; }  // 默认实现为空
};
```

这种设计使得我们可以对任何`ObjectWorld`对象调用`takeDamage`方法，但只有实际实现了该方法的类（如`Actor`及其子类）才会真正处理伤害。

## 三、设计法术类

接下来，我们设计一个新的`Spell`类来表示游戏中的法术：

```cpp
// spell.h
#ifndef SPELL_H
#define SPELL_H

#include "../core/object_world.h"
#include "../affiliate/sprite_anim.h"

class Spell : public ObjectWorld
{
protected:
    SpriteAnim* sprite_ = nullptr;
    float damage_ = 60.0f;
public:
    static Spell* addSpellChild(Object* parent, const std::string& file_path, glm::vec2 pos, float damage, float scale = 1.0f, Anchor anchor = Anchor::CENTER);
    void update(float dt) override;


    // getters and setters
    float getDamage() const { return damage_; }
    void setDamage(float damage) { damage_ = damage; }
    SpriteAnim* getSpriteAnim() const { return sprite_; }
    void setSpriteAnim(SpriteAnim* sprite) { sprite_ = sprite; }

private:
    void attack();
};

#endif  // SPELL_H
```

`Spell`类继承自`ObjectWorld`，这意味着它可以放置在游戏世界中的任何位置。它具有以下主要属性：

- `sprite_`：法术的视觉表现，使用`SpriteAnim`实现动画效果
- `damage_`：法术造成的伤害值

此外，我们声明了几个重要方法：

- `addSpellChild`：静态工厂方法，用于创建和初始化法术实例
- `update`：更新法术状态，包括检查动画是否完成和处理伤害
- `attack`：处理法术的伤害逻辑

## 四、实现法术功能

接下来，我们来实现`Spell`类的具体功能：

```cpp
// spell.cpp
#include "spell.h"
#include "../core/scene.h"

Spell *Spell::addSpellChild(Object *parent, const std::string &file_path, glm::vec2 pos, float damage, float scale, Anchor anchor)
{
    auto spell = new Spell();
    spell->init();
    spell->damage_ = damage;
    spell->sprite_ = SpriteAnim::addSpriteAnimChild(spell, file_path, scale, anchor);
    auto size = spell->sprite_->getSize();
    spell->collider_ = Collider::addColliderChild(spell, size, Collider::Type::CIRCLE, anchor);
    spell->sprite_->setLoop(false);
    spell->setPosition(pos);
    if (parent) parent->addChild(spell);
    return spell;
}

void Spell::update(float dt)
{
    ObjectWorld::update(dt);
    if (sprite_->getFinish()) need_remove_ = true;
    attack();
}

void Spell::attack()
{
    auto objects = game_.getCurrentScene()->getChildrenWorld();
    for (auto& object : objects)
    {
        if (object->getType() != ObjectType::ENEMY) continue;
        if (collider_ && object->getCollider() && collider_->isColliding(object->getCollider()))
        {
            object->takeDamage(damage_);
        }
    }
}
```

让我们详细分析这些方法：

1. **addSpellChild**：创建并初始化一个法术实例。它设置法术的伤害值，创建精灵动画和碰撞器，并将法术放置在指定位置。注意我们将精灵动画设置为不循环（`setLoop(false)`），这意味着法术动画只会播放一次。

2. **update**：更新法术状态。它首先调用基类的`update`方法，然后检查精灵动画是否已经完成，如果完成则标记法术需要移除。最后，调用`attack`方法处理伤害逻辑。

3. **attack**：处理法术的伤害逻辑。它遍历当前场景中的所有世界对象，筛选出类型为`ENEMY`的对象，然后检查是否与法术的碰撞器相交。如果相交，则对敌人调用`takeDamage`方法造成伤害。

这种实现有几个优点：

- **自动清理**：法术动画播放完毕后会自动移除，无需手动管理
- **区域伤害**：法术可以同时对多个敌人造成伤害，实现区域攻击效果
- **视觉反馈**：法术有动画效果，为玩家提供直观的视觉反馈
- **参数化**：法术的伤害值、大小和位置都可以通过参数控制，便于调整和扩展

## 五、与碰撞检测系统的协作

为了正确地实现法术的伤害检测，我们需要访问`Collider`类的一些内部实现。为了实现这一点，我们在`Collider`类中添加了`Spell`类作为友元：

```cpp
// collider.h
class Spell;
class Collider : public ObjectAffiliate
{
protected:
    //  友元
    friend Spell;
    // ... 其他成员
};
```

这样，`Spell`类就可以直接访问`Collider`类的保护成员，便于实现碰撞检测和伤害处理。

## 六、集成到游戏场景中

最后，我们需要将法术系统集成到游戏场景中，使玩家能够通过鼠标点击释放法术：

```cpp
// scene_main.cpp
#include "world/spell.h"

void SceneMain::handleEvents(SDL_Event& event)
{
    Scene::handleEvents(event);
    if (event.type == SDL_EVENT_MOUSE_BUTTON_DOWN)
    {
        if (event.button.button == SDL_BUTTON_LEFT)
        {
            auto pos = game_.getMousePosition() + camera_position_;
            Spell::addSpellChild(this, "assets/effect/Thunderstrike w blur.png", pos, 120.0f, 3.0f, Anchor::CENTER);
        }
    }
}
```

在场景的事件处理方法中，我们检测鼠标左键点击事件，并在点击位置创建一个法术实例。注意这里我们将屏幕坐标转换为世界坐标，以便法术能够在正确的位置生成。

<img src="https://theorhythm.top/gamedev/GE/19-法术类截图.png" style='width: 800px;' />

## 七、敌人状态更新

为了使敌人能够正确响应法术伤害，我们需要修改敌人的状态检查和更新逻辑：

```cpp
// enemy.cpp
void Enemy::update(float dt){
    Actor::update(dt);
    if (target_ && target_->getActive()){
        aim_target(target_);
        move(dt);
        attack();
    }
    checkState();  // 添加状态检查
    remove();
}

void Enemy::checkState()
{
    State new_state;
    if (stats_->getHealth() <= 0) new_state = State::DIE;
    else if (stats_->getInvincible()) new_state = State::HURT;
    else new_state = State::NORMAL;

    if (new_state != current_state_) changeState(new_state);
}
```

在敌人的`update`方法中，我们添加了对`checkState`方法的调用，该方法根据敌人的健康状态和无敌状态决定敌人应该处于什么状态。如果状态需要改变，就调用`changeState`方法切换状态和相应的动画。

这样，当敌人受到法术伤害时，会根据健康值的变化调整其状态和动画，提供直观的视觉反馈。

## 总结

在本课中，我们实现了一个基础的法术系统：

1. 扩展了游戏对象类型，添加了专门的敌人类型
2. 优化了伤害机制，支持对不同类型对象的伤害处理
3. 设计并实现了`Spell`类，处理法术的视觉效果和伤害逻辑
4. 实现了法术的碰撞检测和区域伤害功能
5. 将法术系统集成到游戏场景中，支持鼠标点击释放法术
6. 优化了敌人状态更新机制，使其能够正确响应法术伤害

法术系统大大增强了游戏的交互性和策略深度，为玩家提供了更多的战斗选择。通过点击鼠标释放强大的法术攻击敌人，玩家可以体验到更加丰富和有趣的游戏玩法。

## 练习

1. **法术变种**：实现不同类型的法术，如火球、冰锥、治疗等
2. **法术效果**：为法术添加特殊效果，如减速、灼烧、冻结等
3. **法术升级**：设计一个法术升级系统，随着游戏进程增强法术的效果