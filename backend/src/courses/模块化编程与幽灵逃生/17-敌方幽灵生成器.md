# 敌方幽灵生成器

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/d1OjDDfEVN4?si=2EcHHYM5GRGXjVJ4" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
  
  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV11doiY8EmA&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在游戏开发中，敌人的生成是创造游戏挑战性的重要一环。静态放置的敌人很快就会被玩家熟悉和预测，而动态生成的敌人能够为游戏带来持续的新鲜感和不可预测性。在本课中，我们将设计和实现一个敌方幽灵生成器，用于在游戏运行过程中自动生成敌人。

<img src="https://theorhythm.top/gamedev/GE/17-敌方幽灵生成器1.PNG" style='width: 800px;' />

## 游戏中生成器的意义

在游戏设计中，生成器（Spawner）是一种常见且重要的机制，它具有以下几个关键作用：

1. **持续的挑战**：通过不断生成敌人，为玩家提供持续的挑战
2. **动态难度调整**：可以根据游戏进程或玩家表现调整敌人生成的速度和数量
3. **资源管理**：控制场景中敌人的数量，避免资源过度消耗
4. **游戏节奏控制**：通过调整生成间隔和数量，控制游戏的紧张和放松节奏
5. **随机性**：增加游戏的不可预测性，提高可玩性和重玩价值

基于这些需求，我们将设计一个敌方幽灵生成器（Spawner）类。

## 一、随机数功能的实现

在开始实现生成器之前，我们需要先为游戏引擎添加随机数生成的功能。随机数对于游戏中的许多方面都至关重要，如敌人生成位置、行为决策、掉落物品等。

### 在Game类中添加随机数功能

```cpp
// game.h
#include <random>

class Game
{
    // ... 其他成员

    std::mt19937 gen_ = std::mt19937(std::random_device{}());

public:
    // ... 其他方法

    // 随机数函数
    float randomFloat(float min, float max) { return std::uniform_real_distribution<float>(min, max)(gen_); }
    int randomInt(int min, int max) { return std::uniform_int_distribution<int>(min, max)(gen_); }
    glm::vec2 randomVec2(const glm::vec2& min, const glm::vec2& max) { return glm::vec2(randomFloat(min.x, max.x), randomFloat(min.y, max.y)); }
    glm::ivec2 randomIVec2(const glm::ivec2& min, const glm::ivec2& max) { return glm::ivec2(randomInt(min.x, max.x), randomInt(min.y, max.y)); }
};
```

这里我们使用C++11的随机数库，而不是传统的rand()函数，原因在于：

1. **更好的随机性**：std::mt19937是梅森旋转算法（Mersenne Twister）的实现，提供更好的随机性
2. **可控性**：可以指定分布类型（如均匀分布、正态分布等）
3. **类型安全**：提供类型安全的接口，避免类型转换错误
4. **可重现性**：可以通过设置种子实现可重现的随机序列，有利于调试

我们实现了四种随机数生成方法：
- `randomFloat`：生成指定范围内的浮点数
- `randomInt`：生成指定范围内的整数
- `randomVec2`：生成指定范围内的二维向量（浮点数）
- `randomIVec2`：生成指定范围内的二维向量（整数）

这些方法都是基于均匀分布（uniform distribution）的，即每个可能的值被选中的概率相等。

## 二、设计敌方生成器类

有了随机数功能，接下来我们可以设计敌方生成器类。生成器需要控制敌人的生成频率、数量以及位置。

```cpp
// spawner.h
#ifndef SPAWNER_H
#define SPAWNER_H

#include "core/object.h"
class Player;
class Spawner : public Object {
protected:
    int num_ = 20;            // 每次生成的敌人数量
    float timer_ = 0;         // 计时器
    float interval_ = 3.0f;   // 生成间隔（秒）
    Player* target_ = nullptr; // 目标玩家

public:
    virtual void update(float dt) override;

    // setters and getters
    int getNum() const { return num_; }
    void setNum(int num) { num_ = num; }
    float getTimer() const { return timer_; }
    void setTimer(float timer) { timer_ = timer; }
    float getInterval() const { return interval_; }
    void setInterval(float interval) { interval_ = interval; }
    Player* getTarget() const { return target_; }
    void setTarget(Player* target) { target_ = target; }
};

#endif // SPAWNER_H
```

`Spawner`类继承自`Object`，这意味着它可以被添加到游戏场景中，并参与游戏循环。它具有以下主要属性：

- `num_`：每次生成的敌人数量
- `timer_`：跟踪自上次生成以来经过的时间
- `interval_`：两次生成之间的时间间隔
- `target_`：所有生成的敌人将追踪的目标（通常是玩家）

此外，我们提供了一些getter和setter方法，使得其他模块可以调整生成器的参数。

## 三、实现敌方生成功能

接下来，我们来实现生成器的核心功能，即在游戏中动态生成敌人：

```cpp
// spawner.cpp
#include "spawner.h"
#include "enemy.h"
#include "world/effect.h"
#include "core/scene.h"

void Spawner::update(float dt)
{
    if (!target_ || !target_->getActive()) return;
    timer_ += dt;
    if (timer_ >= interval_)
    {
        timer_ = 0;
        for (int i = 0; i < num_; i++)
        {
            // spawn enemy
            auto pos = game_.randomVec2(game_.getCurrentScene()->getCameraPosition(), game_.getCurrentScene()->getCameraPosition() + game_.getScreenSize());
            Enemy* enemy = Enemy::addEnemyChild(nullptr, pos, target_);
            Effect::addEffectChild(game_.getCurrentScene(), "assets/effect/184_3.png", pos, 1.0f, enemy);
        }
    }
}
```

在`update`方法中，我们首先检查目标玩家是否存在且处于活跃状态。如果不是，我们就不生成新的敌人，这避免了在游戏结束或暂停时继续生成敌人。

接着，我们更新计时器，并检查是否达到了生成间隔。如果是，我们就重置计时器，并开始生成敌人：

1. 使用随机数生成器，在当前摄像机视图范围内选择一个随机位置
2. 使用`Enemy::addEnemyChild`方法创建一个新的敌人，但暂时不将其添加到场景中
3. 创建一个特效，并将敌人设置为特效完成后添加的对象

这种实现方式有几个优点：
- 敌人在玩家可见范围内生成，保证玩家能够察觉并应对
- 使用特效作为敌人出现的前兆，提供视觉反馈和预警
- 批量生成敌人，增加游戏难度
- 生成过程可以通过调整参数灵活控制

## 四、简化敌人创建过程

为了简化敌人的创建过程，我们在`Enemy`类中添加了一个静态工厂方法：

```cpp
// enemy.h
class Enemy : public Actor
{
    // ... 其他成员

public:
    static Enemy* addEnemyChild(Object* parent, glm::vec2 pos, Player* target);
    // ... 其他方法
};
```

```cpp
// enemy.cpp
Enemy *Enemy::addEnemyChild(Object *parent, glm::vec2 pos, Player *target)
{
    auto enemy = new Enemy();
    enemy->init();
    enemy->setPosition(pos);
    enemy->setTarget(target);
    if (parent) parent->addChild(enemy);
    return enemy;
}
```

这个工厂方法封装了敌人的创建和初始化过程，使得在生成器中创建敌人变得更加简洁。它执行以下操作：

1. 创建一个新的敌人对象
2. 初始化敌人
3. 设置敌人的位置
4. 设置敌人的目标
5. 如果指定了父对象，将敌人添加为其子对象
6. 返回创建的敌人对象

注意这里方法名由原来的`set_target`改为了`setTarget`，这是为了保持命名一致性，按照setter方法的命名规范，提高代码的可读性和一致性。

## 五、集成生成器到场景中

最后，我们需要在主场景中初始化和使用这个生成器。我们修改`SceneMain`类，添加一个`Spawner`成员，并在场景初始化时设置它：

```cpp
// scene_main.h
#include "core/scene.h"

class Spawner;
class Player;
class SceneMain: public Scene
{
    Player* player_ = nullptr; // 玩家
    Spawner* spawner_ = nullptr; // 敌人生成器
public:
    // ... 其他方法
};
```

```cpp
// scene_main.cpp
#include "scene_main.h"
#include "player.h"
#include "enemy.h"
#include "world/effect.h"
#include "spawner.h"

void SceneMain::init()
{
    Scene::init();
    world_size_ = glm::vec2(1600.0f, 1200.0f);
    
    player_ = new Player();
    player_->init();
    player_->setPosition(world_size_ / 2.0f);
    addChild(player_);

    spawner_ = new Spawner();
    spawner_->init();
    spawner_->setTarget(player_);
    addChild(spawner_);

    // 注释掉之前手动创建敌人的代码
    // auto enemy = new Enemy();
    // enemy->init();
    // enemy->setTarget(player_);
    // enemy->setPosition(world_size_ / 2.0f + glm::vec2(200.0f));
    // Effect::addEffectChild(this, "assets/effect/184_3.png", world_size_ / 2.0f + glm::vec2(200.0f), 1.0f, enemy);
}
```

与之前直接创建一个敌人的方式相比，使用生成器可以持续地创建敌人，使游戏更具挑战性。同时，我们保留了注释的代码，作为参考和对比。

<img src="https://theorhythm.top/gamedev/GE/17-敌方幽灵生成器截图.png" style='width: 800px;' />

## 总结

在本课中，我们实现了一个敌方幽灵生成器系统：

1. 在游戏引擎中添加了随机数生成功能，为各种随机行为提供支持
2. 设计并实现了`Spawner`类，用于控制敌人的生成
3. 在`Enemy`类中添加了工厂方法，简化敌人的创建过程
4. 将生成器集成到游戏场景中，替代了静态敌人的创建方式
5. 结合特效系统，为敌人的出现增加了视觉反馈

敌方生成器大大增强了游戏的可玩性和挑战性，通过不断生成敌人，给玩家带来持续的挑战。结合前面课程中实现的战斗属性、碰撞检测和特效系统，我们的游戏已经具备了基本的战斗游戏元素。

## 练习

1. **波次生成**：修改生成器，实现波次生成模式，即每隔一段时间生成一波敌人，波次之间有间隔
2. **条件触发**：实现基于特定条件（如玩家接近某个区域）触发敌人生成
3. **多生成点**：设计多个生成点，敌人可以从不同位置生成
4. **Boss生成**：实现特殊的Boss敌人，在特定条件下生成
5. **生成特效变化**：根据敌人类型，使用不同的特效来表示敌人的生成