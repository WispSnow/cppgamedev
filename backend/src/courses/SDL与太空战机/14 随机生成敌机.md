# 随机生成敌机

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/LDbZzaGMrAg?si=Dj-Q8SHK3cApNmEG" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1ib66Y2EYD&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了玩家飞机的射击功能，允许玩家通过按键发射子弹。然而，目前子弹发射出去后只是飞出屏幕而已，没有任何目标可以击中。在这一课中，我们将为游戏添加敌机，让玩家有真正的对手。我们将利用C++的随机数生成功能，实现敌机的随机生成。

<img src="https://theorhythm.top/gamedev/SS/14 随机生成敌机.PNG" style='width: 800px;' />

## C++随机数生成原理与方法

在计算机科学中，真正的随机数很难生成，通常我们使用的是伪随机数。C++提供了多种生成伪随机数的方法，从C++11开始，标准库引入了更加先进和灵活的随机数生成工具。

### 1. 传统的rand()函数

在C++11之前，随机数主要通过`<cstdlib>`库中的`rand()`函数生成：

```cpp
#include <cstdlib>
#include <ctime>

int main() {
    // 设置随机种子
    srand(time(nullptr));
    
    // 生成0到RAND_MAX之间的随机数
    int randomNum = rand();
    
    // 生成0到99之间的随机数
    int randomRange = rand() % 100;
    
    return 0;
}
```

这种方法存在一些问题：
- 随机性较差，容易出现周期性和分布不均匀
- 范围限制为0到RAND_MAX（通常是32767）
- 无法直接生成浮点随机数

### 2. 现代C++随机数库

C++11引入了`<random>`库，提供了更强大和灵活的随机数生成工具：

```cpp
#include <random>
#include <iostream>

int main() {
    // 随机数种子生成器
    std::random_device rd;
    
    // 梅森旋转算法随机数生成器
    std::mt19937 gen(rd());
    
    // 生成[0, 99]范围内的均匀分布随机整数
    std::uniform_int_distribution<int> intDist(0, 99);
    int randomInt = intDist(gen);
    
    // 生成[0.0, 1.0)范围内的均匀分布随机浮点数
    std::uniform_real_distribution<float> floatDist(0.0f, 1.0f);
    float randomFloat = floatDist(gen);
    
    return 0;
}
```

现代C++随机数库包含三个主要组件：

1. **随机数引擎**：生成伪随机数的算法，如`std::mt19937`（梅森旋转算法）
2. **随机数种子**：用于初始化随机数引擎的值，如`std::random_device`
3. **分布器**：将随机数引擎生成的数字转换为特定范围和分布，如`std::uniform_int_distribution`

### 3. 常用随机数引擎

C++标准库提供了几种随机数引擎：

- `std::mt19937`：梅森旋转算法，产生高质量的32位随机数
- `std::mt19937_64`：64位版本的梅森旋转算法
- `std::default_random_engine`：依赖实现的默认随机数引擎

### 4. 常用分布器

分布器用于转换随机数引擎生成的原始值，使其符合特定的数学分布：

- `std::uniform_int_distribution`：均匀分布的整数
- `std::uniform_real_distribution`：均匀分布的浮点数
- `std::normal_distribution`：正态分布
- `std::bernoulli_distribution`：伯努利分布（布尔值）

### 5. 实际应用示例

以下是一个更完整的随机数生成示例：

```cpp
#include <random>
#include <iostream>

int main() {
    // 创建真随机数设备作为种子源
    std::random_device rd;
    
    // 使用种子初始化梅森旋转引擎
    std::mt19937 gen(rd());
    
    // 创建各种分布器
    std::uniform_int_distribution<int> intDist(1, 6);  // 模拟骰子
    std::uniform_real_distribution<float> floatDist(0.0f, 1.0f);  // 0到1之间的浮点数
    std::normal_distribution<double> normalDist(5.0, 2.0);  // 均值为5，标准差为2的正态分布
    
    // 生成并输出随机数
    std::cout << "骰子点数: " << intDist(gen) << std::endl;
    std::cout << "随机概率: " << floatDist(gen) << std::endl;
    std::cout << "正态分布随机数: " << normalDist(gen) << std::endl;
    
    return 0;
}
```

了解了C++中的随机数生成方法后，我们将应用这些知识来实现敌机的随机生成。

## 设计敌机系统

要实现敌机系统，我们需要解决以下几个问题：

1. **敌机的数据结构**：用于存储敌机的位置、速度、纹理等属性。
2. **敌机的随机生成**：在适当的时机在屏幕顶部随机位置生成敌机。
3. **敌机的移动**：使敌机从屏幕顶部向底部移动。
4. **敌机的管理**：处理超出屏幕底部的敌机，释放它们占用的资源。

接下来，我们将一步一步地实现这些功能。

## 1. 定义敌机数据结构

首先，我们在`Object.h`中定义一个新的结构体`Enemy`，表示敌机：

```cpp
// Object.h
struct Enemy{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 200;         // 敌机移动速度
};
```

这个结构与我们之前定义的`Player`和`ProjectilePlayer`类似，包含纹理、位置、尺寸和速度信息。敌机的速度设为200像素/秒，与玩家飞机的基础速度相同。

## 2. 更新SceneMain类

接下来，我们需要更新`SceneMain`类，添加随机数生成器和敌机相关的成员和方法：

```cpp
// SceneMain.h
#include <random>  // 添加随机数库

class SceneMain : public Scene {
public:
    // ...现有方法...

    void spawEnemy();                         // 生成敌机
    void updateEnemies(float deltaTime);      // 更新敌机
    void renderEnemies();                     // 渲染敌机

private:
    // ...现有成员...
    
    // 随机数相关成员
    std::mt19937 gen;                         // 随机数生成器
    std::uniform_real_distribution<float> dis; // 随机数分布器
    
    // 敌机相关成员
    Enemy enemyTemplate;                      // 敌机模板
    std::list<Enemy*> enemies;                // 存储活动敌机的列表
};
```

我们添加了以下新成员和方法：
- 随机数相关：
  - `gen`：基于梅森旋转算法的随机数生成器
  - `dis`：生成[0,1]范围内均匀分布的浮点数的分布器
- 敌机相关：
  - `enemyTemplate`：敌机模板，用于创建新敌机
  - `enemies`：存储当前屏幕上所有活动敌机的列表
  - `spawEnemy()`、`updateEnemies()`和`renderEnemies()`：负责敌机的生成、更新和渲染

## 3. 初始化随机数生成器和敌机模板

在`SceneMain::init()`方法中，我们需要初始化随机数生成器和敌机模板：

```cpp
void SceneMain::init()
{
    // 初始化随机数生成器
    std::random_device rd;  // 获取真随机数作为种子
    gen = std::mt19937(rd());  // 用种子初始化梅森旋转引擎
    dis = std::uniform_real_distribution<float>(0.0f, 1.0f);  // 设置[0,1]均匀分布
    
    // 初始化玩家飞机和子弹模板（与之前相同）
    // ...

    // 初始化敌机模板
    enemyTemplate.texture = IMG_LoadTexture(game.getRenderer(), "assets/image/insect-2.png");
    SDL_QueryTexture(enemyTemplate.texture, NULL, NULL, &enemyTemplate.width, &enemyTemplate.height);
    enemyTemplate.width /= 4;
    enemyTemplate.height /= 4;
}
```

这里我们使用`std::random_device`获取真随机数作为种子，初始化梅森旋转随机数引擎`std::mt19937`，并设置一个均匀分布在[0, 1]区间的浮点数分布器。这样我们就可以生成高质量的随机数，用于敌机的生成。

我们还加载了敌机的纹理并设置了初始尺寸，与之前的玩家飞机和子弹处理方式类似。

## 4. 清理敌机资源

在`SceneMain::clean()`方法中，我们需要添加清理敌机资源的代码：

```cpp
void SceneMain::clean()
{
    // 清理子弹（与之前相同）
    // ...

    // 清理敌机
    for (auto &enemy : enemies){
        if (enemy != nullptr){
            delete enemy;
        }
    }
    enemies.clear();

    // 清理纹理（玩家飞机和子弹模板的清理与之前相同）
    // ...
    
    if (enemyTemplate.texture != nullptr){
        SDL_DestroyTexture(enemyTemplate.texture);
    }
}
```

这段代码确保所有动态分配的敌机对象都被正确删除，并清理了敌机模板的纹理资源，防止内存泄漏。

## 5. 利用随机数实现敌机生成

`spawEnemy()`方法利用随机数控制敌机的生成时机和位置：

```cpp
void SceneMain::spawEnemy()
{
    // 利用随机数决定是否生成敌机（每帧约1/60的概率）
    if (dis(gen) > 1 / 60.0f){
        return;
    }
    
    // 创建新敌机
    Enemy* enemy = new Enemy(enemyTemplate);
    
    // 利用随机数决定敌机的水平位置
    enemy->position.x = dis(gen) * (game.getWindowWidth() - enemy->width);
    
    // 垂直位置设在屏幕上方（刚好不可见）
    enemy->position.y = - enemy->height;
    
    // 添加到活动敌机列表
    enemies.push_back(enemy);
}
```

这个方法有两处使用了随机数：

1. **控制生成频率**：我们使用`dis(gen) > 1 / 60.0f`这个条件来决定是否生成敌机。由于`dis(gen)`生成的是[0,1]范围内的随机数，这个条件等价于有约1/60的概率生成敌机。假设游戏以60FPS运行，这将导致平均每秒生成一个敌机。

2. **决定水平位置**：我们使用`dis(gen) * (game.getWindowWidth() - enemy->width)`来随机确定敌机的水平位置。这确保敌机完全在屏幕宽度范围内，不会部分超出屏幕。

通过这种方法，敌机会以一定的随机性从屏幕顶部出现，使游戏更有挑战性和不可预测性。

## 6. 更新敌机位置

在每一帧，我们需要更新所有敌机的位置，并移除已经飞出屏幕底部的敌机：

```cpp
void SceneMain::updateEnemies(float deltaTime)
{
    for (auto it = enemies.begin(); it != enemies.end();){
        auto enemy = *it;
        
        // 更新敌机位置
        enemy->position.y += enemy->speed * deltaTime;
        
        // 检查敌机是否飞出屏幕底部
        if (enemy->position.y > game.getWindowHeight()){
            delete enemy;
            it = enemies.erase(it);
        }else {
            ++it;
        }
    }
}
```

这段代码遍历所有敌机，根据敌机速度和`deltaTime`更新敌机位置，使其向下移动。如果敌机完全飞出屏幕底部，我们会将其删除并从列表中移除。

与子弹的更新类似，我们使用迭代器确保安全地删除元素。

## 7. 渲染敌机

最后，我们需要渲染所有活动的敌机：

```cpp
void SceneMain::renderEnemies()
{
    for (auto enemy : enemies){
        SDL_Rect enemyRect = {
            static_cast<int>(enemy->position.x),
            static_cast<int>(enemy->position.y),
            enemy->width,
            enemy->height
        };
        SDL_RenderCopy(game.getRenderer(), enemy->texture, NULL, &enemyRect);
    }
}
```

这段代码遍历所有敌机，创建对应的矩形，并使用`SDL_RenderCopy`将敌机纹理渲染到屏幕上。

## 8. 更新主循环

最后，我们需要在`update()`和`render()`方法中调用敌机相关的方法：

```cpp
void SceneMain::update(float deltaTime)
{
    keyboardControl(deltaTime);
    updatePlayerProjectiles(deltaTime);
    spawEnemy();                 // 生成敌机
    updateEnemies(deltaTime);    // 更新敌机
}

void SceneMain::render()
{
    // 渲染玩家子弹
    renderPlayerProjectiles();
    
    // 渲染玩家
    SDL_Rect playerRect = { static_cast<int>(player.position.x), 
                          static_cast<int>(player.position.y), 
                          player.width, 
                          player.height };
    SDL_RenderCopy(game.getRenderer(), player.texture, NULL, &playerRect);
    
    // 渲染敌机
    renderEnemies();
}
```

注意渲染顺序：我们先渲染子弹和玩家，再渲染敌机，这样敌机会显示在玩家和子弹的上方，符合游戏的视觉逻辑（敌机从上方飞来）。

## 游戏效果

实现了上述代码后，游戏中会随机生成敌机，从屏幕顶部向下飞行。玩家可以通过WASD移动飞机，按J键发射子弹，但目前还无法击中敌机，因为我们还没有实现碰撞检测。

<img src="https://theorhythm.top/gamedev/SS/14 随机生成敌机截图.png" style='width: 800px;' />

## 随机数生成的扩展应用

我们可以利用随机数生成进一步增强游戏体验：

1. **随机敌机速度**：可以为每个敌机生成随机速度
   ```cpp
   std::uniform_real_distribution<float> speedDist(150.0f, 300.0f);
   enemy->speed = speedDist(gen);
   ```

2. **随机敌机大小**：为敌机设置随机大小
   ```cpp
   std::uniform_real_distribution<float> scaleDist(0.8f, 1.2f);
   float scale = scaleDist(gen);
   enemy->width *= scale;
   enemy->height *= scale;
   ```

3. **随机敌机类型**：随机选择不同的敌机类型
   ```cpp
   std::uniform_int_distribution<int> typeDist(0, 2);
   int enemyType = typeDist(gen);
   // 根据enemyType选择不同的敌机纹理和属性
   ```

## 总结

在本课中，我们首先学习了C++中随机数生成的原理和方法，然后将这些知识应用到游戏开发中，实现了敌机的随机生成和移动功能。我们学习了：

1. C++中传统和现代的随机数生成方法。
2. 如何使用随机数引擎和分布器生成高质量的随机数。
3. 如何利用随机数控制敌机的生成时机和位置。
4. 如何管理多个移动的游戏对象（敌机）。

这些都是射击游戏中的基本元素，使游戏更具挑战性和趣味性。在下一课中，我们将实现碰撞检测，让子弹能够击中敌机，并处理玩家与敌机的碰撞。

## 练习

1. 修改代码，使敌机能够以不同的速度移动（使用随机数生成器为每个敌机分配一个在某个范围内的速度值）。

2. 实现敌机的左右摇摆运动，可以使用正弦函数和随机初始相位来实现。

3. 使用随机数添加不同类型的敌机，每种类型使用不同的纹理、速度和大小。
