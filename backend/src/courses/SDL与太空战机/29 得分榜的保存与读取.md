# 得分榜的保存与读取

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/BnmWOTvHsMU?si=KmV_YpiVqU0rqes5" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1PfwWeBEtj&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前一章中，我们已经实现了游戏结束场景的得分榜功能，但是这个得分榜有一个明显的缺点：当游戏关闭后，所有的得分记录都会丢失。在本章，我们将解决这个问题，实现得分榜数据的持久化存储，使玩家的得分记录在游戏重启后仍然保留。

## 持久化存储的意义

数据持久化是指将程序运行时产生的数据保存到非易失性存储介质（如硬盘）上，使这些数据在程序结束后仍然存在。在游戏开发中，持久化存储有以下几个重要作用：

1. **保存游戏进度**：允许玩家保存他们的游戏进度，稍后继续游戏
2. **记录历史最高分**：保存历史最高分记录，增加游戏的竞争性
3. **保存玩家偏好设置**：例如音量、控制设置等
4. **统计玩家行为**：收集玩家行为数据，用于改进游戏设计

在本章中，我们将重点关注如何保存和加载得分榜数据。

## 1. 文件读写基础

在C++中，文件操作主要通过`<fstream>`库实现。这个库提供了三个主要的类：
- `ifstream`：用于从文件读取数据
- `ofstream`：用于向文件写入数据
- `fstream`：既可以读也可以写

要使用这些类，首先需要包含相应的头文件：

```cpp
#include <fstream>
```

## 2. 设计存储格式

对于我们的得分榜，需要存储的信息包括：
- 玩家的得分
- 玩家的名字

我们将使用一个简单的文本文件格式，每行存储一个得分记录，格式为：`分数 名字`。例如：

```
100 玩家1
85 玩家2
70 玩家3
```

这种格式简单明了，易于读写，也便于手动编辑（如果需要）。

## 3. 实现保存数据的方法

首先，在`Game`类中，我们添加一个保存数据的方法。在`Game.h`中声明这个方法：

```cpp
// Game.h
private:
    // ...其他成员...
    void saveData();
```

然后在`Game.cpp`中实现这个方法：

```cpp
void Game::saveData()
{
    // 保存得分榜的数据
    std::ofstream file("assets/save.dat");
    if (!file.is_open()){
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to open save file");
        return;
    }
    for (const auto &entry : leaderBoard){
        file << entry.first << " " << entry.second << std::endl;
    }
}
```

这个方法的工作流程是：
1. 创建一个输出文件流，指向`assets/save.dat`文件
2. 检查文件是否成功打开，如果没有，则记录错误并返回
3. 遍历得分榜中的所有条目，将每个条目的分数和名字写入文件
4. 文件流在函数结束时会自动关闭

## 4. 实现加载数据的方法

接下来，我们需要实现加载数据的方法。在`Game.h`中声明这个方法：

```cpp
// Game.h
private:
    // ...其他成员...
    void loadData();
```

然后在`Game.cpp`中实现这个方法：

```cpp
void Game::loadData()
{
    // 加载得分榜的数据
    std::ifstream file("assets/save.dat");
    if (!file.is_open()){
        SDL_Log("Failed to open save file");
        return;
    }
    leaderBoard.clear();
    int score;
    std::string name;
    while (file >> score >> name){
        leaderBoard.insert({score, name});
    }
}
```

这个方法的工作流程是：
1. 创建一个输入文件流，指向`assets/save.dat`文件
2. 检查文件是否成功打开，如果没有，则记录信息并返回
3. 清空当前的得分榜，准备加载新数据
4. 创建临时变量用于存储读取的分数和名字
5. 使用`while`循环从文件中读取数据，直到文件结束
6. 将读取的分数和名字插入到得分榜中
7. 文件流在函数结束时会自动关闭

## 5. 在适当的时机调用这些方法

现在我们有了保存和加载数据的方法，接下来需要在适当的时机调用它们：

1. 在游戏初始化时加载数据：

```cpp
void Game::init()
{
    // ...其他初始化代码...
    
    // 载入得分
    loadData();
    
    // ...更多初始化代码...
}
```

2. 在游戏结束时保存数据：

```cpp
Game::~Game()
{
    saveData(); // Save data before closing
    clean();
}
```

这样，当游戏启动时，会从文件中加载之前保存的得分榜数据；当游戏关闭时，会将当前的得分榜数据保存到文件中。

## 6. 处理文件不存在的情况

在`loadData`方法中，如果文件不存在，我们只是简单地记录一条信息并返回。这意味着如果是第一次运行游戏，或者保存文件被删除了，得分榜将是空的，这是合理的默认行为。

而在`saveData`方法中，如果无法打开文件（可能是因为`assets`目录不存在或没有写入权限），我们会记录一个错误并返回。在实际的商业游戏中，可能需要更加健壮的错误处理机制，例如尝试在其他位置保存文件，或者提示用户有关权限问题。

## 完成效果

实现以上代码后，我们的游戏将具有持久化的得分榜功能：

1. 当玩家完成游戏并输入名字后，他们的得分将被添加到得分榜中
2. 当玩家关闭游戏时，得分榜数据将被保存到文件中
3. 当玩家再次启动游戏时，之前的得分榜数据将被加载，玩家可以看到历史最高分

这使得得分榜功能更加完整和有意义，玩家可以看到自己随着时间的推移的进步，增加了游戏的回头率和竞争性。

## 总结

在本章中，我们学习了如何实现得分榜数据的持久化存储，使玩家的得分记录在游戏重启后仍然保留。我们学习了：

1. 如何使用C++的`<fstream>`库进行文件读写操作
2. 如何设计简单的数据存储格式
3. 如何实现保存和加载数据的方法
4. 在什么时机调用这些方法，以确保数据的持久性
5. 如何处理可能出现的错误情况

这些技能非常重要，因为几乎所有的商业游戏都需要某种形式的数据持久化，无论是保存游戏进度、记录高分，还是存储玩家偏好设置。

## 练习

1. 扩展保存数据的格式，包含更多信息，如游戏完成的日期和时间。

2. 实现一个清除得分榜的功能，允许玩家重置得分记录。

3. 添加加密功能，防止玩家手动编辑保存文件来作弊（提示：可以使用简单的异或加密，或者计算数据的校验和）。
