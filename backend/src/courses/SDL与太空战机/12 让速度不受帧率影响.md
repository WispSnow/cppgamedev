# 让速度不受帧率影响

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/74leMwSu0a0?si=yFHvyR09ifZk9tix" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1oX6nYbE7o&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了使用键盘控制飞机移动的功能。然而，我们的实现存在一个显著的问题：飞机的移动速度直接与游戏的帧率相关。这意味着，如果游戏在不同性能的设备上运行，或者同一设备上的帧率波动，飞机的移动速度也会随之变化，导致游戏体验不一致。

在本课中，我们将解决这个问题，实现基于时间的移动，让游戏速度不受帧率影响。

<img src="https://theorhythm.top/gamedev/SS/12 让速度不受帧率影响1.PNG" style='width: 800px;' />

## 为什么要基于时间的移动？

在上一课中，我们的移动代码如下：

```cpp
void SceneMain::keyboardControl()
{
    auto keyboardState = SDL_GetKeyboardState(NULL);
    if (keyboardState[SDL_SCANCODE_W]){
        player.position.y -= 1;  // 每帧移动1个像素
    }
    // 其他方向类似...
}
```

这种实现方式存在以下问题：

1. **帧率依赖**：移动距离与帧率直接相关。如果游戏运行在60FPS，那么飞机每秒移动60像素；如果运行在30FPS，则每秒只移动30像素。

2. **不一致的游戏体验**：不同性能的设备上，游戏速度会有显著差异。高性能设备上飞机移动更快，低性能设备上移动更慢。

3. **不可预测性**：即使在同一设备上，帧率也可能因为游戏负载变化而波动，导致移动速度不稳定。

基于时间的移动是解决这些问题的标准方法，它通过计算两帧之间的时间差（deltaTime），将移动速度与实际经过的时间挂钩，而非帧数。

## 实现基于时间的移动

### 1. 修改Object.h，添加速度属性

首先，在`Player`结构中添加速度属性：

```cpp
struct Player{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 200;  // 每秒移动200像素
};
```

### 2. 修改Scene基类，传递deltaTime

然后，我们需要修改`Scene`基类的`update`方法，使其接收一个`deltaTime`参数：

```cpp
// Scene.h
class Scene{
public:
    Scene() = default;
    virtual ~Scene() = default;

    virtual void init() = 0;
    virtual void update(float deltaTime) = 0;  // 添加deltaTime参数
    virtual void render() = 0;
    virtual void clean() = 0;
    virtual void handleEvent(SDL_Event* event) = 0;
};
```

### 3. 修改SceneMain类

接下来，修改`SceneMain`类以适应这一变化：

```cpp
// SceneMain.h
class SceneMain : public Scene {
public:
    // ...
    void update(float deltaTime) override;
    // ...
    void keyboardControl(float deltaTime);  // 修改为接收deltaTime
};
```

```cpp
// SceneMain.cpp
void SceneMain::update(float deltaTime)
{
    keyboardControl(deltaTime);  // 传递deltaTime
}

void SceneMain::keyboardControl(float deltaTime)
{
    auto keyboardState = SDL_GetKeyboardState(NULL);
    if (keyboardState[SDL_SCANCODE_W]){
        player.position.y -= deltaTime * player.speed;  // 基于时间的移动
    }
    if (keyboardState[SDL_SCANCODE_S]){
        player.position.y += deltaTime * player.speed;
    }
    if (keyboardState[SDL_SCANCODE_A]){
        player.position.x -= deltaTime * player.speed;
    }
    if (keyboardState[SDL_SCANCODE_D]){
        player.position.x += deltaTime * player.speed;
    }
    
    // 边界检测代码不变...
}
```

现在，不管游戏在什么帧率下运行，飞机每秒都会移动大约`player.speed`个像素（在这个例子中是200像素）。

### 4. 修改Game类，计算deltaTime

最后，我们需要修改`Game`类来计算每帧之间的时间差，并将其传递给场景：

<img src="https://theorhythm.top/gamedev/SS/12 让速度不受帧率影响2.PNG" style='width: 800px;' />

首先，在`Game.h`中添加必要的成员变量：

```cpp
// Game.h
class Game
{
public:
    // ...
    void update(float deltaTime);  // 修改update方法
    // ...
private:
    // ...
    int FPS = 60;            // 目标帧率
    Uint32 frameTime;        // 每帧的目标时间（毫秒）
    float deltaTime;         // 两帧之间的时间差（秒）
};
```

然后，在`Game.cpp`中实现时间管理和帧率控制：

```cpp
// Game.cpp
void Game::init()
{
    frameTime = 1000 / FPS;
    // SDL 初始化 ...
}

void Game::run()
{
    while (isRunning)
    {
        auto frameStart = SDL_GetTicks();  // 记录帧开始时间
        
        SDL_Event event;
        handleEvent(&event);
        update(deltaTime);  // 传递deltaTime
        render();
        
        auto frameEnd = SDL_GetTicks();  // 记录帧结束时间
        auto diff = frameEnd - frameStart;  // 计算帧处理时间
        
        // 帧率限制和deltaTime计算
        if (diff < frameTime){
            SDL_Delay(frameTime - diff);  // 如果处理太快，延迟一下
            deltaTime = frameTime / 1000.0f;  // 转换为秒
        }
        else{
            deltaTime = diff / 1000.0f;  // 如果处理较慢，使用实际时间
        }
    }
}

void Game::update(float deltaTime)
{
    currentScene->update(deltaTime);  // 传递deltaTime给当前场景
}
```

这个实现不仅计算了`deltaTime`，还添加了帧率限制功能，确保游戏不会运行得过快。

## 关于帧率限制

添加帧率限制是很有必要的，因为：

1. **减少资源消耗**：没有必要让游戏运行在超高帧率，这会消耗额外的CPU和GPU资源。

2. **节约电池**：对于移动设备和笔记本电脑，限制帧率可以显著延长电池寿命。

3. **稳定性**：稳定的帧率比高但波动的帧率提供更好的游戏体验。

在我们的实现中，我们将目标帧率设为60FPS（`frameTime = 1000 / FPS`毫秒），这是大多数游戏的标准帧率。如果一帧的处理时间少于`frameTime`，我们通过`SDL_Delay`等待剩余时间；如果处理时间超过`frameTime`，我们接受实际的帧率降低，但仍然使用正确的`deltaTime`来确保移动速度不变。

## 测试与调整

实现基于时间的移动后，你应该测试不同的情况：

1. **尝试不同的速度值**：可以调整`player.speed`，找到适合游戏的移动速度。

2. **人为限制帧率**：可以增加一些计算密集型操作或使用调试工具限制帧率，确认即使在低帧率下，移动速度也保持一致。

3. **调整目标帧率**：可以尝试不同的`FPS`值，看看对游戏体验的影响。

## 总结

在本课中，我们实现了基于时间的移动系统，确保游戏速度不受帧率影响。主要改进包括：

1. 在`Player`结构中添加`speed`属性，定义每秒移动的像素数。

2. 修改`Scene`基类和`SceneMain`类，使其接收和使用`deltaTime`。

3. 在`Game`类中实现时间管理和帧率限制。

4. 将固定值移动替换为`deltaTime * speed`，实现基于时间的移动。

这些改进确保了游戏在不同性能的设备上提供一致的体验，是专业游戏开发中的标准做法。在接下来的课程中，我们将继续扩展游戏功能，添加更多交互元素。

## 练习

1. 实现可变速度：添加一个加速机制，例如按住Shift键时飞机速度翻倍。

2. 添加平滑减速：当松开按键时，不要立即停止，而是逐渐减速至停止。

4. 添加调试信息：在屏幕上显示当前帧率和deltaTime，以便观察它们的变化。

5. 扩展时间管理系统：实现游戏暂停功能，在暂停时停止更新但继续渲染。
