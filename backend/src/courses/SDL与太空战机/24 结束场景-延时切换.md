# 结束场景-延时切换

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/VosN_lXaGGU?si=PwGlDM37RUWUEgi8" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1Wrc8enEBx&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了标题场景和场景管理系统，使游戏有了一个入口点。然而，游戏还缺少一个出口点——当玩家失败时，游戏需要一个合适的结束场景。在本课中，我们将学习如何创建一个结束场景，并实现延时切换功能，使玩家能够在游戏结束后看到最终的爆炸效果，然后自然地过渡到结束场景。

<img src="https://theorhythm.top/gamedev/SS/24 结束场景-延迟切换.PNG" style='width: 800px;' />

## 延时场景切换的意义

在游戏中，直接切换场景往往会让玩家感到突兀。特别是在游戏结束时，如果立即切换到结束场景，玩家可能会错过重要的视觉反馈（如飞船爆炸效果），也无法理解游戏结束的原因。延时场景切换有以下几个优点：

1. **提供视觉过渡**：给玩家时间观察游戏结束的视觉效果
2. **增强游戏体验**：让游戏流程更加自然和流畅
3. **提供心理缓冲**：给玩家一个短暂的缓冲时间，接受游戏结束的事实
4. **增加游戏张力**：在游戏结束和结束场景之间创造期待感

## 1. 创建结束场景类

首先，我们创建一个基本的结束场景类，继承自场景基类：

```cpp
// SceneEnd.h
#ifndef SCENE_END_H
#define SCENE_END_H

#include "Scene.h"

class SceneEnd : public Scene{
    virtual void init();
    virtual void update(float deltaTime);
    virtual void render();
    virtual void clean();
    virtual void handleEvent(SDL_Event* event);
};

#endif // SCENE_END_H
```

然后，在`SceneEnd.cpp`中实现这些基本方法：

```cpp
// SceneEnd.cpp
#include "SceneEnd.h"

void SceneEnd::init()
{
}

void SceneEnd::update(float deltaTime)
{
}

void SceneEnd::render()
{
}

void SceneEnd::clean()
{
}

void SceneEnd::handleEvent(SDL_Event *event)
{
}
```

这是一个最基本的结束场景框架，我们将在后续章节中完善其功能。现在，我们的重点是实现延时切换机制。

## 2. 在主场景中实现延时切换

为了实现延时切换，我们需要在`SceneMain`类中添加以下成员和方法：

### 2.1 添加延时切换相关成员

在`SceneMain.h`中，我们添加一个计时器成员：

```cpp
// SceneMain.h
class SceneMain : public Scene {
private:
    // ...现有成员...
    float timerEnd = 0.0f;
    // ...其他成员...
};
```

这个计时器将用于跟踪游戏结束后经过的时间。

### 2.2 实现延时切换方法

在`SceneMain.h`中，我们声明一个延时切换方法：

```cpp
// SceneMain.h
class SceneMain : public Scene {
private:
    // ...其他方法...
    void changeSceneDelayed(float deltaTime, float delay);
    // ...其他方法...
};
```

然后，在`SceneMain.cpp`中实现这个方法：

```cpp
// SceneMain.cpp
void SceneMain::changeSceneDelayed(float deltaTime, float delay)
{
    timerEnd += deltaTime;
    if (timerEnd > delay){
        auto sceneEnd = new SceneEnd();
        game.changeScene(sceneEnd);
    }
}
```

这个方法累计经过的时间，当时间超过指定的延迟时，创建一个新的结束场景并切换到它。

### 2.3 在更新方法中调用延时切换

最后，我们需要在主场景的`update`方法中调用延时切换方法，但仅在玩家死亡时才调用：

```cpp
// SceneMain.cpp
void SceneMain::update(float deltaTime)
{
    keyboardControl(deltaTime);
    updatePlayerProjectiles(deltaTime);
    updateEnemyProjectiles(deltaTime);
    spawEnemy();
    updateEnemies(deltaTime);
    updatePlayer(deltaTime);
    updateExplosions(deltaTime);
    updateItems(deltaTime);
    if (isDead){
        changeSceneDelayed(deltaTime, 3); // 3秒后切换到结束场景
    }
}
```

这里，我们设置了3秒的延迟，这给玩家足够的时间观察死亡动画，但又不会太长导致玩家等待不耐烦。

## 3. 检测游戏结束条件

我们需要检测玩家何时死亡，以便触发延时切换。在`updatePlayer`方法中，我们添加以下代码：

```cpp
// SceneMain.cpp
void SceneMain::updatePlayer(float)
{
    if (isDead) {
        return;
    }
    if (player.currentHealth <= 0){
        // 游戏结束逻辑
        auto currentTime = SDL_GetTicks();
        isDead = true;
        auto explosion = new Explosion(explosionTemplate);
        explosion->position.x = player.position.x + player.width / 2 - explosion->width / 2;
        explosion->position.y = player.position.y + player.height / 2 - explosion->height / 2;
        explosion->startTime = currentTime;
        explosions.push_back(explosion);
        Mix_PlayChannel(-1, sounds["player_explode"], 0);
        return;
    }
    // ...其他代码...
}
```

当玩家生命值降至0时，我们将`isDead`标志设置为true，创建一个爆炸效果，并播放爆炸音效。此后，延时切换机制将在`update`方法中被触发。

## 4. 修改渲染逻辑

为了确保在玩家死亡后不再显示玩家飞船，我们在`render`方法中添加条件判断：

```cpp
// SceneMain.cpp
void SceneMain::render()
{
    // 渲染玩家子弹
    renderPlayerProjectiles();
    //渲染敌机子弹
    renderEnemyProjectiles();
    // 渲染玩家
    if (!isDead){
        SDL_Rect playerRect = { static_cast<int>(player.position.x), 
                        static_cast<int>(player.position.y), 
                        player.width, 
                        player.height};
        SDL_RenderCopy(game.getRenderer(), player.texture, NULL, &playerRect);
    }
    // ...其他渲染代码...
}
```

这样，当玩家死亡时，飞船将不再显示，但爆炸效果和其他游戏元素仍然可见。

## 5. 包含必要的头文件

为了使用`SceneEnd`类，我们需要在`SceneMain.cpp`的开头包含相应的头文件：

```cpp
// SceneMain.cpp
#include "SceneMain.h"
#include "SceneTitle.h"
#include "SceneEnd.h"
#include "Game.h"
// ...其他包含文件...
```

通过包含`SceneEnd.h`，我们可以在`changeSceneDelayed`方法中创建`SceneEnd`对象。

## 完整的游戏流程

通过实现延时切换，我们创建了一个完整的游戏流程：

1. 游戏从**标题场景**开始
2. 玩家按下J键进入**主游戏场景**
3. 当玩家死亡时，游戏显示爆炸效果，并在3秒后自动切换到**结束场景**
4. 在结束场景中，玩家可以查看得分或重新开始游戏

这种流程提供了良好的用户体验，让游戏感觉更加完整和专业。

## 总结

在本课中，我们实现了游戏结束场景和延时切换功能，为游戏增加了更完整的结构。我们学习了：

1. 如何创建基本的结束场景框架
2. 如何实现延时切换机制
3. 如何检测游戏结束条件
4. 如何修改渲染逻辑以适应游戏结束状态

这些技术对于创建流畅、自然的游戏体验非常重要。在下一课中，我们将进一步完善结束场景，添加更多功能，如显示最终得分、重新开始选项和返回主菜单选项等。

## 练习

1. 修改延时切换的时间，实验不同的延迟值如何影响游戏体验。

2. 在玩家死亡后添加特殊的视觉效果，如屏幕闪烁或颜色变化，增强游戏结束的视觉反馈。

3. 实现一个倒计时显示，在游戏结束后显示切换到结束场景的倒计时，让玩家知道还有多少时间可以观察最终战况。
