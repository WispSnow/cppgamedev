# 结束场景-闪烁光标

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/tGCX1UiMWrM?si=uoOGr2AOzkTHZsep" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1TzwLeJEgj&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前两章中，我们实现了结束场景的文字输入功能，并解决了中文字符退格的问题。现在，我们的游戏已经可以正确地接收和处理玩家输入的名字。然而，为了提供更好的用户体验，我们还可以添加一个视觉指示器——闪烁光标，以帮助玩家了解当前的输入位置。在本课中，我们将学习如何实现这个闪烁光标功能。

<img src="https://theorhythm.top/gamedev/SS/27 结束场景-闪烁光标.PNG" style='width: 800px;' />

## 光标的重要性

在文本输入界面中，光标是一个重要的视觉指示器，它有以下几个关键作用：

1. **指示输入位置**：光标清晰地标示出文本将被插入的位置
2. **提供状态反馈**：闪烁的光标表示系统正在等待输入
3. **增强用户体验**：使文本输入界面看起来更加专业和交互式
4. **减少用户错误**：帮助用户准确定位，减少输入错误

## 1. 添加闪烁光标所需的成员变量

首先，我们需要在`SceneEnd`类中添加一个计时器成员，用于控制光标的闪烁：

```cpp
// SceneEnd.h
class SceneEnd : public Scene{
private:
    bool isTyping = true;
    std::string name = "";
    float blinkTimer = 1.0f;  // 新增：光标闪烁计时器

    // ...其他成员...
};
```

## 2. 实现光标闪烁的更新逻辑

接下来，我们需要在`update`方法中更新光标闪烁计时器：

```cpp
// SceneEnd.cpp
void SceneEnd::update(float deltaTime)
{
    blinkTimer -= deltaTime;
    if (blinkTimer <= 0){
        blinkTimer += 1.0f;
    }
}
```

这段代码会使`blinkTimer`在0到1之间循环变化，我们可以利用这个值来控制光标的显示和隐藏，创造闪烁效果。

## 3. 修改文本渲染函数返回位置信息

为了在文本末尾精确放置光标，我们需要知道渲染文本后的结束位置。让我们修改`Game`类的`renderTextCentered`方法，使其返回文本的结束位置：

```cpp
// Game.h
class Game
{
public:
    // ...其他方法...

    // 渲染文字函数，返回文本结束位置的坐标点
    SDL_Point renderTextCentered(std::string text, float posY, bool isTitle);
    void renderTextPos(std::string text, int posX, int posY);

    // ...其他方法...
};
```

```cpp
// Game.cpp
SDL_Point Game::renderTextCentered(std::string text, float posY, bool isTitle)
{
    SDL_Color color = {255, 255, 255, 255};
    SDL_Surface *surface;
    if (isTitle){
        surface = TTF_RenderUTF8_Solid(titleFont, text.c_str(), color);
    }else{
        surface = TTF_RenderUTF8_Solid(textFont, text.c_str(), color);
    }
    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, surface);
    int y = static_cast<int>((getWindowHeight() - surface->h) * posY);
    SDL_Rect rect = {getWindowWidth() / 2 - surface->w / 2,
                     y,
                     surface->w,
                     surface->h};
    SDL_RenderCopy(renderer, texture, NULL, &rect);
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(surface);
    return {rect.x + rect.w, y};  // 返回文本末尾的坐标
}
```

我们修改了`renderTextCentered`方法，使其返回一个`SDL_Point`类型的值，表示文本末尾的坐标（x为文本右边界的x坐标，y为文本的y坐标）。

## 4. 添加在指定位置渲染文本的方法

为了在指定位置渲染光标，我们需要添加一个新方法，允许我们在任意位置渲染文本：

```cpp
// Game.cpp
void Game::renderTextPos(std::string text, int posX, int posY)
{
    SDL_Color color = {255, 255, 255, 255};
    SDL_Surface *surface = TTF_RenderUTF8_Solid(textFont, text.c_str(), color);
    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_Rect rect = {posX, posY, surface->w, surface->h};
    SDL_RenderCopy(renderer, texture, NULL, &rect);
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(surface);
}
```

这个方法与`renderTextCentered`类似，但允许我们指定文本的确切位置，而不是自动居中。

## 5. 在渲染阶段显示闪烁光标

最后，我们需要修改`renderPhase1`方法，在文本输入区域显示闪烁光标：

```cpp
// SceneEnd.cpp
void SceneEnd::renderPhase1()
{   
    auto score = game.getFinalScore();
    std::string scoreText = "你的得分是：" + std::to_string(score);
    std::string gameOver = "Game Over";
    std::string instrutionText = "请输入你的名字，按回车键确认：";
    game.renderTextCentered(scoreText, 0.1, false);
    game.renderTextCentered(gameOver, 0.4, true);
    game.renderTextCentered(instrutionText, 0.6, false);

    if (name != ""){
        SDL_Point p = game.renderTextCentered(name, 0.8, false);
        if (blinkTimer < 0.5){
            game.renderTextPos("_", p.x, p.y);
        }
    }else{
        if (blinkTimer < 0.5){
            game.renderTextCentered("_", 0.8, false);
        }
    }
}
```

这段代码做了两件事：

1. 当玩家已经输入了一些文本时：
   - 渲染文本并获取其结束位置
   - 根据`blinkTimer`的值，在文本末尾显示或隐藏下划线字符（用作光标）

2. 当玩家尚未输入任何文本时：
   - 根据`blinkTimer`的值，在默认位置显示或隐藏下划线字符

通过这种方式，光标会以每秒约两次的频率闪烁（当`blinkTimer`小于0.5时显示，大于等于0.5时隐藏），提供清晰的视觉反馈，表明程序正在等待用户输入。

## 闪烁效果的实现原理

闪烁效果的实现基于一个简单的时间计数器和条件渲染机制：

1. **计时器循环**：`blinkTimer`在0到1之间循环变化，每秒完成一个完整循环
2. **阈值控制**：当`blinkTimer`小于0.5时显示光标，大于等于0.5时隐藏光标
3. **视觉效果**：这种显示-隐藏的交替产生了闪烁的效果

这是一种常见的游戏开发技术，也可以用于实现其他需要周期性变化的视觉效果，如按钮高亮、警告标识等。

## 总结

在本课中，我们为结束场景的文本输入界面添加了闪烁光标功能，使界面更加直观和用户友好。我们学习了：

1. 如何使用计时器实现闪烁效果
2. 如何修改文本渲染函数以返回位置信息
3. 如何在指定位置渲染文本
4. 如何根据计时器值有条件地显示光标

这些技术不仅可以用于实现文本输入光标，还可以应用于其他需要周期性变化或交互反馈的界面元素。通过这些小细节的改进，我们的游戏界面变得更加专业和用户友好。

## 练习

1. 尝试修改光标的外观，例如使用竖线"|"代替下划线"_"，或者调整光标的颜色。

2. 实现更复杂的光标闪烁效果，例如使用平滑的淡入淡出而不是简单的显示/隐藏。

3. 添加键盘导航功能，允许玩家使用箭头键在已输入的文本中移动光标位置。
