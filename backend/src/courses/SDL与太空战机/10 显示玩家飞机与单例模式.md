# 显示玩家飞机与单例模式

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/YjAKjV5Dq5Y?si=JkBweby2USVJVcyT" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV11j6gYVEhX&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们完善了游戏框架，实现了SDL的初始化、窗口创建和事件处理功能。但是，我们的游戏窗口中还没有显示任何内容。在本课中，我们将添加玩家飞机，这是我们游戏中第一个可见的元素。同时，我们将改进`Game`类的设计，将其实现为单例模式，以便在全局范围内更方便地访问游戏资源。

## 游戏对象的基本结构

首先，让我们创建一个新文件`Object.h`，用于定义游戏中的各种对象。在这个文件中，我们先定义一个简单的`Player`结构，用于表示玩家飞机：

<img src="https://theorhythm.top/gamedev/SS/10 场景中的元素.PNG" style='width: 800px;' />

```cpp
// Object.h
#ifndef OBJECT_H
#define OBJECT_H
#include <SDL.h>

struct Player{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
};

#endif // OBJECT_H
```

这个结构包含了玩家飞机的基本属性：
- **texture**：飞机的纹理，将从图像文件加载
- **position**：飞机在屏幕上的位置，使用浮点数以实现平滑移动
- **width**和**height**：飞机的宽度和高度

我们使用结构体而不是类，是因为在这个简单的例子中，我们不需要对数据进行封装或提供复杂的方法。随着游戏的发展，我们可能会将其改为更完整的类设计。

## 实现单例模式

接下来，我们将`Game`类改造为单例模式。单例模式确保一个类只有一个实例，并提供一个全局访问点。这对游戏引擎特别有用，因为我们通常只需要一个游戏实例，而且需要从不同的地方访问它。

<img src="https://theorhythm.top/gamedev/SS/10 单例模式.PNG" style='width: 800px;' />

### 修改Game.h

```cpp
// Game.h
#ifndef GAME_H
#define GAME_H

#include "Scene.h"
#include "SDL.h"

class Game
{
public:
    static Game& getInstance(){
        static Game instance;
        return instance;
    }

    ~Game();
    void run();
    void init();
    void clean();
    void changeScene(Scene* scene);

    void handleEvent(SDL_Event *event);
    void update();
    void render();

    SDL_Window* getWindow() { return window; }
    SDL_Renderer* getRenderer() { return renderer; }
    int getWindowWidth() { return windowWidth; }
    int getWindowHeight() { return windowHeight; }
private:
    Game();
    // 删除拷贝与赋值构造函数
    Game(const Game&) = delete;
    Game& operator=(const Game&) = delete;

    bool isRunning = true;
    Scene* currentScene = nullptr;
    SDL_Window* window = nullptr;
    SDL_Renderer* renderer = nullptr;
    int windowWidth = 600;
    int windowHeight = 800;
};

#endif
```

相比上一课，我们做了以下关键修改：

1. **添加静态方法`getInstance()`**：这是单例模式的核心，它返回类的唯一实例。我们使用局部静态变量确保线程安全的懒汉式初始化。

2. **将构造函数设为私有**：防止外部代码创建`Game`类的实例。

3. **删除拷贝构造函数和赋值运算符**：防止通过拷贝创建新实例，确保单例的唯一性。

4. **添加访问器方法**：提供对窗口、渲染器和窗口尺寸的访问，使其他类（如场景类）可以使用这些资源。

### 修改main.cpp

由于`Game`类现在是单例模式，我们需要修改`main.cpp`：

```cpp
// main.cpp
#include <iostream>
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_mixer.h>
#include <SDL_ttf.h>
#include "Game.h"

int main(int, char**) {
    Game& game = Game::getInstance();
    game.init();
    game.run();
    
    return 0;
}
```

现在我们通过`getInstance()`获取`Game`实例，而不是直接创建一个新的实例。

## 在场景中显示玩家飞机

为了载入并显示图片，我们需要引入SDL_image并进行初始化

### 修改Game.cpp

```cpp
// Game.cpp 更新
#include "Game.h"
#include "SceneMain.h"
#include <SDL.h>
#include <SDL_image.h>

void Game::init()
{
    // ... 创建渲染器之后
    // 初始化SDL_image
    if (IMG_Init(IMG_INIT_PNG) != IMG_INIT_PNG) {
        SDL_LogError(SDL_LOG_CATEGORY_ERROR, "SDL_image could not initialize! SDL_image Error: %s\n", IMG_GetError());
        isRunning = false;
    }

    currentScene = new SceneMain();
    currentScene->init();
}
```

接下来，我们修改`SceneMain`类，添加并显示玩家飞机。

### 修改SceneMain.h

```cpp
// SceneMain.h
#ifndef SCENE_MAIN_H
#define SCENE_MAIN_H

#include "Scene.h"
#include "Object.h"

class Game;

class SceneMain : public Scene {
public:
    SceneMain();
    ~SceneMain();

    void update() override;
    void render() override;
    void handleEvent(SDL_Event* event) override;
    void init() override;
    void clean() override;

private:
    Game &game;
    Player player;
    
};

#endif // SCENE_MAIN_H
```

我们在`SceneMain`类中添加了两个私有成员：
- **game**：对`Game`单例的引用，使场景可以访问游戏资源
- **player**：玩家飞机对象

### 修改SceneMain.cpp

```cpp
// SceneMain.cpp
#include "SceneMain.h"
#include "Game.h"
#include <SDL.h>
#include <SDL_image.h>

SceneMain::SceneMain() : game(Game::getInstance())
{
}

SceneMain::~SceneMain()
{
}

void SceneMain::update()
{
}

void SceneMain::render()
{
    SDL_Rect playerRect = { static_cast<int>(player.position.x), 
                            static_cast<int>(player.position.y), 
                            player.width, 
                            player.height };
    SDL_RenderCopy(game.getRenderer(), player.texture, NULL, &playerRect);
}

void SceneMain::handleEvent(SDL_Event *event)
{
}

void SceneMain::init()
{
    player.texture = IMG_LoadTexture(game.getRenderer(), "assets/image/SpaceShip.png");
    if (player.texture == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_ERROR, "Failed to load player texture: %s", SDL_GetError());
    }
    SDL_QueryTexture(player.texture, NULL, NULL, &player.width, &player.height);
    player.width /= 4;
    player.height /= 4;
    player.position.x = game.getWindowWidth() / 2 - player.width / 2;
    player.position.y = game.getWindowHeight() - player.height;
}

void SceneMain::clean()
{
    if (player.texture != nullptr)
    {
        SDL_DestroyTexture(player.texture);
    }
}
```

在`SceneMain`类的实现中，我们做了以下关键修改：

1. **构造函数**：初始化`game`引用，指向`Game`单例。

2. **init方法**：
   - 加载玩家飞机的纹理
   - 查询纹理的尺寸
   - 缩小纹理尺寸（除以4）以适应游戏窗口
   - 将飞机定位在窗口底部中央

3. **render方法**：
   - 创建一个矩形，定义飞机在屏幕上的位置和大小
   - 使用`SDL_RenderCopy`将飞机纹理渲染到屏幕上

4. **clean方法**：
   - 释放飞机纹理资源

## 运行效果

编译并运行程序，你应该会看到一个窗口，窗口底部中央显示一个飞机图像：

<img src="https://theorhythm.top/gamedev/SS/10 游戏画面截图.png" style='width: 800px;' />

## 单例模式的优势

实现单例模式为我们带来了以下好处：

1. **全局访问点**：任何类都可以通过`Game::getInstance()`访问游戏实例，无需传递引用或指针。

2. **资源共享**：游戏窗口、渲染器等资源可以共享给所有需要的类，避免重复创建。

3. **控制实例数量**：确保游戏引擎只有一个实例，避免资源冲突。

4. **延迟初始化**：单例实例在第一次被请求时才创建，优化了资源使用。

## 总结

在本课中，我们完成了两个重要的改进：

1. **实现了单例模式**：将`Game`类改造为单例，提供了更好的资源访问方式。

2. **添加了玩家飞机**：创建了`Player`结构，并在场景中显示玩家飞机。

这些改进为我们的游戏添加了第一个可见元素，同时改进了代码结构。在接下来的课程中，我们将实现键盘控制，使玩家可以移动飞机。

## 练习

1. 尝试修改玩家飞机的缩放比例和初始位置，观察效果。

2. 使用SDL_image库加载不同格式的图像作为玩家飞机的纹理。

3. 实现一个简单的背景，例如一个纯色背景或一张背景图片。

4. 研究SDL中的颜色调制（SDL_SetTextureColorMod），尝试改变飞机的颜色。
