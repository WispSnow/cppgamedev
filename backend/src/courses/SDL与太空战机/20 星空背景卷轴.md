# 星空背景卷轴

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/GsHcdTcVENM?si=ttl4dhPqOp3FgjG0" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1LmreYPEbz&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们为游戏添加了音乐和音效，使游戏体验更加完整和生动。然而，游戏的视觉效果仍然比较单调，背景是纯黑色的，缺乏宇宙环境的感觉。在这一课中，我们将实现一个星空背景卷轴效果，使游戏场景更加丰富和动感。

## 背景卷轴的概念

背景卷轴（Background Scrolling）是一种常见的2D游戏技术，用于创建游戏世界的视觉深度和运动感。通过不断移动背景图像，可以给玩家一种在游戏世界中移动的错觉。在竖直射击游戏中，背景通常是从上到下滚动，以营造飞机向前飞行的感觉。

为了增强深度感，我们可以使用多层背景卷轴技术（Parallax Scrolling）。这种技术使用多个背景层，每层以不同的速度移动，从而创造出前景和远景的视觉差异：

- 远景层（远处的星星）移动较慢，给人一种距离较远的感觉
- 近景层（近处的星星）移动较快，给人一种距离较近的感觉

这种层次感使游戏画面更加丰富和立体，提升了游戏的视觉体验。

## 1. 定义背景数据结构

首先，我们在`Object.h`文件中定义一个新的结构体`Background`，用于表示卷轴背景：

```cpp
// Object.h
struct Background{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    float offset = 0;
    int width = 0;
    int height = 0;
    int speed = 30;
};
```

这个结构体包含了背景的基本属性：
- `texture`：背景图片的纹理
- `position`：背景的位置坐标
- `offset`：背景的偏移量，用于实现滚动效果
- `width`和`height`：背景图片的宽度和高度
- `speed`：背景滚动的速度

## 2. 添加背景成员变量

在`Game.h`文件中，我们需要添加背景相关的成员变量和方法：

```cpp
// Game.h
#include "Object.h"

class Game {
public:
    // ...现有方法...
    void backgroundUpdate(float deltaTime);
    void renderBackground();

private:
    // ...现有成员...
    Background nearStars;  // 近处的星星
    Background farStars;   // 远处的星星
};
```

我们添加了以下新成员和方法：
- `nearStars`：近处的星星背景，移动速度较快
- `farStars`：远处的星星背景，移动速度较慢
- `backgroundUpdate()`：更新背景位置的方法
- `renderBackground()`：渲染背景的方法

## 3. 初始化背景资源

在`Game.cpp`的`init()`方法中，我们需要初始化背景资源：

```cpp
// Game.cpp
void Game::init()
{
    // ...前面的代码保持不变

    // 初始化背景卷轴
    nearStars.texture = IMG_LoadTexture(renderer, "assets/image/Stars-A.png");
    SDL_QueryTexture(nearStars.texture, NULL, NULL, &nearStars.width, &nearStars.height);   
    nearStars.height /= 2;
    nearStars.width /= 2;

    farStars.texture = IMG_LoadTexture(renderer, "assets/image/Stars-B.png");
    SDL_QueryTexture(farStars.texture, NULL, NULL, &farStars.width, &farStars.height);
    farStars.height /= 2;
    farStars.width /= 2;
    farStars.speed = 20;  // 远处的星星移动速度较慢

    // ...后面的代码保持不变
}
```

这段代码加载了两张星空图片作为背景，并设置了初始属性。为了让背景图片不会太大，我们将它们的尺寸缩小为原来的一半。同时，我们将远处星星的速度设置为20，比近处星星的默认速度（30）慢，以创造出深度感。

## 4. 清理背景资源

在`Game.cpp`的`clean()`方法中，我们需要添加清理背景资源的代码：

```cpp
// Game.cpp
void Game::clean()
{
    // ...前面的代码保持不变

    if (nearStars.texture != nullptr){
        SDL_DestroyTexture(nearStars.texture);
    }
    if (farStars.texture != nullptr){
        SDL_DestroyTexture(farStars.texture);
    }

    // ...后面的代码保持不变
}
```

这段代码确保在游戏结束时释放背景纹理资源，防止内存泄漏。

## 5. 更新背景位置

接下来，我们实现`backgroundUpdate()`方法，用于更新背景的位置：

```cpp
// Game.cpp
void Game::backgroundUpdate(float deltaTime)
{
    nearStars.offset += nearStars.speed * deltaTime;
    if (nearStars.offset >= 0)
    {
        nearStars.offset -= nearStars.height;
    }

    farStars.offset += farStars.speed * deltaTime;
    if (farStars.offset >= 0){
        farStars.offset -= farStars.height;
    }
}
```

在这个方法中，我们根据背景的速度和经过的时间更新背景的偏移量，并在偏移量超过某个阈值时重置它，以实现无缝滚动效果。注意，我们的背景是从下往上滚动的，所以偏移量是逐渐增加的，而起始偏移量是负数（在屏幕外）。

## 6. 渲染背景

最后，我们实现`renderBackground()`方法，用于渲染背景：

```cpp
// Game.cpp
void Game::renderBackground()
{
    // 渲染远处的星星
    for (int posY = static_cast<int>(farStars.offset); posY < getWindowHeight(); posY += farStars.height){
        for (int posX = 0; posX < getWindowWidth(); posX += farStars.width){
            SDL_Rect ds = {posX, posY, farStars.width, farStars.height};
            SDL_RenderCopy(renderer, farStars.texture, NULL, &ds);
        }
    }
    // 渲染近处的星星
    for (int posY = static_cast<int>(nearStars.offset); posY < getWindowHeight(); posY += nearStars.height)
    {
        for (int posX = 0; posX < getWindowWidth(); posX += nearStars.width)
        {
            SDL_Rect dstRect = {posX, posY, nearStars.width, nearStars.height};
            SDL_RenderCopy(renderer, nearStars.texture, nullptr, &dstRect);
        }   
    }
}
```

这个方法使用嵌套循环，将背景图片平铺在整个屏幕上，从偏移位置开始，一直到屏幕底部。通过这种方式，我们可以创建一个无缝的卷轴背景，即使背景图片的尺寸小于屏幕的尺寸。

渲染顺序很重要：我们先渲染远处的星星，然后再渲染近处的星星，这样近处的星星会覆盖远处的星星，创造出适当的深度效果。

## 7. 更新游戏主循环

最后，我们需要在游戏主循环中调用背景相关的方法：

```cpp
// Game.cpp
void Game::update(float deltaTime)
{
    backgroundUpdate(deltaTime);
    currentScene->update(deltaTime);
}

void Game::render()
{
    // 清空
    SDL_RenderClear(renderer);
    // 渲染星空背景
    renderBackground();

    currentScene->render();
    // 显示更新
    SDL_RenderPresent(renderer);
}
```

在`update()`方法的开始，我们调用`backgroundUpdate()`更新背景位置。在`render()`方法中，我们在渲染场景之前先渲染背景，保证背景位于场景的最底层。

## 背景卷轴原理解析

让我们分析一下背景卷轴的实现原理：

1. **重复平铺**：
   我们的背景图片通常小于屏幕尺寸，所以需要将它们重复平铺以覆盖整个屏幕。在`renderBackground()`方法中，我们使用嵌套循环将背景图片平铺在屏幕上。

2. **持续移动**：
   通过在每一帧更新背景的偏移量，我们实现了背景的持续移动。偏移量是基于背景速度和帧间时间间隔计算的。

3. **无缝循环**：
   当背景滚动出屏幕时，我们需要重置偏移量，使背景从另一侧重新进入屏幕，从而创造出无限滚动的效果。在`backgroundUpdate()`方法中，我们检查偏移量是否超过阈值，如果是，则重置它。

4. **多层次感**：
   通过使用多个背景层，且每层移动速度不同，我们创造出深度感。远处的星星移动较慢，近处的星星移动较快，这符合现实世界中的视差原理。

## 总结

在本课中，我们实现了星空背景卷轴效果，使游戏场景更加丰富和动感。我们学习了：

1. 如何设计背景卷轴的数据结构
2. 如何加载和初始化背景资源
3. 如何实现背景的无缝滚动
4. 如何创造多层次的背景效果（视差滚动）
5. 如何将背景渲染到游戏场景中

这些技术不仅适用于星空背景，也可以用于实现其他类型的动态背景，如云层、山脉、海洋等。通过合理设计背景层次和移动速度，可以创造出各种生动的游戏场景。

## 练习

1. 尝试添加第三层背景，如更远处的星系或星云，使背景层次感更加丰富。

2. 实现背景的水平移动效果，例如在玩家飞机左右移动时，背景也随之轻微移动，增强游戏的互动感。

3. 尝试实现动态背景效果，如星星闪烁、彗星划过等，使背景更加生动。

4. 实现背景的渐变效果，例如随着游戏进程的推进，背景颜色或样式逐渐变化，用于指示游戏关卡或难度的变化。
