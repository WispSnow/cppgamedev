# 结束场景-得分榜

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/J-n7bJGqwus?si=89Ta2DgTWaYoUKST" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1Y7wFeEE26&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前面几章中，我们已经实现了结束场景中的文字输入功能和闪烁光标，使玩家能够输入自己的名字。但是，输入名字后，我们还没有一个地方来展示玩家的得分和排名。在本课中，我们将实现得分榜功能，让玩家可以看到自己在游戏中的表现与其他玩家相比如何。

<img src="https://theorhythm.top/gamedev/SS/28 结束场景-得分榜.PNG" style='width: 800px;' />

## 得分榜的意义

得分榜（Leaderboard）是许多游戏中的重要功能，它有以下几个关键作用：

1. **提供竞争动力**：让玩家能够与其他玩家比较自己的成绩，激发竞争欲望
2. **增加回头率**：玩家会想要再次尝试，以提高自己在排行榜上的位置
3. **展示进步**：玩家可以看到自己的历史最高分，了解自己的进步
4. **社区感**：创造一种社区感，让玩家感觉自己是更大社区的一部分

## 1. 设计数据结构存储得分信息

首先，我们需要在`Game`类中添加一个数据结构来存储得分榜信息。我们使用`std::multimap`来存储得分和玩家名字，并使用`std::greater`作为比较函数，确保分数按降序排列（高分在前）：

```cpp
// Game.h
class Game {
private:
    // ...其他成员...
    std::multimap<int, std::string, std::greater<int>> leaderBoard; // 使用multimap来存储分数和名字，分数作为键，名字作为值
};
```

`std::multimap`允许我们存储具有相同键（在这里是分数）的多个条目，这对于可能有相同分数的不同玩家很有用。`std::greater<int>`比较函数确保分数按降序排序，这样高分就会出现在前面。

## 2. 添加操作排行榜的方法

接下来，我们在`Game`类中添加方法来操作排行榜：

```cpp
// Game.h
class Game {
public:
    // ...其他方法...
    void insertLeaderBoard(int score, std::string name); // 插入排行榜
    std::multimap<int, std::string, std::greater<int>>& getLeaderBoard() { return leaderBoard; } // 返回leaderBoard的引用
};
```

然后在`Game.cpp`中实现`insertLeaderBoard`方法：

```cpp
// Game.cpp
void Game::insertLeaderBoard(int score, std::string name)
{
    leaderBoard.insert({score, name});
    if (leaderBoard.size() > 8){
        leaderBoard.erase(--leaderBoard.end());
    }
}
```

这个方法做了两件事：
1. 将新的分数和名字插入到排行榜中
2. 如果排行榜条目超过8个，删除最低分（即排行榜末尾的条目）

通过这种方式，我们保持排行榜的大小合理，只显示最高的8个分数。

## 3. 在结束场景中实现排行榜显示

现在，我们需要修改`SceneEnd`类，使其能够在玩家输入名字后显示排行榜。首先，我们添加一个状态变量`isTyping`来区分名字输入阶段和排行榜显示阶段：

```cpp
// SceneEnd.h
class SceneEnd : public Scene{
private:
    bool isTyping = true;
    // ...其他成员...
};
```

然后，在`render`方法中，根据当前状态渲染不同的内容：

```cpp
// SceneEnd.cpp
void SceneEnd::render()
{
    if (isTyping){
        renderPhase1(); // 渲染名字输入界面
    }else{
        renderPhase2(); // 渲染排行榜界面
    }
}
```

这里，我们将渲染逻辑分为两个阶段：
- `renderPhase1`：显示名字输入界面（之前已经实现）
- `renderPhase2`：显示排行榜界面（我们将在下面实现）

## 4. 从名字输入转换到排行榜显示

当玩家输入名字后按回车键，我们需要将状态从名字输入转换到排行榜显示。在`handleEvent`方法中，我们修改回车键的处理：

```cpp
// SceneEnd.cpp
void SceneEnd::handleEvent(SDL_Event *event)
{
    if (isTyping){
        if (event->type == SDL_TEXTINPUT){
            name += event->text.text;
        }
        if (event->type == SDL_KEYDOWN){
            if (event->key.keysym.scancode == SDL_SCANCODE_RETURN){
                isTyping = false; // 切换状态
                SDL_StopTextInput();
                if (name == ""){
                    name = "无名氏"; // 如果玩家没有输入名字，使用默认名字
                }
                game.insertLeaderBoard(game.getFinalScore(), name); // 将玩家分数插入排行榜
            }
            if (event->key.keysym.scancode == SDL_SCANCODE_BACKSPACE){
                removeLastUTF8Char(name);
            }
        }
    }
    else{
        if (event->type == SDL_KEYDOWN){
            if (event->key.keysym.scancode == SDL_SCANCODE_J){
                auto sceneMain = new SceneMain(); // 创建新的主游戏场景
                game.changeScene(sceneMain); // 切换回主游戏场景
            }
        }
    }
}
```

在玩家按下回车键后，我们：
1. 将`isTyping`设置为`false`，切换到排行榜显示状态
2. 停止文本输入
3. 如果玩家没有输入名字，使用默认名字"无名氏"
4. 将玩家的分数和名字插入排行榜

此外，在排行榜显示状态下，我们还处理了J键，当玩家按J键时，我们会切换回主游戏场景，允许玩家再次游戏。

## 5. 实现排行榜显示界面

最后，我们需要实现`renderPhase2`方法，显示排行榜：

```cpp
// SceneEnd.cpp
void SceneEnd::renderPhase2()
{
    game.renderTextCentered("得分榜", 0.05, true);
    auto posY = 0.2 * game.getWindowHeight();
    auto i = 1;
    for (auto item : game.getLeaderBoard()){
        std::string name = std::to_string(i) + ". " + item.second;
        std::string score = std::to_string(item.first);
        game.renderTextPos(name, 100, posY);
        game.renderTextPos(score, 100, posY, false);
        posY += 45;
        i++;
    }
    if (blinkTimer < 0.5){
        game.renderTextCentered("按 J 键重新开始游戏", 0.85, false);
    }
}
```

这段代码完成以下任务：
1. 显示"得分榜"标题
2. 初始化垂直位置和计数器
3. 遍历排行榜中的所有条目，对于每个条目：
   - 构造要显示的名字字符串（位置编号 + 玩家名字）
   - 构造要显示的分数字符串
   - 在左侧显示名字
   - 在右侧显示分数
   - 更新垂直位置和计数器
4. 显示一个闪烁的提示，告诉玩家按J键可以重新开始游戏

为了支持在屏幕右侧显示分数，我们对`Game::renderTextPos`方法进行了扩展，添加了一个`isLeft`参数：

```cpp
// Game.cpp
void Game::renderTextPos(std::string text, int posX, int posY, bool isLeft)
{
    SDL_Color color = {255, 255, 255, 255};
    SDL_Surface *surface = TTF_RenderUTF8_Solid(textFont, text.c_str(), color);
    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, surface);
    SDL_Rect rect;
    if (isLeft){
        rect = {posX, posY, surface->w, surface->h};
    }else{
        rect = {getWindowWidth() - posX - surface->w, posY, surface->w, surface->h};
    }
    SDL_RenderCopy(renderer, texture, NULL, &rect);
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(surface);
}
```

当`isLeft`为`true`时，文本从左边距`posX`开始显示；当`isLeft`为`false`时，文本从右边距`posX`开始显示（文本右对齐）。

## 完成效果

实现以上代码后，我们的游戏将有一个完整的结束场景，包括名字输入和排行榜显示：

<img src="https://theorhythm.top/gamedev/SS/28 结束场景-得分榜截图.png" style='width: 800px;' />

1. 当玩家游戏结束时，显示输入名字的界面
2. 当玩家输入名字并按回车键后，显示排行榜界面
3. 在排行榜界面，玩家可以看到所有历史最高分
4. 玩家可以按J键重新开始游戏

## 总结

在本课中，我们实现了游戏的得分榜功能，使玩家能够看到自己的游戏表现与其他玩家相比如何。我们学习了：

1. 如何使用`std::multimap`存储排序的得分数据
2. 如何在游戏类中管理排行榜数据
3. 如何实现从名字输入到排行榜显示的转换
4. 如何渲染排行榜界面
5. 如何实现左对齐和右对齐的文本渲染

这些功能大大增强了游戏的重玩价值和竞争性，使玩家更有动力提高自己的得分。

## 练习

1. 扩展排行榜，添加游戏日期和游戏时间信息。

2. 实现排行榜数据的持久化存储，使玩家的得分在游戏重启后仍然保留。

3. 为排行榜添加筛选和排序功能，允许玩家按不同的标准（如日期、分数、名字）查看排行榜。
