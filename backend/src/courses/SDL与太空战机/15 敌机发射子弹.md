# 敌机发射子弹

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/OqTlRHJRAS8?si=y1lMLmeyRrYqVj5C" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1XK6UYeEkL&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了随机生成敌机的功能，让敌机从屏幕顶部随机位置出现并向下移动。然而，目前的敌机只是简单地向下飞行，没有任何攻击行为，这对玩家来说并不构成真正的威胁。在这一课中，我们将为敌机添加发射子弹的能力，让游戏更具挑战性。

<img src="https://theorhythm.top/gamedev/SS/15 敌机发射子弹.PNG" style='width: 800px;' />

## 设计敌机子弹系统

与玩家子弹不同，敌机子弹需要实现以下特性：

1. **朝向玩家发射**：敌机子弹应该朝着玩家当前位置的方向发射，而不是简单地向下移动。
2. **旋转渲染**：由于子弹朝向不固定，我们需要根据飞行方向旋转子弹的纹理。
3. **定时发射**：敌机应该定期发射子弹，而不是连续不断地发射。

接下来，我们将一步一步地实现这些功能。

## 1. 定义敌机子弹数据结构

首先，我们在`Object.h`中定义一个新的结构体`ProjectileEnemy`，表示敌机子弹：

```cpp
// Object.h
struct ProjectileEnemy{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    SDL_FPoint direction = {0, 0};  // 子弹方向向量
    int width = 0;
    int height = 0;
    int speed = 400;
};
```

与玩家子弹的结构相比，敌机子弹多了一个`direction`成员，用于存储子弹的飞行方向。这是一个归一化的二维向量，表示子弹移动的方向。

同时，我们也需要为`Enemy`结构添加发射子弹相关的属性：

```cpp
struct Enemy{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 200;
    Uint32 coolDown = 1000;     // 发射冷却时间（1秒）
    Uint32 lastShootTime = 0;   // 上次发射时间
};
```

我们添加了两个新成员：
- `coolDown`：表示子弹发射的冷却时间，设为1000毫秒（1秒）。
- `lastShootTime`：记录上次发射子弹的时间戳。

## 2. 更新SceneMain类

接下来，我们需要更新`SceneMain`类，添加敌机子弹相关的成员和方法：

```cpp
// SceneMain.h
class SceneMain : public Scene {
public:
    // ...现有方法...

    void renderEnemyProjectiles();             // 渲染敌机子弹
    void updateEnemyProjectiles(float deltaTime); // 更新敌机子弹
    void shootEnemy(Enemy* enemy);              // 敌机发射子弹
    SDL_FPoint getDirection(Enemy* enemy);      // 计算子弹方向

private:
    // ...现有成员...
    
    ProjectileEnemy projectileEnemyTemplate;    // 敌机子弹模板
    std::list<ProjectileEnemy*> projectilesEnemy; // 敌机子弹容器
};
```

我们添加了以下新成员和方法：
- `projectileEnemyTemplate`：敌机子弹模板，用于创建新子弹。
- `projectilesEnemy`：存储当前屏幕上所有敌机子弹的列表。
- `renderEnemyProjectiles()`：渲染敌机子弹的方法。
- `updateEnemyProjectiles()`：更新敌机子弹位置的方法。
- `shootEnemy()`：让敌机发射子弹的方法。
- `getDirection()`：计算子弹飞向玩家的方向向量。

## 3. 初始化敌机子弹模板

在`SceneMain::init()`方法中，我们需要初始化敌机子弹模板：

```cpp
void SceneMain::init()
{
    // 初始化随机数生成器和玩家、敌机模板（与之前相同）
    // ...

    // 初始化敌机子弹模板
    projectileEnemyTemplate.texture = IMG_LoadTexture(game.getRenderer(), "assets/image/bullet-1.png");
    SDL_QueryTexture(projectileEnemyTemplate.texture, NULL, NULL, &projectileEnemyTemplate.width, &projectileEnemyTemplate.height);
    projectileEnemyTemplate.width /= 4;
    projectileEnemyTemplate.height /= 4;
}
```

这里我们加载了敌机子弹的纹理，并设置了初始尺寸，与之前处理玩家子弹的方式类似。

## 4. 清理敌机子弹资源

在`SceneMain::clean()`方法中，我们需要添加清理敌机子弹资源的代码：

```cpp
void SceneMain::clean()
{
    // 清理玩家子弹和敌机（与之前相同）
    // ...

    // 清理敌机子弹
    for (auto &projectile : projectilesEnemy){
        if (projectile != nullptr){
            delete projectile;
        }
    }
    projectilesEnemy.clear();

    // 清理纹理（与之前相同）
    // ...
    
    if (projectileEnemyTemplate.texture != nullptr){
        SDL_DestroyTexture(projectileEnemyTemplate.texture);
    }
}
```

这段代码确保所有动态分配的敌机子弹对象都被正确删除，并清理了敌机子弹模板的纹理资源，防止内存泄漏。

## 5. 实现敌机发射子弹

现在我们需要实现敌机的射击功能。这需要在更新敌机时检查是否可以发射子弹：

```cpp
void SceneMain::updateEnemies(float deltaTime)
{
    auto currentTime = SDL_GetTicks();
    for (auto it = enemies.begin(); it != enemies.end();){
        auto enemy = *it;
        enemy->position.y += enemy->speed * deltaTime;
        if (enemy->position.y > game.getWindowHeight()){
            delete enemy;
            it = enemies.erase(it);
        }else {
            // 检查冷却时间，决定是否发射子弹
            if (currentTime - enemy->lastShootTime > enemy->coolDown){
                shootEnemy(enemy);
                enemy->lastShootTime = currentTime;
            }
            ++it;
        }
    }
}
```

这段代码在每次更新敌机位置时，会检查是否已经过了发射冷却时间。如果是，就调用`shootEnemy()`方法让敌机发射一颗子弹，并更新上次发射时间。

敌机发射子弹的具体实现如下：

```cpp
void SceneMain::shootEnemy(Enemy *enemy)
{
    // 创建新子弹
    auto projectile = new ProjectileEnemy(projectileEnemyTemplate);
    
    // 设置子弹初始位置（从敌机中央发射）
    projectile->position.x = enemy->position.x + enemy->width / 2 - projectile->width / 2;
    projectile->position.y = enemy->position.y + enemy->height / 2 - projectile->height / 2;
    
    // 计算子弹飞向玩家的方向
    projectile->direction = getDirection(enemy);
    
    // 添加到敌机子弹列表
    projectilesEnemy.push_back(projectile);
}
```

这个方法创建一个新的敌机子弹，将其位置设置在敌机的中心，计算指向玩家的方向，然后将子弹添加到容器中。

## 6. 计算子弹飞向玩家的方向

为了让敌机子弹朝向玩家发射，我们需要计算从敌机到玩家的单位向量：

```cpp
SDL_FPoint SceneMain::getDirection(Enemy *enemy)
{
    // 计算从敌机中心到玩家中心的向量
    auto x = (player.position.x + player.width / 2) - (enemy->position.x + enemy->width / 2);
    auto y = (player.position.y + player.height / 2) - (enemy->position.y + enemy->height / 2);
    
    // 计算向量长度
    auto length = sqrt(x * x + y * y);
    
    // 归一化向量
    x /= length;
    y /= length;
    
    return SDL_FPoint{x, y};
}
```

这个方法首先计算从敌机中心到玩家中心的向量，然后将其归一化（使其长度为1），最后返回这个单位向量作为子弹的飞行方向。

## 7. 更新敌机子弹位置

在每一帧，我们需要根据子弹的方向和速度更新所有敌机子弹的位置，并移除已经飞出屏幕的子弹：

```cpp
void SceneMain::updateEnemyProjectiles(float deltaTime)
{
    auto margin = 32; // 屏幕边缘额外余量
    for (auto it = projectilesEnemy.begin(); it != projectilesEnemy.end();){
        auto projectile = *it;
        
        // 根据方向向量更新子弹位置
        projectile->position.x += projectile->speed * projectile->direction.x * deltaTime;
        projectile->position.y += projectile->speed * projectile->direction.y * deltaTime;
        
        // 检查子弹是否飞出屏幕边界
        if (projectile->position.y > game.getWindowHeight() + margin ||
            projectile->position.y < - margin ||
            projectile->position.x < - margin ||
            projectile->position.x > game.getWindowWidth() + margin){
            delete projectile;
            it = projectilesEnemy.erase(it);
        }else {
            ++it;
        }
    }
}
```

这段代码遍历所有敌机子弹，根据子弹的方向向量和速度更新其位置。与玩家子弹不同，敌机子弹可以向任意方向飞行，因此我们需要检查四个边界来判断子弹是否飞出屏幕。

## 8. 渲染敌机子弹

最后，我们需要渲染所有敌机子弹，并根据飞行方向旋转子弹纹理：

```cpp
void SceneMain::renderEnemyProjectiles()
{
    for (auto projectile : projectilesEnemy){
        SDL_Rect projectileRect = {
            static_cast<int>(projectile->position.x),
            static_cast<int>(projectile->position.y),
            projectile->width,
            projectile->height
        };
        
        // 计算子弹旋转角度（从弧度转换为角度，并调整为正确的方向）
        float angle = atan2(projectile->direction.y, projectile->direction.x) * 180 / M_PI - 90;
        
        // 使用带旋转参数的渲染函数
        SDL_RenderCopyEx(game.getRenderer(), projectile->texture, NULL, &projectileRect, angle, NULL, SDL_FLIP_NONE);
    }
}
```

这里我们使用`SDL_RenderCopyEx`函数而不是`SDL_RenderCopy`，因为前者允许我们指定旋转角度。角度计算公式是：
- `atan2(y, x)`：计算向量的弧度角（范围是-π到π）
- `* 180 / M_PI`：将弧度转换为角度
- `- 90`：调整角度使子弹图片正确朝向前进方向（这取决于你的子弹纹理的初始方向）

## 9. 更新主循环

最后，我们需要在`update()`和`render()`方法中调用敌机子弹相关的方法：

```cpp
void SceneMain::update(float deltaTime)
{
    keyboardControl(deltaTime);
    updatePlayerProjectiles(deltaTime);
    updateEnemyProjectiles(deltaTime);  // 更新敌机子弹
    spawEnemy();
    updateEnemies(deltaTime);
}

void SceneMain::render()
{
    // 渲染玩家子弹
    renderPlayerProjectiles();
    // 渲染敌机子弹
    renderEnemyProjectiles();
    
    // 渲染玩家
    SDL_Rect playerRect = { static_cast<int>(player.position.x), 
                          static_cast<int>(player.position.y), 
                          player.width, 
                          player.height };
    SDL_RenderCopy(game.getRenderer(), player.texture, NULL, &playerRect);
    
    // 渲染敌机
    renderEnemies();
}
```

注意渲染顺序：我们先渲染玩家子弹和敌机子弹，再渲染玩家和敌机。这样子弹会显示在飞机的下层，符合游戏的视觉逻辑。

## 游戏效果

实现了上述代码后，敌机会定期朝着玩家的位置发射子弹，增加了游戏的难度和挑战性。玩家不仅需要躲避敌机，还需要躲避敌机发射的子弹。

<img src="https://theorhythm.top/gamedev/SS/15 敌机发射子弹截图.png" style='width: 800px;' />


## 总结

在本课中，我们为敌机添加了发射子弹的能力，大大增加了游戏的挑战性。我们学习了：

1. 如何设计具有方向属性的敌机子弹数据结构。
2. 如何计算从敌机指向玩家的方向向量。
3. 如何根据方向更新子弹位置。
4. 如何旋转渲染子弹，使其朝向与飞行方向一致。
5. 如何管理敌机的射击冷却时间。

这些技术不仅适用于此游戏，也是许多射击游戏中的基本元素。在下一课中，我们将实现碰撞检测，让子弹能够击中敌机和玩家，使游戏成为一个完整的射击体验。

## 练习

1. 修改代码，让不同敌机具有不同的射击冷却时间和子弹速度。

2. 实现敌机的散射能力，即一次发射多颗朝不同方向的子弹。

4. 实现子弹发射的声音效果。

5. 添加一种新的敌机类型，能够发射更快或更大的子弹。
