# 玩家子弹与射击控制

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/yaKYB9jF4aE?si=XFKTLX65zEaz8ao_" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1Rb66Y2E3x&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了基于时间的移动系统，使玩家飞机的移动速度不受帧率影响。现在，我们将为游戏添加射击功能，让玩家可以发射子弹攻击敌人。这是太空射击游戏的核心玩法之一。

<img src="https://theorhythm.top/gamedev/SS/13 玩家子弹与射击控制.PNG" style='width: 800px;' />

## 设计子弹系统

为了实现子弹功能，我们需要考虑以下几个方面：

1. **子弹的数据结构**：用于存储子弹的位置、速度、纹理等属性。
2. **子弹的生成**：当玩家按下射击键时创建新子弹。
3. **子弹的更新**：移动子弹并检查是否超出屏幕。
4. **子弹的渲染**：在屏幕上显示子弹。
5. **子弹的冷却时间**：限制玩家射击的频率。

接下来，我们将逐步实现这些功能。

## 1. 定义子弹数据结构

首先，我们在`Object.h`中定义一个新的结构体`ProjectilePlayer`，表示玩家的子弹，同时在`Player`结构中添加射击冷却相关的属性：

```cpp
// Object.h
struct Player{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 200;
    Uint32 coolDown = 500;        // 射击冷却时间（毫秒）
    Uint32 lastShootTime = 0;     // 上次射击的时间
};

struct ProjectilePlayer{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 400;              // 子弹移动速度
};
```

这里我们为`Player`添加了两个新的属性：
- `coolDown`：射击间隔，设为500毫秒（即每秒最多射击2次）
- `lastShootTime`：记录上次射击的时间戳

同时定义了`ProjectilePlayer`结构体，包含子弹的纹理、位置、尺寸和速度信息。子弹速度设置为400像素/秒，比飞机的移动速度(200像素/秒)快，这样玩家可以看到子弹向前飞行。

## 2. 更新SceneMain类

接下来，我们需要更新`SceneMain`类，添加子弹相关的成员和方法：

```cpp
// SceneMain.h
#include <list>

class SceneMain : public Scene {
public:
    // ...现有方法...

    void keyboardControl(float deltaTime);
    void shootPlayer();                          // 发射子弹
    void updatePlayerProjectiles(float deltaTime); // 更新子弹
    void renderPlayerProjectiles();              // 渲染子弹

private:
    Game &game;
    Player player;
    // 创建子弹模板
    ProjectilePlayer projectilePlayerTemplate;

    // 存储活动子弹的列表
    std::list<ProjectilePlayer*> projectilesPlayer;  
};
```

我们添加了以下新成员和方法：
- `projectilePlayerTemplate`：子弹模板，用于创建新子弹
- `projectilesPlayer`：存储当前屏幕上所有活动子弹的列表
- `shootPlayer()`：创建新子弹
- `updatePlayerProjectiles()`：更新所有子弹的位置和状态
- `renderPlayerProjectiles()`：渲染所有子弹

我们使用`std::list`来存储子弹，因为它支持高效的插入和删除操作，这对于频繁创建和销毁子弹的情况非常适合。

## 3. 初始化子弹模板

在`SceneMain::init()`方法中，我们需要初始化子弹模板：

```cpp
void SceneMain::init()
{
    // 初始化玩家飞机（与之前相同）
    player.texture = IMG_LoadTexture(game.getRenderer(), "assets/image/SpaceShip.png");
    if (player.texture == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_ERROR, "Failed to load player texture: %s", SDL_GetError());
    }
    SDL_QueryTexture(player.texture, NULL, NULL, &player.width, &player.height);
    player.width /= 4;
    player.height /= 4;
    player.position.x = game.getWindowWidth() / 2 - player.width / 2;
    player.position.y = game.getWindowHeight() - player.height;

    // 初始化子弹模板
    projectilePlayerTemplate.texture = IMG_LoadTexture(game.getRenderer(), "assets/image/laser-1.png");
    SDL_QueryTexture(projectilePlayerTemplate.texture, NULL, NULL, &projectilePlayerTemplate.width, &projectilePlayerTemplate.height);
    projectilePlayerTemplate.width /= 4;
    projectilePlayerTemplate.height /= 4;
}
```

这段代码加载了子弹的纹理并设置了初始尺寸。我们将纹理尺寸除以4，使子弹看起来不会太大，与飞机比例协调。

## 4. 清理资源

在`SceneMain::clean()`方法中，我们需要清理所有子弹资源：

```cpp
void SceneMain::clean()
{
    // 清理子弹
    for (auto &projectile : projectilesPlayer){
        if (projectile != nullptr){
            delete projectile;
        }
    }
    projectilesPlayer.clear();
    
    // 清理纹理
    if (player.texture != nullptr)
    {
        SDL_DestroyTexture(player.texture);
    }
    if (projectilePlayerTemplate.texture != nullptr)
    {
        SDL_DestroyTexture(projectilePlayerTemplate.texture);
    }
}
```

这段代码确保所有动态分配的子弹都被正确删除，并清理了子弹模板的纹理资源。

## 5. 实现射击功能

在`keyboardControl()`方法中，我们添加射击控制代码：

```cpp
void SceneMain::keyboardControl(float deltaTime)
{
    // 飞机移动代码保持不变...

    // 控制子弹发射
    if (keyboardState[SDL_SCANCODE_J]){
        auto currentTime = SDL_GetTicks();
        if (currentTime - player.lastShootTime > player.coolDown){
            shootPlayer();
            player.lastShootTime = currentTime;
        }
    }
}
```

当玩家按下J键时，我们会检查是否已经过了冷却时间。如果是，则调用`shootPlayer()`方法发射子弹，并更新`lastShootTime`。

## 6. 创建子弹

`shootPlayer()`方法负责创建新的子弹：

```cpp
void SceneMain::shootPlayer()
{
    // 创建新子弹
    auto projectile = new ProjectilePlayer(projectilePlayerTemplate);
    // 定位在飞机顶部中央
    projectile->position.x = player.position.x + player.width / 2 - projectile->width / 2;
    projectile->position.y = player.position.y;
    // 添加到活动子弹列表
    projectilesPlayer.push_back(projectile);
}
```

这段代码创建了一个新的子弹对象，将其定位在飞机的顶部中央，然后添加到活动子弹列表中。

## 7. 更新子弹

在每一帧，我们需要更新所有子弹的位置，并移除超出屏幕的子弹：

```cpp
void SceneMain::updatePlayerProjectiles(float deltaTime)
{
    int margin = 32; // 子弹超出屏幕外边界的距离
    for (auto it = projectilesPlayer.begin(); it != projectilesPlayer.end();){
        auto projectile = *it;
        // 更新子弹位置
        projectile->position.y -= projectile->speed * deltaTime;
        // 检查子弹是否超出屏幕
        if (projectile->position.y + margin < 0){
            delete projectile;
            it = projectilesPlayer.erase(it);
        }else {
            ++it;
        }
    }
}
```

这段代码遍历所有子弹，根据子弹速度和`deltaTime`更新子弹位置。如果子弹完全超出屏幕上方（包括一个额外的余量），我们会将其删除并从列表中移除。

注意这里的迭代器使用：在删除元素后，我们使用`erase()`方法的返回值作为新的迭代器位置，避免访问已删除的元素。

## 8. 渲染子弹

最后，我们需要渲染所有活动的子弹：

```cpp
void SceneMain::renderPlayerProjectiles()
{
    for (auto projectile : projectilesPlayer){
        SDL_Rect projectileRect = {
            static_cast<int>(projectile->position.x),
            static_cast<int>(projectile->position.y),
            projectile->width,
            projectile->height
        };
        SDL_RenderCopy(game.getRenderer(), projectile->texture, NULL, &projectileRect);
    }
}
```

这段代码遍历所有子弹，创建对应的矩形，并使用`SDL_RenderCopy`将子弹纹理渲染到屏幕上。

## 9. 更新主循环

最后，我们需要在`update()`和`render()`方法中调用子弹相关的方法：

```cpp
void SceneMain::update(float deltaTime)
{
    keyboardControl(deltaTime);
    updatePlayerProjectiles(deltaTime);
}

void SceneMain::render()
{
    // 渲染子弹
    renderPlayerProjectiles();
    // 渲染玩家
    SDL_Rect playerRect = { static_cast<int>(player.position.x), 
                          static_cast<int>(player.position.y), 
                          player.width, 
                          player.height };
    SDL_RenderCopy(game.getRenderer(), player.texture, NULL, &playerRect);
}
```

注意渲染顺序：我们先渲染子弹，再渲染玩家，这样玩家飞机会显示在子弹上方，看起来更自然。

## 游戏效果

实现了上述代码后，我们可以使用WASD移动飞机，按J键发射子弹。子弹会从飞机顶部发射，向上飞行，最终超出屏幕边界被删除。

<img src="https://theorhythm.top/gamedev/SS/13 玩家子弹与射击控制截图.png" style='width: 800px;' />


## 总结

在本课中，我们实现了玩家子弹和射击控制功能，为游戏添加了基本的射击玩法。我们学习了：

1. 如何设计和实现子弹数据结构
2. 如何管理多个游戏对象（子弹）
3. 如何实现射击冷却机制
4. 如何清理不再需要的游戏对象

这些都是射击游戏中的基本元素，为后续添加敌人和碰撞检测奠定了基础。在下一课中，我们将实现敌人的生成和移动，为游戏增加挑战性。

## 练习

1. 修改代码，使玩家可以发射多颗子弹（例如，两颗并排的子弹）。

2. 实现子弹冷却时间的可视化显示，例如在屏幕上显示一个冷却进度条。

3. 添加不同类型的子弹，可以通过不同的按键触发，具有不同的速度和外观。

5. 修改代码，使子弹发射位置更自然（例如，从飞机的枪口位置发射，而不是中心点）。
