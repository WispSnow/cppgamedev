# 碰撞检测与击杀

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/s2gtqmo-oIE?si=DtTEDoiKafGOC-eG" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1T1rWYREkg&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了敌机发射子弹的功能，使敌机能够向玩家发起攻击。然而，目前的游戏中，子弹和飞机之间并没有实际的相互作用——子弹无法击中飞机，飞机之间也不会发生碰撞。在这一课中，我们将实现碰撞检测机制，让子弹能够击中敌机和玩家，同时也让敌机与玩家之间能够相撞，从而使游戏更加真实和具有挑战性。

<img src="https://theorhythm.top/gamedev/SS/16 碰撞检测与击杀.PNG" style='width: 800px;' />

## 碰撞检测的基本原理

在2D游戏中，碰撞检测通常采用以下几种方法：

1. **矩形碰撞检测**：将游戏对象视为矩形，检查两个矩形是否重叠。这是最简单和最常用的方法。
2. **圆形碰撞检测**：将游戏对象视为圆形，检查两个圆是否重叠。这适用于圆形或近似圆形的对象。
3. **多边形碰撞检测**：使用多边形表示游戏对象的形状，检查多边形是否相交。这是最精确但计算成本最高的方法。
4. **像素级碰撞检测**：检查两个对象的非透明像素是否重叠。这是最精确的方法，但计算成本极高。

在我们的射击游戏中，由于大多数游戏对象（飞机和子弹）都是近似矩形的，我们将使用矩形碰撞检测方法。SDL提供了`SDL_HasIntersection`函数，可以方便地检测两个`SDL_Rect`矩形是否相交。

## 1. 扩展游戏对象数据结构

首先，我们需要为游戏对象添加健康值和伤害值属性：

```cpp
// Object.h
struct Player{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 300;
    int currentHealth = 3;      // 玩家初始生命值为3
    Uint32 coolDown = 300;
    Uint32 lastShootTime = 0;
};

struct Enemy{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 150;
    int currentHealth = 2;      // 敌机初始生命值为2
    Uint32 coolDown = 2000;
    Uint32 lastShootTime = 0;
};

struct ProjectilePlayer{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 600;
    int damage = 1;             // 玩家子弹伤害值为1
};

struct ProjectileEnemy{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    SDL_FPoint direction = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 400;
    int damage = 1;             // 敌机子弹伤害值为1
};
```

我们为`Player`和`Enemy`添加了`currentHealth`属性，表示当前生命值。同时，为`ProjectilePlayer`和`ProjectileEnemy`添加了`damage`属性，表示子弹的伤害值。

## 2. 更新SceneMain类

接下来，我们需要更新`SceneMain`类，添加玩家死亡状态和爆炸效果：

```cpp
// SceneMain.h
class SceneMain : public Scene {
public:
    // ...现有方法...
    void updatePlayer(float deltaTime);   // 更新玩家状态
    void enemyExplode(Enemy* enemy);      // 敌机爆炸效果

private:
    // ...现有成员...
    bool isDead = false;                 // 玩家是否死亡
};
```

我们添加了以下新成员和方法：
- `isDead`：标记玩家是否已经死亡，用于控制游戏状态。
- `updatePlayer()`：检查玩家状态，包括生命值和碰撞情况。
- `enemyExplode()`：处理敌机被击毁时的效果。

## 3. 实现玩家子弹与敌机的碰撞检测

在`updatePlayerProjectiles()`方法中，我们需要检测玩家子弹是否击中敌机：

```cpp
void SceneMain::updatePlayerProjectiles(float deltaTime)
{
    int margin = 32; // 子弹超出屏幕外边界的距离
    for (auto it = projectilesPlayer.begin(); it != projectilesPlayer.end();){
        auto projectile = *it;
        projectile->position.y -= projectile->speed * deltaTime;
        // 检查子弹是否超出屏幕
        if (projectile->position.y + margin < 0){
            delete projectile;
            it = projectilesPlayer.erase(it);
        }else {
            bool hit = false;
            for (auto enemy : enemies){
                SDL_Rect enemyRect = {
                    static_cast<int>(enemy->position.x),
                    static_cast<int>(enemy->position.y),
                    enemy->width,
                    enemy->height
                };
                SDL_Rect projectileRect = {
                    static_cast<int>(projectile->position.x),
                    static_cast<int>(projectile->position.y),
                    projectile->width,
                    projectile->height
                };
                if (SDL_HasIntersection(&enemyRect, &projectileRect)){
                    enemy->currentHealth -= projectile->damage;
                    delete projectile;
                    it = projectilesPlayer.erase(it);
                    hit = true;
                    break;
                }
            }
            if (!hit){
                ++it;
            }
        }
    }
}
```

这段代码在更新玩家子弹位置时，检查每颗子弹是否与任何敌机相交。如果相交，则减少敌机的生命值，删除子弹，并标记为击中（`hit = true`）。

## 4. 更新敌机状态，处理击毁

在`updateEnemies()`方法中，我们需要检查敌机的生命值，如果生命值降至0或以下，触发爆炸效果并移除敌机：

```cpp
void SceneMain::updateEnemies(float deltaTime)
{
    auto currentTime = SDL_GetTicks();
    for (auto it = enemies.begin(); it != enemies.end();){
        auto enemy = *it;
        enemy->position.y += enemy->speed * deltaTime;
        if (enemy->position.y > game.getWindowHeight()){
            delete enemy;
            it = enemies.erase(it);
        }else {
            if (currentTime - enemy->lastShootTime > enemy->coolDown && isDead == false){
                shootEnemy(enemy);
                enemy->lastShootTime = currentTime;
            }
            if (enemy->currentHealth <= 0){
                enemyExplode(enemy);
                it = enemies.erase(it);
            } else {
                ++it;
            }
        }
    }
}
```

我们添加了对敌机生命值的检查。如果敌机的`currentHealth`小于等于0，则调用`enemyExplode()`方法处理爆炸效果，并从敌机列表中移除该敌机。

敌机爆炸效果的实现：

```cpp
void SceneMain::enemyExplode(Enemy *enemy)
{
    delete enemy;
}
```

在当前版本中，爆炸效果只是简单地删除敌机对象。在后续课程中，我们将添加爆炸动画和音效，使爆炸效果更加生动。

## 5. 实现敌机子弹与玩家的碰撞检测

在`updateEnemyProjectiles()`方法中，我们需要检测敌机子弹是否击中玩家：

```cpp
void SceneMain::updateEnemyProjectiles(float deltaTime)
{
    auto margin = 32;
    for (auto it = projectilesEnemy.begin(); it != projectilesEnemy.end();){
        auto projectile = *it;
        projectile->position.x += projectile->speed * projectile ->direction.x * deltaTime;
        projectile->position.y += projectile->speed * projectile->direction.y * deltaTime;
        if (projectile->position.y > game.getWindowHeight() + margin ||
            projectile->position.y < - margin ||
            projectile->position.x < - margin ||
            projectile->position.x > game.getWindowWidth() + margin){
            delete projectile;
            it = projectilesEnemy.erase(it);
        }else {
            SDL_Rect projectileRect = {
                static_cast<int>(projectile->position.x),
                static_cast<int>(projectile->position.y),
                projectile->width,
                projectile->height
            };
            SDL_Rect playerRect = {
                static_cast<int>(player.position.x),
                static_cast<int>(player.position.y),
                player.width,
                player.height
            };
            if (SDL_HasIntersection(&projectileRect, &playerRect) && !isDead){
                player.currentHealth -= projectile->damage;
                delete projectile;
                it = projectilesEnemy.erase(it);
            } else {
                ++it;
            }
        }
    }
}
```

这段代码在更新敌机子弹位置时，检查每颗子弹是否与玩家相交。如果相交且玩家未死亡，则减少玩家的生命值，并删除子弹。

## 6. 实现玩家与敌机的碰撞检测

我们还需要检测玩家飞机与敌机之间的碰撞，这通常会导致玩家受伤：

```cpp
void SceneMain::updatePlayer(float deltaTime)
{
    if (isDead) {
        return;
    }
    if (player.currentHealth <= 0){
        // 玩家死亡处理
        isDead = true;
    }
    for (auto enemy : enemies){
        SDL_Rect enemyRect = {
            static_cast<int>(enemy->position.x),
            static_cast<int>(enemy->position.y),
            enemy->width,
            enemy->height
        };
        SDL_Rect playerRect = {
            static_cast<int>(player.position.x),
            static_cast<int>(player.position.y),
            player.width,
            player.height
        };
        if (SDL_HasIntersection(&playerRect, &enemyRect)){
            player.currentHealth -= 1;
            enemy->currentHealth = 0;
        }
    }
}
```

这个方法首先检查玩家是否已经死亡。如果玩家的生命值小于等于0，则将`isDead`设置为`true`。然后，检查玩家是否与任何敌机碰撞。如果碰撞，则减少玩家的生命值，并将敌机的生命值设为0（相当于敌机被摧毁）。

## 7. 更新游戏主循环

最后，我们需要在主循环中调用`updatePlayer()`方法，并在渲染时考虑玩家死亡状态：

```cpp
void SceneMain::update(float deltaTime)
{
    keyboardControl(deltaTime);
    updatePlayerProjectiles(deltaTime);
    updateEnemyProjectiles(deltaTime);
    spawEnemy();
    updateEnemies(deltaTime);
    updatePlayer(deltaTime);  // 添加更新玩家状态
}

void SceneMain::render()
{
    // 渲染玩家子弹
    renderPlayerProjectiles();
    //渲染敌机子弹
    renderEnemyProjectiles();
    // 渲染玩家（只在玩家未死亡时渲染）
    if (!isDead){
        SDL_Rect playerRect = { static_cast<int>(player.position.x), 
                       static_cast<int>(player.position.y), 
                       player.width, 
                       player.height};
        SDL_RenderCopy(game.getRenderer(), player.texture, NULL, &playerRect);
    }
    // 渲染敌人
    renderEnemies();
}
```

在`update()`方法的最后，我们添加了对`updatePlayer()`的调用，以检查玩家状态。在`render()`方法中，我们只在玩家未死亡时渲染玩家飞机。

## 游戏效果

实现上述代码后，游戏将具有以下功能：

1. 玩家子弹可以击中敌机，并减少敌机生命值。
2. 敌机子弹可以击中玩家，并减少玩家生命值。
3. 玩家飞机与敌机碰撞会同时伤害玩家和敌机。
4. 玩家生命值降至0时，玩家死亡，飞机消失。
5. 敌机生命值降至0时，敌机被摧毁。

这些功能使游戏更加真实和具有挑战性，玩家需要躲避敌机子弹和敌机本身，同时尝试击毁尽可能多的敌机。

## 总结

在本课中，我们实现了游戏中的碰撞检测和击杀功能，这是任何射击游戏的核心机制。我们学习了如何：

1. 使用SDL的`SDL_HasIntersection`函数检测两个矩形是否相交。
2. 为游戏对象添加生命值和伤害值属性。
3. 实现玩家子弹与敌机的碰撞检测。
4. 实现敌机子弹与玩家的碰撞检测。
5. 实现玩家飞机与敌机的碰撞检测。
6. 处理玩家和敌机的死亡状态。

这些功能使我们的游戏更加完整和具有挑战性。在下一课中，我们将添加爆炸动画效果，使敌机被击毁的过程更加生动。

## 练习

1. 在玩家被击中时添加闪烁效果，提供视觉反馈。

2. 实现不同类型的敌机，具有不同的生命值和移动速度。

3. 实现游戏结束后的重新开始功能。
