# 游戏的基本逻辑

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/nDi5jLh8eYw?si=MHAlgL5urD1YsTsN" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1bu6WYxEBi&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前面的课程中，我们学习了SDL的基础知识，包括如何初始化SDL、显示图形、播放音乐以及渲染文本。现在，我们将深入探讨游戏开发中最核心的概念：游戏循环和场景管理。这些概念是构建任何游戏的基础框架。

## 游戏循环

游戏循环是所有游戏的核心，它定义了游戏如何运行，从启动到结束的整个生命周期。

<img src="https://theorhythm.top/gamedev/SS/7 游戏的基本逻辑.png" style='width: 800px;' />

如上图所示，一个典型的游戏循环包括以下几个阶段：

### 1. 初始化阶段

在游戏开始时，需要执行一系列初始化操作：
- 初始化游戏引擎（如SDL）
- 创建窗口和渲染器
- 加载游戏资源（图像、音频、字体等）
- 初始化游戏数据和状态

初始化阶段只执行一次，为游戏的运行做好准备。

### 2. 主循环

主循环是游戏运行的核心，它会不断循环执行，直到游戏结束。在主循环中，主要包含三个关键步骤：

#### 2.1 事件处理（handleEvent）

事件处理负责接收并响应用户输入和系统事件：
- 键盘输入（按键按下、释放）
- 鼠标操作（点击、移动）
- 系统事件（窗口关闭、失去焦点等）
- 游戏事件（计时器触发、碰撞检测等）

事件处理是玩家与游戏交互的桥梁，决定了游戏的响应性和操作体验。

#### 2.2 逻辑更新（update）

逻辑更新负责根据事件和时间推进游戏状态：
- 更新游戏对象的位置、速度、状态
- 执行AI逻辑
- 处理游戏规则和机制
- 检测碰撞和交互

逻辑更新通常以固定的时间步长进行，以确保游戏在不同性能的设备上有一致的行为。

#### 2.3 渲染绘制（render）

渲染绘制负责将当前游戏状态可视化展示给玩家：
- 清除屏幕
- 绘制背景
- 绘制游戏对象（玩家、敌人、道具等）
- 绘制UI元素（分数、生命值、菜单等）
- 更新屏幕显示

渲染通常会尽可能快地执行，以提供高帧率和流畅的视觉体验。

### 3. 清理阶段

当游戏结束时（玩家退出或游戏自然结束），需要执行清理操作：
- 释放所有分配的资源（内存、纹理、音频等）
- 关闭文件和网络连接
- 保存游戏数据和设置
- 关闭游戏引擎

良好的清理过程可以防止资源泄漏，确保游戏正常关闭。

## 场景管理

随着游戏复杂度的增加，我们通常需要将游戏分解为多个场景（或状态），例如：标题界面、游戏主画面、暂停菜单、结束界面等。场景管理就是在这些场景之间进行切换和管理。

<img src="https://theorhythm.top/gamedev/SS/7 游戏的基本逻辑2.png" style='width: 800px;' />

### 场景的概念

场景可以被视为游戏的不同"页面"或"模式"，每个场景有自己的：
- 视觉表现
- 交互逻辑
- 更新规则
- 资源需求

### 场景切换的实现

如上图所示，虽然不同场景的内容和行为各不相同，但它们都遵循相同的游戏循环结构。实现场景切换的常见方法有：

#### 1. 状态模式

使用一个变量来跟踪当前游戏状态，根据状态调用不同的处理函数：

```
enum GameState {
    TITLE_SCREEN,
    PLAYING,
    PAUSED,
    GAME_OVER
};

GameState currentState = TITLE_SCREEN;

// 在主循环中
switch(currentState) {
    case TITLE_SCREEN:
        handleTitleEvents();
        updateTitleScreen();
        renderTitleScreen();
        break;
    case PLAYING:
        handleGameEvents();
        updateGame();
        renderGame();
        break;
    // 其他状态...
}
```

#### 2. 场景类

更面向对象的方法是创建一个场景基类，然后为每种场景类型创建子类：

```
class Scene {
public:
    virtual void handleEvent() = 0;
    virtual void update() = 0;
    virtual void render() = 0;
};

class TitleScene : public Scene {
    // 实现方法...
};

class GameScene : public Scene {
    // 实现方法...
};

// 当前场景
Scene* currentScene = new TitleScene();

// 在主循环中
currentScene->handleEvent();
currentScene->update();
currentScene->render();

// 切换场景
delete currentScene;
currentScene = new GameScene();
```

### 场景切换的考虑因素

实现场景管理时，需要考虑以下几点：

1. **资源管理**：不同场景可能需要不同的资源。为了优化内存使用，可以在切换场景时加载/卸载资源。

2. **状态保存**：切换场景时可能需要保存当前场景的状态，以便稍后返回时恢复。

3. **过渡效果**：为了提供更好的用户体验，可以添加场景切换的过渡动画（淡入淡出、滑动等）。

4. **场景堆栈**：有时需要实现场景的"叠加"（例如在游戏上显示暂停菜单），可以使用场景堆栈来管理。

## 时间管理

在游戏循环中，时间管理是一个关键问题。游戏需要在不同性能的设备上保持一致的速度。

### 固定时间步长

一种常见的方法是使用固定时间步长更新游戏逻辑：

```
const int MS_PER_UPDATE = 16; // 60 FPS
int lag = 0;

while (running) {
    int currentTime = SDL_GetTicks();
    int elapsed = currentTime - previousTime;
    previousTime = currentTime;
    lag += elapsed;
    
    // 处理事件
    handleEvents();
    
    // 固定时间步长更新
    while (lag >= MS_PER_UPDATE) {
        update();
        lag -= MS_PER_UPDATE;
    }
    
    // 渲染（可以使用lag/MS_PER_UPDATE作为插值因子实现平滑渲染）
    render();
}
```

这种方法确保了游戏逻辑以固定的速率更新，同时允许渲染尽可能流畅。

## 总结

游戏循环和场景管理是游戏开发中的核心概念。理解它们对于构建结构良好、反应灵敏的游戏至关重要。

在下一课中，我们将开始实现这些概念，创建一个基本的游戏框架，它将包含多个场景和一个健壮的游戏循环，为我们的太空射击游戏打下基础。

## 思考与练习

1. 思考不同类型游戏（如回合制RPG、即时战略游戏、物理解谜游戏）的主循环有什么不同？
