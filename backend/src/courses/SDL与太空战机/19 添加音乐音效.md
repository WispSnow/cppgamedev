# 添加音乐音效

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/5VLcLMhPodk?si=PXg_GYDt3HieVDsZ" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1YkrDYrE1c&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了物品掉落与拾取系统，使玩家能够通过击败敌人获得增益物品。但是，目前的游戏体验仍然缺少音频反馈，而音频是提升游戏沉浸感的重要元素。在这一课中，我们将为游戏添加背景音乐和各种音效，使游戏体验更加完整和生动。

<img src="https://theorhythm.top/gamedev/SS/19 添加音乐音效.PNG" style='width: 800px;' />

## 游戏音频概述

音频在游戏中扮演着重要角色，它能够：

1. 提供即时反馈，让玩家知道他们的操作产生了效果
2. 增强游戏的氛围和情感体验
3. 提示游戏状态的变化，如危险或成功
4. 使游戏世界更具生命力和沉浸感

在射击游戏中，常见的音频包括：

- **背景音乐**：设定游戏的整体氛围和节奏
- **武器发射音效**：玩家和敌人射击时的声音
- **爆炸音效**：敌人或玩家被击毁时的声音
- **命中音效**：子弹击中目标时的声音
- **拾取音效**：玩家获得物品时的声音

SDL提供了SDL_mixer库，它是一个强大的音频处理库，支持多种音频格式，并且能够同时播放多个音频通道。我们将使用它来为游戏添加音频功能。

## 1. 初始化SDL_mixer

首先，我们需要在`Game.h`文件中导入SDL_mixer头文件，并在`Game.cpp`中初始化它：

```cpp
// Game.h
#include <SDL_mixer.h>
```

接下来，在`Game.cpp`的`init()`方法中添加SDL_mixer的初始化代码：

```cpp
// Game.cpp
void Game::init()
{
    // ...前面的代码保持不变

    // 初始化SDL_mixer
    if (Mix_Init(MIX_INIT_MP3 | MIX_INIT_OGG) != (MIX_INIT_MP3 | MIX_INIT_OGG)) {
        SDL_LogError(SDL_LOG_CATEGORY_ERROR, "SDL_mixer could not initialize! SDL_mixer Error: %s\n", Mix_GetError());
        isRunning = false;
    }

    // 打开音频设备
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
        SDL_LogError(SDL_LOG_CATEGORY_ERROR, "SDL_mixer could not open audio! SDL_mixer Error: %s\n", Mix_GetError());
        isRunning = false;
    }
    
    // 设置音效channel数量
    Mix_AllocateChannels(32);

    // 设置音乐音量
    Mix_VolumeMusic(MIX_MAX_VOLUME / 4);
    Mix_Volume(-1, MIX_MAX_VOLUME / 8);

    // ...后面的代码保持不变
}
```

这段代码做了几件事情：

1. 初始化SDL_mixer，并指定我们需要支持MP3和OGG格式
2. 打开音频设备，设置音频质量参数（采样率、格式、声道数和缓冲区大小）
3. 分配32个音效通道，使我们能够同时播放多个音效
4. 设置音乐和音效的音量，这里将音乐音量设为最大音量的四分之一，音效音量设为最大音量的八分之一

同时，我们需要在`Game.cpp`的`clean()`方法中添加SDL_mixer的清理代码：

```cpp
// Game.cpp
void Game::clean()
{
    // ...前面的代码保持不变

    // 清理SDL_mixer
    Mix_CloseAudio();
    Mix_Quit();

    // ...后面的代码保持不变
}
```

## 2. 更新SceneMain类

接下来，我们需要更新`SceneMain.h`文件，添加音频相关的成员变量和包含头文件：

```cpp
// SceneMain.h
#include <SDL_mixer.h>
#include <map>

// ...其他代码保持不变

private:
    // ...其他成员保持不变
    Mix_Music* bgm;
    std::map<std::string, Mix_Chunk*> sounds; // 存储音效
```

这里我们添加了两个新成员：
- `bgm`：背景音乐指针，用于存储和控制背景音乐
- `sounds`：音效映射表，用于存储游戏中所有的音效，通过字符串标识符访问

## 3. 加载和播放背景音乐

在`SceneMain.cpp`的`init()`方法中，我们添加加载和播放背景音乐的代码：

```cpp
// SceneMain.cpp
void SceneMain::init()
{
    // 读取并播放背景音乐
    bgm = Mix_LoadMUS("assets/music/03_Racing_Through_Asteroids_Loop.ogg");
    if (bgm == nullptr){
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to load music: %s", Mix_GetError());
    }
    Mix_PlayMusic(bgm, -1);

    // ...其他初始化代码
}
```

这段代码使用`Mix_LoadMUS()`函数加载背景音乐文件，然后使用`Mix_PlayMusic()`函数播放它。第二个参数`-1`表示无限循环播放。

## 4. 加载音效资源

同样在`SceneMain.cpp`的`init()`方法中，我们添加加载各种音效的代码：

```cpp
// SceneMain.cpp
void SceneMain::init()
{
    // 读取并播放背景音乐
    // ...上面的代码保持不变

    // 读取音效资源
    sounds["player_shoot"] = Mix_LoadWAV("assets/sound/laser_shoot4.wav");
    sounds["enemy_shoot"] = Mix_LoadWAV("assets/sound/xs_laser.wav");
    sounds["player_explode"] = Mix_LoadWAV("assets/sound/explosion1.wav");
    sounds["enemy_explode"] = Mix_LoadWAV("assets/sound/explosion3.wav");
    sounds["hit"] = Mix_LoadWAV("assets/sound/eff11.wav");
    sounds["get_item"] = Mix_LoadWAV("assets/sound/eff5.wav");

    // ...其他初始化代码
}
```

这段代码使用`Mix_LoadWAV()`函数加载各种音效文件，并将它们存储在`sounds`映射表中，通过字符串标识符访问。我们加载了以下音效：

- `player_shoot`：玩家射击音效
- `enemy_shoot`：敌人射击音效
- `player_explode`：玩家爆炸音效
- `enemy_explode`：敌人爆炸音效
- `hit`：子弹命中目标的音效
- `get_item`：玩家拾取物品的音效

## 5. 清理音频资源

在`SceneMain.cpp`的`clean()`方法中，我们需要添加清理音频资源的代码：

```cpp
// SceneMain.cpp
void SceneMain::clean()
{
    // 清理容器
    for (auto sound : sounds){
        if (sound.second != nullptr){
            Mix_FreeChunk(sound.second);
        }
    }
    sounds.clear();
    
    // ...其他清理代码

    // 清理音乐资源
    if (bgm != nullptr){
        Mix_HaltMusic();
        Mix_FreeMusic(bgm);
    }
}
```

这段代码首先遍历`sounds`映射表，释放所有音效资源，然后清空映射表。最后，停止背景音乐并释放背景音乐资源。

## 6. 在游戏事件中播放音效

接下来，我们需要在各种游戏事件中播放相应的音效，以提供即时反馈和增强游戏体验。

### 6.1 玩家射击音效

在`shootPlayer()`方法中添加玩家射击音效：

```cpp
// SceneMain.cpp
void SceneMain::shootPlayer()
{
    // ...原有代码
    Mix_PlayChannel(0, sounds["player_shoot"], 0);
}
```

### 6.2 敌人射击音效

在`shootEnemy()`方法中添加敌人射击音效：

```cpp
// SceneMain.cpp
void SceneMain::shootEnemy(Enemy *enemy)
{
    // ...原有代码
    Mix_PlayChannel(-1, sounds["enemy_shoot"], 0);
}
```

### 6.3 子弹命中音效

在`updatePlayerProjectiles()`和`updateEnemyProjectiles()`方法中添加子弹命中音效：

```cpp
// SceneMain.cpp
void SceneMain::updatePlayerProjectiles(float deltaTime)
{
    // ...原有代码
    if (SDL_HasIntersection(&enemyRect, &projectileRect)){
        enemy->currentHealth -= projectile->damage;
        delete projectile;
        it = projectilesPlayer.erase(it);
        hit = true;
        Mix_PlayChannel(-1, sounds["hit"], 0);
        break;
    }
    // ...原有代码
}

void SceneMain::updateEnemyProjectiles(float deltaTime)
{
    // ...原有代码
    if (SDL_HasIntersection(&projectileRect, &playerRect) && !isDead){
        player.currentHealth -= projectile->damage;
        delete projectile;
        it = projectilesEnemy.erase(it);
        Mix_PlayChannel(-1, sounds["hit"], 0);
    }
    // ...原有代码
}
```

### 6.4 爆炸音效

在`enemyExplode()`和`updatePlayer()`方法中添加爆炸音效：

```cpp
// SceneMain.cpp
void SceneMain::enemyExplode(Enemy *enemy)
{
    // ...原有代码
    Mix_PlayChannel(-1, sounds["enemy_explode"], 0);
    // ...原有代码
}

void SceneMain::updatePlayer(float)
{
    // ...原有代码
    if (player.currentHealth <= 0){
        // ...原有代码
        Mix_PlayChannel(-1, sounds["player_explode"], 0);
        return;
    }
    // ...原有代码
}
```

### 6.5 拾取物品音效

在`playerGetItem()`方法中添加拾取物品音效：

```cpp
// SceneMain.cpp
void SceneMain::playerGetItem(Item *item)
{
    // ...原有代码
    Mix_PlayChannel(-1, sounds["get_item"], 0);
}
```

## SDL_mixer函数解释

在上面的代码中，我们使用了几个SDL_mixer函数，这里简单解释一下它们的作用：

- `Mix_Init()`：初始化SDL_mixer库，指定需要支持的音频格式
- `Mix_OpenAudio()`：打开音频设备，设置音频质量参数
- `Mix_AllocateChannels()`：分配音效通道数量
- `Mix_VolumeMusic()`：设置背景音乐的音量
- `Mix_Volume()`：设置音效的音量，参数`-1`表示设置所有通道的音量
- `Mix_LoadMUS()`：加载背景音乐文件
- `Mix_LoadWAV()`：加载音效文件
- `Mix_PlayMusic()`：播放背景音乐，第二个参数表示循环次数，`-1`表示无限循环
- `Mix_PlayChannel()`：在指定通道播放音效，第一个参数是通道号，`-1`表示使用第一个可用的通道，第三个参数表示循环次数，`0`表示不循环
- `Mix_HaltMusic()`：停止背景音乐
- `Mix_FreeMusic()`：释放背景音乐资源
- `Mix_FreeChunk()`：释放音效资源
- `Mix_CloseAudio()`：关闭音频设备
- `Mix_Quit()`：退出SDL_mixer库

## 总结

在本课中，我们为游戏添加了背景音乐和各种音效，使游戏体验更加完整和生动。我们学习了：

1. 如何初始化和清理SDL_mixer库
2. 如何加载和播放背景音乐
3. 如何加载和管理多个音效
4. 如何在不同的游戏事件中播放相应的音效
5. 如何清理音频资源，防止内存泄漏

这些音频元素大大提升了游戏的沉浸感和反馈效果，使玩家能够通过听觉获取游戏状态信息，增强游戏体验。

## 练习

1. 尝试为游戏添加更多的音效，如玩家受伤音效、游戏胜利或失败的音效等。

2. 尝试在不同的游戏阶段播放不同的背景音乐，例如在游戏开始、战斗激烈和游戏结束时播放不同的音乐，以增强情感体验。
