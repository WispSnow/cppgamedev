# 标题场景

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/Yu1KxWOC9zU?si=6FrscZTlJqA8LdbU" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1cecyepEga&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在前面的课程中，我们已经实现了游戏的主要场景，包括玩家控制、敌机生成、碰撞检测以及用户界面等功能。然而，一个完整的游戏通常包含多个场景，如标题场景、游戏场景、暂停场景和结束场景等。在本课中，我们将学习如何创建一个标题场景，为游戏提供一个入口点，增强游戏的完整性和专业性。

<img src="https://theorhythm.top/gamedev/SS/23 标题场景.PNG" style='width: 800px;' />

## 场景管理的意义

游戏场景管理是游戏开发中的重要概念，它允许游戏在不同的状态之间切换，例如从标题屏幕切换到主游戏，或从主游戏切换到暂停菜单。良好的场景管理有以下优点：

1. **模块化设计**：将游戏分解为独立的场景，使代码更加模块化和可维护
2. **状态管理**：清晰地管理游戏的不同状态，避免状态混乱
3. **资源管理**：在不同场景之间合理地加载和释放资源，提高性能
4. **用户体验**：提供完整的游戏流程，增强用户体验

## 1. 场景基类的实现

首先，我们需要创建一个场景基类，所有具体的场景都将继承自这个基类。在我们的项目中，这个基类已经定义在`Scene.h`文件中：

```cpp
// Scene.h
#ifndef SCENE_H
#define SCENE_H

#include <SDL.h>

class Game;

class Scene{
public:
    Scene();
    virtual ~Scene() = default;

    virtual void init() = 0;
    virtual void update(float deltaTime) = 0;
    virtual void render() = 0;
    virtual void clean() = 0;
    virtual void handleEvent(SDL_Event* event) = 0;
protected:
    Game& game;
};

#endif // SCENE_H
```

这个基类定义了所有场景共享的接口：
- `init()`：初始化场景，加载资源
- `update(float deltaTime)`：更新场景状态
- `render()`：渲染场景
- `clean()`：清理资源
- `handleEvent(SDL_Event* event)`：处理输入事件

同时，我们在`Scene.cpp`中实现了构造函数：

```cpp
// Scene.cpp
#include "Scene.h"
#include "Game.h"

Scene::Scene() : game(Game::getInstance())
{
}
```

这个构造函数获取游戏实例的引用，使每个场景都能访问游戏的共享资源和功能。

## 2. 创建标题场景类

接下来，我们创建一个专门的标题场景类，继承自场景基类：

```cpp
// SceneTitle.h
#ifndef SCENE_TITLE_H
#define SCENE_TITLE_H

#include "Scene.h"
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_ttf.h>
#include <SDL_mixer.h>

class SceneTitle : public Scene
{
public:
    virtual void init() override;
    virtual void update(float deltaTime) override;
    virtual void render() override;
    virtual void clean() override;
    virtual void handleEvent(SDL_Event* event) override;

private:
    Mix_Music* bgm; // 背景音乐
    float timer = 0.0f; // 计时器
};

#endif // SCENE_TITLE_H
```

标题场景类包含两个私有成员：
- `bgm`：背景音乐
- `timer`：用于实现文本闪烁效果的计时器

## 3. 实现标题场景功能

### 3.1 初始化标题场景

在`SceneTitle.cpp`中，我们首先实现`init()`方法来初始化标题场景：

```cpp
// SceneTitle.cpp
#include "SceneTitle.h"
#include "SceneMain.h"
#include "Game.h"
#include <string>

void SceneTitle::init()
{
    //载入并播放背景音乐
    bgm = Mix_LoadMUS("assets/music/06_Battle_in_Space_Intro.ogg");
    if (bgm == nullptr)
    {
        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "Failed to load music: %s", Mix_GetError());
    }
    Mix_PlayMusic(bgm, -1);
}
```

在初始化方法中，我们加载并播放背景音乐，为标题场景创建氛围。

### 3.2 更新标题场景

接下来，我们实现`update()`方法来更新标题场景的状态：

```cpp
// SceneTitle.cpp
void SceneTitle::update(float deltaTime)
{
    timer += deltaTime;
    if (timer > 1.0f){
        timer -= 1.0f;
    }
}
```

这个方法更新计时器，当计时器超过1秒时重置，形成一个循环计时器，用于实现文本闪烁效果。

### 3.3 渲染标题场景

在`render()`方法中，我们渲染标题场景的视觉元素：

```cpp
// SceneTitle.cpp
void SceneTitle::render()
{
    //渲染标题文字
    std::string titleText = "SDL太空战机";
    game.renderTextCentered(titleText, 0.4, true);

    //渲染普通文字
    if (timer < 0.5f){
        std::string instructions = "按 J 键开始游戏";
        game.renderTextCentered(instructions, 0.8, false);
    }
}
```

这个方法完成两项任务：
1. 渲染游戏标题，位于屏幕中上部
2. 根据计时器状态渲染或隐藏提示文字，产生闪烁效果

### 3.4 处理输入事件

在`handleEvent()`方法中，我们处理用户输入，允许玩家从标题场景进入主游戏场景：

```cpp
// SceneTitle.cpp
void SceneTitle::handleEvent(SDL_Event *event)
{
    if (event->type == SDL_KEYDOWN){
        if (event->key.keysym.scancode == SDL_SCANCODE_J){
            auto sceneMain = new SceneMain();
            game.changeScene(sceneMain);
        }
    }
}
```

当玩家按下J键时，我们创建一个新的主游戏场景对象，并调用游戏实例的`changeScene()`方法来切换场景。

### 3.5 清理资源

最后，我们实现`clean()`方法来清理标题场景使用的资源：

```cpp
// SceneTitle.cpp
void SceneTitle::clean()
{
    // 清理背景音乐
    if (bgm != nullptr) {
        Mix_HaltMusic();
        Mix_FreeMusic(bgm);
    }
}
```

虽然这个简单的标题场景没有使用太多资源，但我们仍然需要确保在场景结束时正确释放背景音乐资源，防止内存泄漏。

## 4. 修改游戏类

要支持场景管理，我们需要修改游戏类（`Game`）以处理场景切换和管理。

### 4.1 添加场景管理相关成员

在`Game.h`中，我们添加了以下成员和方法：

```cpp
// Game.h
class Game
{
public:
    // ...现有方法...
    void changeScene(Scene* scene);

    // 渲染文字函数
    void renderTextCentered(std::string text, float posY, bool isTitle);

private:
    // ...现有成员...
    TTF_Font* titleFont;
    TTF_Font* textFont;
    Scene* currentScene = nullptr;
    // ...其他成员...
};
```

我们添加了：
- `currentScene`：当前活动场景的指针
- `titleFont`和`textFont`：用于渲染标题和普通文本的字体
- `changeScene()`：切换场景的方法
- `renderTextCentered()`：居中渲染文本的辅助方法

### 4.2 实现场景切换

在`Game.cpp`中，我们实现了场景切换的方法：

```cpp
// Game.cpp
void Game::changeScene(Scene *scene)
{
    if (currentScene != nullptr)
    {
        currentScene->clean();
        delete currentScene;
    }
    currentScene = scene;
    currentScene->init();
}
```

这个方法执行以下步骤：
1. 如果存在当前场景，清理并释放其资源
2. 将当前场景指针设置为新场景
3. 初始化新场景

### 4.3 实现文本渲染

为了支持在场景中渲染文本，我们实现了`renderTextCentered()`方法：

```cpp
// Game.cpp
void Game::renderTextCentered(std::string text, float posY, bool isTitle)
{
    SDL_Color color = {255, 255, 255, 255};
    SDL_Surface *surface;
    if (isTitle){
        surface = TTF_RenderUTF8_Solid(titleFont, text.c_str(), color);
    }else{
        surface = TTF_RenderUTF8_Solid(textFont, text.c_str(), color);
    }
    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, surface);
    int y = static_cast<int>((getWindowHeight() - surface->h) * posY);
    SDL_Rect rect = {getWindowWidth() / 2 - surface->w / 2,
                     y,
                     surface->w,
                     surface->h};
    SDL_RenderCopy(renderer, texture, NULL, &rect);
    SDL_DestroyTexture(texture);
    SDL_FreeSurface(surface);
}
```

这个方法根据参数渲染不同大小的文本，并将其居中显示在指定的垂直位置。参数包括：
- `text`：要渲染的文本内容
- `posY`：文本在屏幕上的垂直位置，范围为0到1
- `isTitle`：是否使用大号字体（标题字体）

### 4.4 修改游戏初始化和主循环

最后，我们修改`Game::init()`方法，将初始场景设置为标题场景：

```cpp
// Game.cpp
void Game::init()
{
    // ...前面的初始化代码...

    // 载入字体
    titleFont = TTF_OpenFont("assets/font/VonwaonBitmap-16px.ttf", 64);
    textFont = TTF_OpenFont("assets/font/VonwaonBitmap-16px.ttf", 32);
    if (titleFont == nullptr || textFont == nullptr) {
        SDL_LogError(SDL_LOG_CATEGORY_ERROR, "TTF_OpenFont: %s\n", TTF_GetError());
        isRunning = false;
    }

    currentScene = new SceneTitle();
    currentScene->init();
}
```

同时，修改游戏主循环的`update()`、`render()`和`handleEvent()`方法，让它们调用当前场景的相应方法：

```cpp
// Game.cpp
void Game::update(float deltaTime)
{
    backgroundUpdate(deltaTime);
    currentScene->update(deltaTime);
}

void Game::render()
{
    // 清空
    SDL_RenderClear(renderer);
    // 渲染星空背景
    renderBackground();

    currentScene->render();
    // 显示更新
    SDL_RenderPresent(renderer);
}

void Game::handleEvent(SDL_Event *event)
{
    while (SDL_PollEvent(event))
    {
        if (event->type == SDL_QUIT)
        {
            isRunning = false;
        }
        currentScene->handleEvent(event);
    }
}
```

这样，游戏主循环就会将输入事件、更新和渲染任务委托给当前活动的场景。

## 完成效果

实现上述代码后，游戏将从标题场景开始，显示游戏标题和闪烁的提示文字。当玩家按下J键时，游戏将切换到主游戏场景，开始实际的游戏。

<img src="https://theorhythm.top/gamedev/SS/23 标题场景截图.png" style='width: 800px;' />

## 总结

在本课中，我们实现了标题场景和场景管理系统，为游戏增加了更完整的结构。我们学习了：

1. 如何设计和实现场景基类
2. 如何创建和实现具体的场景类（标题场景）
3. 如何在游戏中管理和切换场景
4. 如何使用SDL_ttf渲染居中文本
5. 如何实现文本闪烁效果

这些技术为实现更复杂的游戏流程奠定了基础，你可以在此基础上添加更多场景，如游戏暂停场景、游戏结束场景、高分榜场景等，使游戏更加完整和专业。

## 练习

1. 为标题场景添加背景图片或动画效果，增强视觉效果。

2. 在标题场景中添加菜单选项，如"开始游戏"、"选项设置"和"退出游戏"等，并实现菜单导航和选择功能。

3. 实现一个暂停场景，当玩家在主游戏场景中按下ESC键时，游戏会切换到暂停场景，显示"继续游戏"和"返回主菜单"等选项。

4. 设计并实现一个游戏结束场景，显示玩家的得分和游戏时间，以及"重新开始"和"返回主菜单"等选项。
