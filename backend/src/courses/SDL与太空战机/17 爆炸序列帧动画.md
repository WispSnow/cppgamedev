# 爆炸序列帧动画

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/xaTtU9hrLeg?si=VcxhmhmrzX2fEjmu" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1XirGYwEJT&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了碰撞检测和击杀功能，让子弹能够击中敌机，敌机被击毁时会直接从游戏中消失。但是，这种直接消失的方式缺乏视觉反馈，不够生动。在这一课中，我们将为敌机被击毁时添加爆炸动画效果，使游戏更加生动有趣。

<img src="https://theorhythm.top/gamedev/SS/17 爆照序列帧动画.PNG" style='width: 800px;' />

## 序列帧动画原理

序列帧动画（Sprite Animation）是游戏开发中常用的动画技术。它通过快速播放一系列静态图像（帧），创造出连续运动的错觉。这种技术在游戏中用于实现角色移动、特效展示等动画效果。

实现序列帧动画的基本步骤如下：

1. **准备序列帧图像**：制作一系列表示动画不同状态的图像，通常将它们合并为一张精灵图（Sprite Sheet）。
2. **加载精灵图**：在游戏中加载这张精灵图。
3. **定义显示区域**：只显示精灵图的特定区域，这个区域就是当前需要显示的帧。
4. **动态更新显示区域**：随着时间推移，更改显示区域指向的帧，创造出动画效果。

对于爆炸动画，我们使用一张包含多个爆炸帧的精灵图。通过控制显示区域，依次显示每一帧，就能呈现出爆炸的过程。

## 1. 定义爆炸动画数据结构

首先，我们在`Object.h`中定义一个新的结构体`Explosion`，表示爆炸动画：

```cpp
// Object.h
struct Explosion{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int currentFrame = 0;       // 当前帧索引
    int totlaFrame = 0;         // 总帧数
    Uint32 startTime = 0;       // 动画开始时间
    Uint32 FPS = 10;            // 帧率（每秒播放帧数）
};
```

这个结构体包含了爆炸动画所需的所有信息：
- `texture`：爆炸精灵图的纹理
- `position`：爆炸的位置
- `width`和`height`：每帧的宽度和高度
- `currentFrame`：当前显示的帧索引
- `totlaFrame`：动画的总帧数
- `startTime`：动画开始的时间戳
- `FPS`：帧率，决定动画播放的速度

## 2. 更新SceneMain类

接下来，我们需要更新`SceneMain`类，添加爆炸动画相关的成员和方法：

```cpp
// SceneMain.h
class SceneMain : public Scene {
public:
    // ...现有方法...
    void updateExplosions(float deltaTime);  // 更新爆炸动画
    void renderExplosions();                 // 渲染爆炸动画

private:
    // ...现有成员...
    Explosion explosionTemplate;            // 爆炸动画模板
    std::list<Explosion*> explosions;       // 存储活动爆炸动画的列表
};
```

我们添加了以下新成员和方法：
- `explosionTemplate`：爆炸动画模板，用于创建新的爆炸效果
- `explosions`：存储当前屏幕上所有活动爆炸动画的列表
- `updateExplosions()`：更新爆炸动画状态的方法
- `renderExplosions()`：渲染爆炸动画的方法

## 3. 初始化爆炸动画模板

在`SceneMain::init()`方法中，我们需要初始化爆炸动画模板：

```cpp
void SceneMain::init()
{
    // 初始化随机数生成器和其他模板（与之前相同）
    // ...

    // 初始化爆炸动画模板
    explosionTemplate.texture = IMG_LoadTexture(game.getRenderer(), "assets/effect/explosion.png");
    SDL_QueryTexture(explosionTemplate.texture, NULL, NULL, &explosionTemplate.width, &explosionTemplate.height);
    explosionTemplate.totlaFrame = explosionTemplate.width / explosionTemplate.height;
    explosionTemplate.width = explosionTemplate.height;
}
```

这里我们加载了爆炸精灵图的纹理，并设置了初始属性。特别需要注意的是：
- 我们假设爆炸精灵图是一个水平排列的帧序列，每帧的宽度等于高度（正方形）
- 通过将总宽度除以高度，我们得到总帧数
- 然后将宽度设置为高度，使每帧成为正方形

## 4. 清理爆炸动画资源

在`SceneMain::clean()`方法中，我们需要添加清理爆炸动画资源的代码：

```cpp
void SceneMain::clean()
{
    // 清理其他资源（与之前相同）
    // ...

    // 清理爆炸动画
    for (auto &explosion : explosions){
        if (explosion != nullptr){
            delete explosion;
        }
    }
    explosions.clear();

    // 清理纹理（与之前相同）
    // ...
    
    if (explosionTemplate.texture != nullptr){
        SDL_DestroyTexture(explosionTemplate.texture);
    }
}
```

这段代码确保所有动态分配的爆炸动画对象都被正确删除，并清理了爆炸动画模板的纹理资源，防止内存泄漏。

## 5. 修改敌机爆炸效果

在上一课中，`enemyExplode()`方法只是简单地删除敌机对象。现在，我们需要修改它，在敌机位置创建一个爆炸动画：

```cpp
void SceneMain::enemyExplode(Enemy *enemy)
{
    auto currentTime = SDL_GetTicks();
    auto explosion = new Explosion(explosionTemplate);
    explosion->position.x = enemy->position.x + enemy->width / 2 - explosion->width / 2;
    explosion->position.y = enemy->position.y + enemy->height / 2 - explosion->height / 2;
    explosion->startTime = currentTime;
    explosions.push_back(explosion);
    delete enemy;
}
```

在这个方法中，我们：
1. 获取当前时间作为爆炸动画的开始时间
2. 创建一个新的爆炸动画对象，基于爆炸动画模板
3. 将爆炸动画的位置设置在敌机的中心
4. 设置爆炸动画的开始时间
5. 将爆炸动画添加到容器中
6. 删除敌机对象

## 6. 实现爆炸动画的更新

我们需要定期更新爆炸动画的状态，主要是更新当前帧索引，并在动画播放完毕后删除爆炸对象：

```cpp
void SceneMain::updateExplosions(float)
{
    auto currentTime = SDL_GetTicks();
    for (auto it = explosions.begin(); it != explosions.end();)
    {
        auto explosion = *it;
        // 根据时间差和帧率计算当前帧索引
        explosion->currentFrame = (currentTime - explosion->startTime) * explosion->FPS / 1000;
        // 检查动画是否播放完毕
        if (explosion->currentFrame >= explosion->totlaFrame){
            delete explosion;
            it = explosions.erase(it);
        }else {
            ++it;
        }
    }
}
```

这个方法遍历所有爆炸动画对象，根据当前时间和开始时间的差值，以及设定的帧率，计算当前应该显示的帧索引。如果当前帧索引超过了总帧数，说明动画已经播放完毕，此时我们删除该爆炸对象。

## 7. 渲染爆炸动画

最后，我们需要渲染所有活动的爆炸动画：

```cpp
void SceneMain::renderExplosions()
{
    for (auto explosion : explosions)
    {
        // 定义源矩形（精灵图上的区域）
        SDL_Rect src = {explosion->currentFrame * explosion->width, 0, explosion->width, explosion->height};
        // 定义目标矩形（屏幕上的位置）
        SDL_Rect dst = {
            static_cast<int>(explosion->position.x), 
            static_cast<int>(explosion->position.y), 
            explosion->width, 
            explosion->height
        };
        // 绘制当前帧
        SDL_RenderCopy(game.getRenderer(), explosion->texture, &src, &dst);
    }
}
```

在这个方法中，我们遍历所有爆炸动画对象，为每个对象：
1. 定义源矩形（src），表示精灵图上的区域，根据当前帧索引和帧宽度计算
2. 定义目标矩形（dst），表示屏幕上的位置和大小
3. 使用`SDL_RenderCopy`函数，将精灵图指定区域绘制到屏幕指定位置

与之前的渲染方法不同，这里我们使用了`SDL_RenderCopy`的另一种形式，额外提供了源矩形参数，用于指定只渲染纹理的特定区域。

## 8. 更新主循环

最后，我们需要在主循环中调用爆炸动画相关的方法：

```cpp
void SceneMain::update(float deltaTime)
{
    keyboardControl(deltaTime);
    updatePlayerProjectiles(deltaTime);
    updateEnemyProjectiles(deltaTime);
    spawEnemy();
    updateEnemies(deltaTime);
    updatePlayer(deltaTime);
    updateExplosions(deltaTime);  // 添加更新爆炸动画
}

void SceneMain::render()
{
    // 渲染玩家子弹
    renderPlayerProjectiles();
    //渲染敌机子弹
    renderEnemyProjectiles();
    // 渲染玩家
    if (!isDead){
        SDL_Rect playerRect = { static_cast<int>(player.position.x), 
                       static_cast<int>(player.position.y), 
                       player.width, 
                       player.height};
        SDL_RenderCopy(game.getRenderer(), player.texture, NULL, &playerRect);
    }
    // 渲染敌人
    renderEnemies();
    // 渲染爆炸动画
    renderExplosions();  // 添加渲染爆炸动画
}
```

在`update()`方法的最后，我们添加了对`updateExplosions()`的调用，以更新爆炸动画状态。在`render()`方法的最后，我们添加了对`renderExplosions()`的调用，以渲染爆炸动画。

## 游戏效果

实现上述代码后，当敌机被玩家子弹击中或与玩家碰撞而被摧毁时，会在敌机位置播放一段爆炸动画，使游戏画面更加生动有趣。爆炸动画播放完毕后会自动消失，不会影响游戏性能。

## 总结

在本课中，我们实现了序列帧动画技术，为敌机被击毁时添加了爆炸效果，使游戏更加生动有趣。我们学习了：

1. 序列帧动画的基本原理和实现方法。
2. 如何加载和管理精灵图（Sprite Sheet）。
3. 如何根据时间和帧率控制动画播放。
4. 如何使用`SDL_RenderCopy`渲染纹理的特定区域。
5. 如何在游戏中集成和管理多个动画实例。

这些技术不仅适用于爆炸效果，也可以用于实现其他类型的动画，如角色移动、特效展示等，为游戏添加更多视觉吸引力。

## 练习

1. 修改代码，为玩家被击毁时也添加爆炸动画效果。

2. 实现一个更大、更持久的爆炸效果，用于特殊敌机被击毁时。

3. 为不同类型的敌机添加不同的爆炸效果，如小型敌机爆炸效果小而快，大型敌机爆炸效果大而慢。
