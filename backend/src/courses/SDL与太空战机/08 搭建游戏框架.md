# 搭建游戏框架

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/SYBudM_LE9I?si=8_rwvJqgg8cgQcqC" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1tV6WYXEuz&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们学习了游戏循环和场景管理的理论知识。本课中，我们将把这些理论付诸实践，搭建一个基本的游戏框架，为我们的太空射击游戏打下基础。

<img src="https://theorhythm.top/gamedev/SS/8 搭建游戏框架.PNG" style='width: 800px;' />

## 项目结构重组

与前面课程相比，我们将对项目结构进行重组，采用更专业的组织方式：

```
SDLShooter/
├── .vscode/          # VSCode配置文件
├── assets/           # 游戏资源（图像、音频、字体等）
├── src/              # 源代码目录
│   ├── main.cpp      # 程序入口
│   ├── Game.h        # 游戏主类头文件
│   ├── Game.cpp      # 游戏主类实现
│   ├── Scene.h       # 场景基类
│   ├── SceneMain.h   # 主场景类头文件
│   └── SceneMain.cpp # 主场景类实现
└── CMakeLists.txt    # CMake配置文件
```

这种结构将源代码集中放在`src`目录下，使项目更整洁，更易于维护。

## 更新CMake配置

首先，我们需要更新`CMakeLists.txt`文件，以支持新的项目结构：

```cmake
# 添加可执行文件
add_executable(${TARGET} 
                "src/main.cpp"
                "src/Game.cpp"
                "src/SceneMain.cpp")

# 链接库
target_link_libraries(${TARGET}
                        ${SDL2_LIBRARIES}
                        SDL2_image::SDL2_image
                        SDL2_mixer::SDL2_mixer
                        SDL2_ttf::SDL2_ttf
                        )
```

与之前相比，我们现在明确列出了所有需要编译的源文件，而不是仅指定一个main.cpp文件。这种方式更适合多文件项目。

## 创建场景基类

根据上一课的理论，我们需要一个场景基类，它定义了所有场景必须实现的接口：

```cpp
// Scene.h
#ifndef SCENE_H
#define SCENE_H

#include <SDL.h>

class Scene{
public:
    Scene() = default;
    virtual ~Scene() = default;

    virtual void init() = 0;
    virtual void update() = 0;
    virtual void render() = 0;
    virtual void clean() = 0;
    virtual void handleEvent(SDL_Event* event) = 0;
};

#endif // SCENE_H
```

这个基类定义了每个场景必须实现的五个纯虚函数：
- `init()`: 初始化场景
- `update()`: 更新场景状态
- `render()`: 渲染场景
- `clean()`: 清理场景资源
- `handleEvent()`: 处理输入事件

注意我们使用了`= 0`将这些函数声明为纯虚函数，这意味着子类必须实现它们，同时也使`Scene`成为一个抽象类，不能直接实例化。

## 创建游戏主类

游戏主类`Game`是整个游戏的核心，它管理游戏循环和场景切换：

```cpp
// Game.h
#ifndef GAME_H
#define GAME_H

#include "Scene.h"
#include "SDL.h"

class Game
{
public:
    Game();
    ~Game();
    void run();
    void init();
    void clean();
    void changeScene(Scene* scene);
private:
    bool isRunning = true;
    Scene* currentScene = nullptr;
};

#endif
```

`Game`类包含以下重要方法：
- `run()`: 运行游戏主循环
- `init()`: 初始化游戏
- `clean()`: 清理游戏资源
- `changeScene()`: 切换当前场景

同时，它还包含两个私有成员变量：
- `isRunning`: 表示游戏是否正在运行
- `currentScene`: 指向当前活动场景的指针

```cpp
// Game.cpp
#include "Game.h"

Game::Game()
{
}

Game::~Game()
{
}

void Game::run()
{
    while (isRunning)
    {
        SDL_Event event;
        currentScene->handleEvent(&event);
        currentScene->update();
        currentScene->render();
    }
    
}

void Game::init()
{
}

void Game::clean()
{
}

void Game::changeScene(Scene *scene)
{
    if (currentScene != nullptr)
    {
        currentScene->clean();
        delete currentScene;
    }
    currentScene = scene;
    currentScene->init();
}
```

`Game::run()`方法实现了我们在上一课中讨论的游戏循环，它包含三个主要步骤：事件处理、逻辑更新和渲染。

`Game::changeScene()`方法实现了场景切换逻辑：
1. 如果已有当前场景，先清理并删除它
2. 将新场景设置为当前场景
3. 初始化新场景

## 创建主场景类

接下来，我们创建一个具体的场景类`SceneMain`，继承自`Scene`基类：

```cpp
// SceneMain.h
#ifndef SCENE_MAIN_H
#define SCENE_MAIN_H

#include "Scene.h"

class SceneMain : public Scene {
public:
    SceneMain();
    ~SceneMain();

    void update() override;
    void render() override;
    void handleEvent(SDL_Event* event) override;
    void init() override;
    void clean() override;

private:

};

#endif // SCENE_MAIN_H
```

```cpp
// SceneMain.cpp
#include "SceneMain.h"

SceneMain::SceneMain()
{
}

SceneMain::~SceneMain()
{
}

void SceneMain::update()
{
}

void SceneMain::render()
{
}

void SceneMain::handleEvent(SDL_Event *event)
{
}

void SceneMain::init()
{
}

void SceneMain::clean()
{
}
```

目前，这些方法的实现都是空的，在后续课程中，我们将填充它们，使游戏具有实际功能。

## 程序入口

最后，我们需要修改`main.cpp`文件，作为程序的入口点：

```cpp
#include <iostream>
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_mixer.h>
#include <SDL_ttf.h>

int main(int, char**) {

    return 0;
}
```

目前，`main()`函数也是空的。在下一课中，我们将完善它，创建`Game`实例并运行游戏循环。

## 框架结构分析

我们创建的游戏框架遵循了面向对象的设计原则：

1. **单一职责原则**：每个类都有明确的职责。`Game`类负责管理游戏循环和场景，而各种`Scene`子类负责特定场景的逻辑。

2. **开放/封闭原则**：框架对扩展开放，对修改封闭。我们可以添加新的场景类而无需修改现有代码。

3. **依赖倒置原则**：高层模块（`Game`）依赖于抽象（`Scene`基类），而不依赖于具体实现（`SceneMain`等子类）。

这种设计使我们能够轻松添加新场景（如标题界面、游戏结束界面等）而无需大幅修改现有代码。

## 与上课理论的对应

让我们回顾一下这个框架如何实现上一课中讲述的游戏循环和场景管理理论：

1. **游戏循环**：在`Game::run()`方法中实现，包括事件处理、更新和渲染三个步骤。

2. **场景管理**：使用面向对象方法，通过`Scene`基类和具体场景子类实现。场景切换通过`Game::changeScene()`方法完成。

3. **初始化和清理**：每个场景都有`init()`和`clean()`方法，确保资源的正确管理。

## 下一步

虽然我们已经搭建了基本框架，但它还不能运行。在后续课程中，我们将逐步：

1. 完善`Game`类，添加SDL初始化和清理代码
2. 实现`SceneMain`类的内容，使其能够显示和控制游戏对象
3. 更新`main.cpp`，创建和运行游戏实例

## 练习

1. 尝试分析这个框架的优缺点，思考有哪些地方可以改进。

2. 思考如何扩展这个框架以支持更多功能，如：
   - 资源管理系统
   - 音频管理系统
   - 输入处理系统

3. 设计一个新的场景类（如`SceneTitle`或`SceneGameOver`），思考它们需要实现哪些特定功能。

4. 思考如何改进`Game::run()`方法，加入时间管理，确保游戏在不同性能的设备上以相同的速度运行。
