# 物品掉落与拾取

<link rel="stylesheet" href="/css/videoStyles.css" />

<div class="video-container">
  <div class="video-tabs">
    <a href="#bilibili" class="video-tab bilibili-tab">哔哩哔哩</a>
    <a href="#youtube" class="video-tab youtube-tab">YouTube</a>
  </div>

  <div id="youtube" class="video-content">
    <iframe 
      class="video-frame"
      src="https://www.youtube.com/embed/y4QszwlpCD8?si=ySAkgSZAeKH8Fpha" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>

  <div id="bilibili" class="video-content">
    <iframe 
      class="video-frame"
      src="//player.bilibili.com/player.html?bvid=BV1XyrDYgEco&page=1&autoplay=0&danmaku=0&high_quality=1" 
      scrolling="no" 
      border="0" 
      frameborder="no" 
      framespacing="0" 
      allowfullscreen="true">
    </iframe>
  </div>
</div>

在上一课中，我们实现了爆炸序列帧动画，使敌机被击毁时的效果更加生动。但是，游戏中仅有敌机被摧毁的视觉效果还不够，我们还需要一种激励机制来鼓励玩家击败敌人。在这一课中，我们将实现物品掉落与拾取系统，当敌机被击毁时，有一定概率掉落物品，玩家可以拾取这些物品来获得各种增益效果。

<img src="https://theorhythm.top/gamedev/SS/18 物品的掉落与拾取.PNG" style='width: 800px;' />

## 物品系统概述

在射击游戏中，物品掉落系统是一种常见的游戏机制，它能够增加游戏的策略性和乐趣。通过这个系统，我们可以实现：

1. 设计不同类型的物品，如生命回复、护盾和武器升级等
2. 实现敌机击毁后随机掉落物品的机制
3. 为物品添加运动效果，使其在场景中有更多的动态表现
4. 实现玩家与物品的碰撞检测和拾取功能
5. 根据物品类型应用不同的增益效果

这些功能将使游戏更加有趣，并为玩家提供额外的游戏目标和战略选择。

## 1. 定义物品数据结构

首先，我们在`Object.h`文件中定义物品类型枚举和物品结构体：

```cpp
// 物品类型枚举
enum class ItemType{
    Life,
    Shield,
    Time
};

// 物品结构体
struct Item{
    SDL_Texture* texture = nullptr;
    SDL_FPoint position = {0, 0};
    SDL_FPoint direction = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 200;
    int bounceCount = 3;
    ItemType type = ItemType::Life;
};
```

这个结构体包含了物品的基本属性：
- `texture`：物品的纹理
- `position`：物品在屏幕上的位置
- `direction`：物品的移动方向
- `width`和`height`：物品的宽度和高度
- `speed`：物品的移动速度
- `bounceCount`：物品在碰到屏幕边缘时可以反弹的次数
- `type`：物品的类型，用于确定拾取后的效果

同时，我们还需要为玩家添加最大生命值属性，方便实现生命值回复的上限：

```cpp
struct Player{
    // ...原有属性
    int currentHealth = 3;
    int maxHealth = 3;
    // ...其他属性
};
```

## 2. 更新SceneMain类

接下来，我们需要更新`SceneMain`类，添加物品相关的成员和方法：

```cpp
// SceneMain.h
class SceneMain : public Scene {
public:
    // ...现有方法...
    void dropItem(Enemy* enemy);
    void updateItems(float deltaTime);
    void playerGetItem(Item* item);
    void renderItems();

private:
    // ...现有成员...
    Item itemLifeTemplate;
    std::list<Item*> items;
};
```

我们添加了以下新成员和方法：
- `itemLifeTemplate`：物品模板，用于创建新的物品
- `items`：存储当前屏幕上所有物品的列表
- `dropItem()`：当敌机被击毁时，随机掉落物品
- `updateItems()`：更新物品的位置和状态，处理物品与玩家的碰撞
- `playerGetItem()`：玩家获得物品后的效果处理
- `renderItems()`：渲染屏幕上的所有物品

## 3. 初始化物品模板

在`SceneMain::init()`方法中，我们需要初始化物品模板：

```cpp
void SceneMain::init()
{
    // 初始化随机数生成器和其他模板（与之前相同）
    // ...

    // 初始化物品模板
    itemLifeTemplate.texture = IMG_LoadTexture(game.getRenderer(), "assets/image/bonus_life.png");
    SDL_QueryTexture(itemLifeTemplate.texture, NULL, NULL, &itemLifeTemplate.width, &itemLifeTemplate.height);
    itemLifeTemplate.width /= 4;
    itemLifeTemplate.height /= 4;
}
```

这里我们加载了生命值物品的纹理，并设置了初始属性。为了让物品在屏幕上不会太大，我们将其尺寸缩小为原来的四分之一。

## 4. 清理物品资源

在`SceneMain::clean()`方法中，我们需要添加清理物品资源的代码：

```cpp
void SceneMain::clean()
{
    // 清理其他资源（与之前相同）
    // ...

    // 清理物品容器
    for (auto &item : items){
        if (item != nullptr){
            delete item;
        }
    }
    items.clear();
    
    // 清理物品模板纹理
    if (itemLifeTemplate.texture != nullptr){
        SDL_DestroyTexture(itemLifeTemplate.texture);
    }
}
```

这段代码确保所有动态分配的物品对象都被正确删除，并清理了物品模板的纹理资源，防止内存泄漏。

## 5. 实现物品掉落功能

当敌机被击毁时，我们希望有一定概率掉落物品。在`enemyExplode`方法中添加物品掉落的逻辑：

```cpp
void SceneMain::enemyExplode(Enemy *enemy)
{
    auto currentTime = SDL_GetTicks();
    auto explosion = new Explosion(explosionTemplate);
    explosion->position.x = enemy->position.x + enemy->width / 2 - explosion->width / 2;
    explosion->position.y = enemy->position.y + enemy->height / 2 - explosion->height / 2;
    explosion->startTime = currentTime;
    explosions.push_back(explosion);
    
    // 添加50%概率掉落物品
    if (dis(gen) < 0.5f){
        dropItem(enemy);
    }
    
    delete enemy;
}
```

在这里，我们使用随机数生成器和均匀分布来确定是否掉落物品，概率设置为50%。

然后，我们实现`dropItem`方法：

```cpp
void SceneMain::dropItem(Enemy *enemy)
{
    auto item = new Item(itemLifeTemplate);
    item->position.x = enemy->position.x + enemy->width / 2 - item->width / 2;
    item->position.y = enemy->position.y + enemy->height / 2 - item->height / 2;
    
    // 生成随机方向
    float angle = dis(gen) * 2 * M_PI;
    item->direction.x = cos(angle);
    item->direction.y = sin(angle);
    
    items.push_back(item);
}
```

在这个方法中，我们创建了一个新的物品，将其位置设置为敌机的中心，并给它一个随机的移动方向。

## 6. 实现物品的更新和碰撞检测

接下来，我们需要实现`updateItems`方法，用于更新物品的位置和检测物品与玩家的碰撞：

```cpp
void SceneMain::updateItems(float deltaTime)
{
    for (auto it = items.begin(); it != items.end();)
    {
        auto item = *it;
        // 更新位置
        item->position.x += item->direction.x * item->speed * deltaTime;
        item->position.y += item->direction.y * item->speed * deltaTime;
        
        // 处理屏幕边缘反弹
        if (item->position.x < 0 && item->bounceCount > 0) {
            item->direction.x = -item->direction.x;
            item->bounceCount--;
        }
        if (item->position.x + item->width > game.getWindowWidth() && item->bounceCount > 0) {
            item->direction.x = -item->direction.x;
            item->bounceCount--;
        }
        if (item->position.y < 0 && item->bounceCount > 0) {
            item->direction.y = -item->direction.y;
            item->bounceCount--;
        }
        if (item->position.y + item->height > game.getWindowHeight() && item->bounceCount > 0) {
            item->direction.y = -item->direction.y;
            item->bounceCount--;
        }
        
        // 如果超出屏幕范围则删除
        if (item->position.x + item->width < 0 || 
            item->position.x > game.getWindowWidth() ||
            item->position.y + item->height < 0 || 
            item->position.y > game.getWindowHeight()){
            delete item;
            it = items.erase(it);
        }
        else{
            // 检测物品与玩家的碰撞
            SDL_Rect itemRect = {
                static_cast<int>(item->position.x), 
                static_cast<int>(item->position.y), 
                item->width, 
                item->height
            };
            SDL_Rect playerRect = {
                static_cast<int>(player.position.x), 
                static_cast<int>(player.position.y), 
                player.width, 
                player.height
            };
            
            if (SDL_HasIntersection(&itemRect, &playerRect))
            {
                playerGetItem(item);
                delete item;
                it = items.erase(it);
            }else
            {
                ++it;
            }
        }
    }
}
```

这个方法主要做了三件事：
1. 更新物品的位置
2. 处理物品与屏幕边缘的碰撞，实现反弹效果
3. 检测物品与玩家的碰撞，如果碰撞则触发物品效果

## 7. 实现物品效果

当玩家拾取物品时，我们需要根据物品类型应用相应的效果。在本例中，我们实现了一种物品类型——恢复生命值：

```cpp
void SceneMain::playerGetItem(Item *item)
{
    if (item->type == ItemType::Life){
        player.currentHealth += 1;
        if (player.currentHealth > player.maxHealth){
            player.currentHealth = player.maxHealth;
        }
    }
}
```

这个方法检查物品的类型，如果是生命物品，则为玩家恢复一点生命值，但不会超过最大生命值。

## 8. 渲染物品

最后，我们需要实现`renderItems`方法，将物品渲染到屏幕上：

```cpp
void SceneMain::renderItems()
{
    for (auto &item : items)
    {
        SDL_Rect itemRect = {
            static_cast<int>(item->position.x), 
            static_cast<int>(item->position.y), 
            item->width, 
            item->height
        };
        SDL_RenderCopy(game.getRenderer(), item->texture, NULL, &itemRect);
    }   
}
```

## 9. 更新游戏主循环

在`SceneMain::update`和`SceneMain::render`方法中，我们需要调用相应的物品处理方法：

```cpp
void SceneMain::update(float deltaTime)
{
    keyboardControl(deltaTime);
    updatePlayerProjectiles(deltaTime);
    updateEnemyProjectiles(deltaTime);
    spawEnemy();
    updateEnemies(deltaTime);
    updatePlayer(deltaTime);
    updateExplosions(deltaTime);
    updateItems(deltaTime);  // 添加更新物品
}

void SceneMain::render()
{
    renderPlayerProjectiles();
    renderEnemyProjectiles();
    if (!isDead){
        SDL_Rect playerRect = { static_cast<int>(player.position.x), 
                       static_cast<int>(player.position.y), 
                       player.width, 
                       player.height};
        SDL_RenderCopy(game.getRenderer(), player.texture, NULL, &playerRect);
    }
    renderEnemies();
    renderExplosions();
    renderItems();  // 添加渲染物品
}
```

## 总结

在本课中，我们实现了物品掉落与拾取系统，为游戏增加了更多的策略性和乐趣。我们学习了：

1. 如何设计物品数据结构和类型系统
2. 如何在敌机被击毁时随机掉落物品
3. 如何实现物品在场景中的运动和碰撞检测
4. 如何处理玩家拾取物品并应用效果
5. 如何合理管理物品的生命周期

这个系统为游戏增加了更多的策略性和乐趣，玩家可以通过击败敌人来获得增益物品，提高游戏体验。

## 练习

1. 尝试添加更多类型的物品，如护盾（Shield）和时间减缓（Time）。
4. 添加物品拾取时的音效和视觉效果。
5. 实现一个物品状态显示界面，显示当前玩家拥有的物品效果。
