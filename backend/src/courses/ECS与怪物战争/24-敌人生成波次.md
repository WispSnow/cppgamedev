# 24 敌人生成波次

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV11pmsBhEzG&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV11pmsBhEzG/)

## 📖 概述

前面的章节里，我们为了验证战斗链路，经常用“测试刷怪”来堆敌人（例如 `createTestEnemy()` 每个起点刷一批）。

但塔防真正的节奏来自于 **波次（Wave）**：

- 开局给玩家一个准备时间（部署第一批单位）
- 然后按波次推进：第 1 波 → 间隔 → 第 2 波 → ……
- 每一波内部也需要“逐个生成”，而不是一口气把所有敌人瞬间丢出来

<img src="https://theorhythm.top/gamedev/MW/怪物战争.087.webp" style='width: 800px;' />

> PPT 第 87 页：敌人按波次生成（准备时间 + 波次间隔 + 波次内生成间隔 + 关卡/波次数据结构）

这一节我们把“刷怪逻辑”升级为 **数据驱动**：

- 用 JSON 描述每关的波次数据（敌人类型/数量、波次间隔、生成间隔）
- 用队列推进波次，用计时器推进生成
- 支持多起点随机出怪
- 顺带把“地图路径”也放进关卡配置，实现多关切换

本节对应代码标签：`24-敌人生成波次`（基线：`23-出击准备与出击完成`）。

## 🎯 学习目标

- 用 JSON 配置关卡：`assets/data/level_config.json`
- 设计“关卡 → 波次 → 敌人队列”的数据结构：`LevelData/Waves/Wave`
- 实现 `LevelConfig` 负责加载配置、解析波次、计算总敌人数量
- 实现 `EnemySpawner` 负责推进波次与生成敌人（队列 + 计时器）
- 将关卡数据注入 `registry.ctx()`，让 spawner/scene 可以共享使用

## 🧠 思路与设计

本节的核心是把“关卡节奏”拆成两层队列：

1) **关卡波次队列（Waves）**：一关中有多波，先进先出  
2) **当前波次敌人队列（EnemyTypes）**：一波中有多个敌人，也按队列逐个生成  

并用两套计时器控制“何时进入下一波 / 何时生成下一个敌人”：

- `next_wave_count_down_`：距离下一波开始的倒计时（开局用 `prep_time` 初始化）
- `spawn_timer_` + `spawn_interval_`：波次内生成节奏

另外，为了让出怪更“像游戏”，我们做了两件随机化：

- 每次生成敌人时，从 `start_points_` 里随机选一个起点
- 每波的敌人列表会先展开再洗牌（保证生成顺序随机）

## 🔧 实现步骤

## 🗂️ 1) 用 JSON 描述关卡与波次

新增配置文件：`assets/data/level_config.json`（数组，每个元素是一关）。

结构大致如下（节选）：

```json
{
  "name": "Level 1",
  "map_path": "assets/maps/level1.tmj",
  "prep_time": 5.0,
  "enemy_level": 1,
  "enemy_rarity": 1,
  "waves": [
    {
      "enemy_types": {"slime": 8, "wolf": 2},
      "next_wave_interval": 20.0,
      "spawn_interval": 0.8
    }
  ]
}
```

这份配置同时承担两件事：

- **关卡数据**：地图路径、敌人等级/稀有度、准备时间
- **波次数据**：每波生成什么、生成节奏怎样、下一波间隔多久

本节还新增了 `assets/maps/level2.tmj`，并在配置中通过 `map_path` 指向它，实现“同一套场景代码 → 不同关卡地图”。

## 🧱 2) 定义关卡数据结构：`LevelData/Waves/Wave`

在 `src/game/data/level_data.h` 定义 3 个结构体：

- `Wave`：一波数据（生成间隔、下一波间隔、敌人类型-数量对）
- `Waves`：多波数据（倒计时 + `queue<Wave>`）
- `LevelData`：一关的总信息（关卡号、地图路径、准备时间、总敌人数量、Waves…）

这里使用 `std::queue` 的好处是：我们天然按“第 1 波 → 第 2 波 → ……”的顺序推进，不需要额外维护索引。

## 📦 3) 载入配置：`LevelConfig`

`src/game/data/level_config.*` 负责把 JSON 转成 `LevelData` 数组：

- JSON 的敌人类型是字符串（如 `"slime"`），我们用 `entt::hashed_string` 转为 `entt::id_type` 方便后续直接走蓝图/工厂创建
- 解析时顺带累加 `total_enemy_count_`，用于填充 `GameStats.enemy_count_`（让“关卡结束判定”真正有意义）
- 把开局准备时间写入 `waves_data_.next_wave_count_down_`

关键处理逻辑（节选）：

```cpp
for (const auto& [enemy_type, count] : wave["enemy_types"].items()) {
    entt::id_type type_id = entt::hashed_string(enemy_type.c_str());
    wave_data.enemy_types_.push_back({type_id, count.get<int>()});
}
level_data.waves_data_.waves_.push(std::move(wave_data));
level_data.waves_data_.next_wave_count_down_ = level_data.prep_time_;
```

## 🧟 4) 敌人生成器：`EnemySpawner`

`src/game/spawner/enemy_spawner.*` 负责在运行时推进关卡节奏：

### 4.1 推进波次

当 `next_wave_count_down_` 归零，说明新一波开始：

1) 从 `waves_.front()` 取出 `Wave`  
2) 把 `enemy_types` 展开成一个“待生成队列”（按数量重复入队）  
3) 打乱队列顺序（洗牌）  
4) pop 掉当前波次  

为了方便洗牌，本节在 `engine::utils::math.h` 新增了泛型 `shuffle(first, last)`（内部用 `std::shuffle` + `thread_local` 随机数引擎）。

### 4.2 波次内生成敌人

当“当前波次队列”不为空，就按 `spawn_interval_` 定时生成：

- 每生成一次：从队列 `pop_front()` 拿一个敌人类型
- 随机选择一个起点
- 用 `EntityFactory::createEnemyUnit(type, pos, start, level, rarity)` 创建敌人

其中 `start_points_ / waypoint_nodes_ / level_number_ / level_config_ / Waves` 等数据，都通过 `registry.ctx()` 获取，这让 spawner 不需要直接依赖 `GameScene` 的成员。

## 🎬 5) 场景集成：从“测试刷怪”切到“配置刷怪”

`GameScene` 做了三点改造：

1) 新增 `initLevelConfig()`：加载 `LevelConfig`，并把当前关的 `waves_` 拷贝出来，同时设置：

```cpp
waves_ = level_config_->getWavesData(level_number_);
game_stats_.enemy_count_ = level_config_->getTotalEnemyCount(level_number_);
```

2) `loadLevel()` 不再写死 `level1.tmj`，而是从配置取 `map_path`。  
3) 新增 `EnemySpawner` 并在 `update()` 中每帧 `enemy_spawner_->update(dt)`；删除原来的 `createTestEnemy()` 测试刷怪入口。

此外，`initRegistryContext()` 也把 `waves_ / level_config_ / start_points_ / waypoint_nodes_ / level_number_` 等数据放进 `registry.ctx()`，让 spawner 可以无痛读取。

## ✅ 本节小结

- 用 `LevelConfig + level_config.json` 把关卡与波次从代码里抽离出来，实现真正的数据驱动
- 用 `queue<Wave>` 推进“波次”，用 `deque<enemy_type>` 推进“波次内生成”
- 通过 `registry.ctx()` 共享关卡运行时数据，让 `EnemySpawner` 成为一个可复用、低耦合模块
- `GameStats.enemy_count_` 终于被关卡配置填充，为后续“通关判定/结算 UI”铺路

## 🔍 自检清单

- [ ] 开局是否先等待 `prep_time`，再开始第一波
- [ ] 每波是否按 `spawn_interval` 逐个生成敌人，而不是瞬间生成全部
- [ ] 敌人是否会从多个起点随机刷出
- [ ] `enemy_count_` 是否等于 JSON 中所有波次敌人数量之和
- [ ] 切换到 `Level 2` 时是否会加载 `level2.tmj`

## ➡️ 下一节预告

下一节我们开始把“调试工具”正式用起来：用 ImGui 显示单位信息（属性、状态、锁定目标等），让后续数值与系统调试更高效。

