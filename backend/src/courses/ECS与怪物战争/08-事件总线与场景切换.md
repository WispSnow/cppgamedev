# 08 事件总线与场景切换

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1xGyCBgENW&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1xGyCBgENW)

## 📖 概述

第 07 节我们已经把输入做成了“信号驱动”：`InputManager` 负责检测输入变化，并通过 `entt::sigh/sink` 通知外部回调。

但如果你继续把这些输入回调**直接写在 Scene 里**，很快会遇到一个老问题：**场景和场景管理器耦合**。

- 你想“切换场景”，就必须拿到 `SceneManager` 的引用/指针
- Scene 的构造函数被迫携带 `SceneManager&`
- 未来如果 UI、系统、甚至网络逻辑也想触发切场景，你会发现“到处都在传 SceneManager”

这一节我们引入“事件总线”来解决这个问题：把“想做什么（事件）”与“谁来做（订阅者）”分离。

做法是：在引擎核心里新增 `entt::dispatcher`，把它放进 `Context`，让任何持有 `Context` 的模块都能发送事件；而 `SceneManager` 只需要订阅“切换场景事件”，在合适的时机统一执行即可。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.043.webp" style='width: 800px;' />

> PPT 第 43 页：InputManager（即时触发信号） + GameApp（事件总线，可延时触发）组合出更完整的事件系统

本节对应代码标签：`08-事件总线与场景切换`（基线：`07-输入模块的信号功能`）。

## 🎯 学习目标

- 理解 `entt::dispatcher` 的角色：**事件中心** + **事件队列（enqueue + update）**
- 设计“切场景事件”的数据结构，并用 `unique_ptr` 传递所有权
- 把 dispatcher 注入到 `Context`，形成“全局可用但不写单例”的事件总线
- 让 Scene 通过“发事件”请求切换，而不是直接依赖 `SceneManager`
- 让 `SceneManager` 通过订阅事件来做 `Push/Pop/Replace`，并保持“延迟执行”保证安全

## 🧠 思路与设计

### 1) `sigh` vs `dispatcher`：为什么两者都需要？

`entt::sigh` 更像“信号槽”：简单、直接，适合输入这种**即时**回调。

`entt::dispatcher` 更像“事件总线”：

- 为**每一种事件类型**管理一个独立的信号（`sink<Event>()`）
- 支持事件队列：`enqueue<Event>()` 入队，`dispatcher.update()` 统一出队触发

这意味着我们可以选择：

- **立即触发**（`trigger`）：事件马上被处理（适合只改一个“挂起标记”）
- **延时触发**（`enqueue + update`）：把事件放到“本帧末尾”或“下一帧”再处理（适合需要稳定时序的操作）

<img src="https://theorhythm.top/gamedev/MW/怪物战争.042.webp" style='width: 800px;' />

> PPT 第 42 页：dispatcher 的“事件类型 → 信号”映射 + “事件队列”

### 2) 用事件总线解耦 Scene 与 SceneManager

核心思路很简单：

- Scene 不再持有 `SceneManager&`
- Scene 需要切场景时，只做一件事：**发送事件**
- SceneManager 订阅事件，并把“真正的切换动作”放到 `update()` 末尾执行（避免在更新过程中修改 scene stack）

<img src="https://theorhythm.top/gamedev/MW/怪物战争.044.webp" style='width: 800px;' />

> PPT 第 44 页：通过“发送信号”请求切换场景，让 Scene 不必依赖 SceneManager

## 🔧 实现步骤

### 1) 定义事件类型：把“意图”做成结构体

本节新增了 `src/engine/utils/events.h`，定义了 4 类事件：

```cpp
// src/engine/utils/events.h
struct QuitEvent {};
struct PopSceneEvent {};
struct PushSceneEvent { std::unique_ptr<engine::scene::Scene> scene; };
struct ReplaceSceneEvent { std::unique_ptr<engine::scene::Scene> scene; };
```

这里用 `std::unique_ptr` 的理由是：场景对象的所有权应该随着事件一起“移动”给 SceneManager，而不是复制或共享。

> 小提示：因为要 `std::move` 掉 `unique_ptr`，处理函数的参数一般要用非常量引用 `Event&`（而不是 `const Event&`）。

### 2) 在 GameApp 初始化 dispatcher，并放进 Context

事件总线应该是“引擎核心能力”，因此由 `GameApp` 创建、控制生命周期：

- `GameApp` 增加 `std::unique_ptr<entt::dispatcher> dispatcher_`
- `init()` 里先 `initDispatcher()`，再 `initContext()`
- `Context` 增加 `entt::dispatcher& dispatcher_` 与 `getDispatcher()`

并且在主循环里，`GameApp::update()` 会在场景更新后调用：

```cpp
// src/engine/core/game_app.cpp
void GameApp::update(float delta_time) {
    scene_manager_->update(delta_time);
    dispatcher_->update();   // 分发 enqueue() 进队列的事件
}
```

此外，GameApp 自己也订阅一个 `QuitEvent`，用于统一退出：

- `dispatcher_->sink<utils::QuitEvent>().connect<&GameApp::onQuitEvent>(this);`

### 3) Scene 发事件：提供“请求切换场景”的统一接口

本节把 Scene 的构造函数改为只依赖 `Context`：

- 以前：`Scene(name, context, scene_manager)`
- 现在：`Scene(name, context)`

并在 `Scene` 基类里新增 4 个“请求接口”：

- `requestPopScene()`
- `requestPushScene(std::unique_ptr<Scene>&&)`
- `requestReplaceScene(std::unique_ptr<Scene>&&)`
- `quit()`

实现上它们都很薄——就是把事件丢进 dispatcher：

```cpp
// src/engine/scene/scene.cpp
void Scene::requestPopScene() {
    context_.getDispatcher().trigger<engine::utils::PopSceneEvent>();
}
```

> 这里用的是 `trigger()`：立即调用订阅者。因为订阅者只会设置“挂起动作”，不会立刻改 scene stack，所以是安全的。

### 4) SceneManager 订阅事件，并在 update 末尾统一执行

`SceneManager` 在构造时注册事件回调：

- `PopSceneEvent` → `onPopScene()`
- `PushSceneEvent` → `onPushScene(event)`
- `ReplaceSceneEvent` → `onReplaceScene(event)`

这些回调不做实际切换，只设置 `pending_action_` 和 `pending_scene_`：

```cpp
// src/engine/scene/scene_manager.cpp
void SceneManager::onPushScene(engine::utils::PushSceneEvent& event) {
    pending_action_ = PendingAction::Push;
    pending_scene_ = std::move(event.scene);
}
```

真正的切换发生在 `update()` 的末尾：`processPendingActions()`。

另外还有一个很实用的小细节：如果弹出了最后一个场景，就自动退出游戏：

```cpp
// src/engine/scene/scene_manager.cpp
if (scene_stack_.empty()) {
    context_.getDispatcher().enqueue<engine::utils::QuitEvent>();
}
```

这里选择 `enqueue()` 的原因是：我们正在执行 `popScene()`（属于 SceneManager 更新流程），更稳妥的方式是把“退出”延迟到本帧末尾由 `dispatcher_->update()` 统一处理。

### 5) 用 GameScene 做一个“事件驱动切场景”的最小演示

为了验证整套链路，本节把 `GameScene` 变成一个“场景切换测试器”：

- `J`：Replace（替换当前场景）
- 鼠标左键：Push（压栈）
- 鼠标右键：Pop（出栈）
- `P`：Quit（退出游戏）

对应实现是：输入信号 → 调用 `requestPushScene/...` → dispatcher 分发 → SceneManager 挂起 → update 末尾执行切换。

## ✅ 本节小结

- 用 `entt::dispatcher` 建立了引擎级事件总线，并放进 `Context` 作为“共享能力”
- Scene 不再依赖 SceneManager：切场景改为“发事件”
- SceneManager 只负责订阅事件并在安全时机执行 `Push/Pop/Replace`
- `enqueue + dispatcher.update()` 让我们可以把某些操作延迟到“帧末尾统一处理”，时序更稳定

## 🔍 自检清单

- [ ] 启动后按 `J`：出现 “切换场景” 日志（Replace）
- [ ] 鼠标左键点击：不断压入场景，看到场景编号递增（Push）
- [ ] 鼠标右键点击：弹出场景，直到最后一个场景弹出后自动退出（Pop + QuitEvent）
- [ ] 按 `P`：无论当前栈里有多少场景都能退出（QuitEvent）

## ➡️ 下一节预告

下一节（第 09 节）会解决“信号穿透”的问题：当场景栈里有多个场景时，输入信号可能会触发**所有**场景的回调。我们会引入“捕获与中断”的机制，让信号只作用于当前场景，或者可以被某个层级拦截掉。