# 09 捕获与中断信号传递

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1FHyaBeEyh&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1FHyaBeEyh)

## 📖 概述

第 07 节我们把输入做成了信号（`entt::sigh`），第 08 节又引入了事件总线（`entt::dispatcher`）并做到了“事件驱动场景切换”。到这里，框架看起来已经很“事件化”了。

但当我们真的把场景栈跑起来后，会遇到一个很典型的问题：**信号穿透**。

想象一下：

- 你用鼠标左键 `Push` 压入多个场景
- 每个场景在 `init()` 都订阅了同一个动作（例如 `mouse_left`）
- 那么当你再次点击鼠标时——**所有场景的回调都会触发**（因为它们都连接在同一个信号上）

这一节要解决的就是：如何让输入信号“只被当前场景处理”，或者允许某个回调“捕获并中断”后续传播。

![](../本期参考/PPT截图/怪物战争.046.png)

> PPT 第 46 页：信号穿透问题 & 用回调返回值控制“继续/中止”

本节对应代码标签：`09-捕获与中断信号传递`（基线：`08-事件总线与场景切换`）。

## 🎯 学习目标

- 理解为什么会发生“信号穿透”：多个场景都在订阅同一个输入动作
- 学会用 EnTT 的 `sigh::collect()` 收集回调返回值，并在满足条件时中止传播
- 调整输入回调签名为 `bool()`：用返回值表达“是否已处理”
- 顺手完善输入模块：把 SDL_QUIT 统一转成 `QuitEvent`，并缓存逻辑鼠标坐标避免重复计算

## 🧠 思路与设计

### 1) 设计一个“可中断”的信号

第 07~08 节的回调是 `void()`：不返回任何信息，因此也就没法表达“我处理完了，请不要再传下去”。

这一节把信号改成 `bool()`，并约定：

- 返回 `true`：表示“事件已被处理”，应该**中止**继续传播
- 返回 `false`：表示“我没处理”，应该继续让其他订阅者尝试处理

这样就能用一个非常通用的模式来解决“穿透”：

- 场景栈顶（当前场景）的回调返回 `true`
- 栈底或非当前场景的回调即使存在，也会被“中断”而不再执行

> EnTT 信号的一个重要细节：通常是“后绑定先调用”（LIFO）。这恰好符合场景栈：新场景后绑定、优先响应。

### 2) 从 `publish()` 到 `collect()`：用返回值控制传播

EnTT 的 `sigh` 支持 `collect`：它会依次调用所有回调，并把每个回调的返回值传给一个收集器（collector）。当 collector 返回 `true` 时，停止继续分发。

所以我们的实现策略是：

- `InputManager` 内部不再 `publish()`（无返回值）
- 改为 `collect([](bool result){ return result; })`
  - 任何回调返回 `true`，就立即停止

这相当于把“捕获/中断”的控制权交给了订阅者（场景/系统/UI）。

## 🔧 实现步骤

### 1) InputManager：把信号类型改成 `bool()`

核心数据结构从：

- `std::array<entt::sigh<void()>, 3>`

变成：

- `std::array<entt::sigh<bool()>, 3>`

对应地，`onAction(...)` 返回的 sink 也随之改成 `entt::sink<entt::sigh<bool()>>`。

### 2) InputManager：分发回调时使用 `collect` 中断传播

原来第 07 节是：

- `publish()`：无条件把所有回调都触发一遍

现在改成：

```cpp
// src/engine/input/input_manager.cpp
it->second.at(static_cast<size_t>(state)).collect([](bool result) {
    return result; // 任一回调返回 true，则停止继续分发
});
```

并在代码注释里明确了两条关键规则：

- collector 的返回值为 `true` → 停止分发
- 调用顺序为“后绑定先调用”

这两条合起来，就是“场景栈顶捕获输入”的基础。

### 3) GameScene：回调返回 `true` 表示捕获

为了配合新的信号签名，`GameScene` 把几个输入回调从 `void` 改为 `bool`，并在处理后返回 `true`：

```cpp
bool GameScene::onPush() {
    requestPushScene(std::make_unique<game::scene::GameScene>(context_));
    return true; // 我处理了这个输入，不要再往下传
}
```

如果你未来有“输入透传”的需求（例如 UI 没处理就交给游戏场景），只要在 UI 回调里返回 `false` 即可。

### 4) 顺手整理：统一 Quit 流程 & 优化鼠标逻辑坐标

这一节还做了两点小的工程优化：

**（1）统一 Quit：InputManager 直接发 `QuitEvent`**

`InputManager` 新增 `dispatcher_` 指针，并提供 `quit()`：

- `SDL_EVENT_QUIT`（窗口关闭）→ `InputManager::quit()` → `dispatcher_->trigger<QuitEvent>()`

这样退出事件就统一走事件总线，不再需要 `GameApp` 轮询 `shouldQuit()`。

**（2）缓存逻辑鼠标坐标**

之前 `getLogicalMousePosition()` 每次调用都要做一次 `SDL_RenderCoordinatesFromWindow` 计算。

现在改为：在鼠标移动/点击事件发生时更新 `logical_mouse_position_`，查询时直接返回缓存值：

- “每帧最多计算一次”，避免重复转换。

## ✅ 本节小结

- 通过把输入回调从 `void()` 升级为 `bool()`，我们获得了“捕获/中断传播”的能力
- `InputManager` 使用 `sigh::collect()` 收集回调返回值：任意回调返回 `true` 即停止分发，解决“信号穿透”
- 借助“后绑定先调用”的顺序，新压入的场景天然优先处理输入，更符合场景栈直觉
- Quit 也统一走 dispatcher；鼠标逻辑坐标做了缓存优化

## 🔍 自检清单

- [ ] 连续 `Push` 多个场景后，点击鼠标左键：只触发当前（栈顶）场景的回调，不再出现多个场景同时响应
- [ ] 关闭窗口触发 SDL_QUIT：能通过 `QuitEvent` 正常退出
- [ ] 需要“透传”的场景：把上层回调返回 `false`，确认下层仍能收到输入

## ➡️ 下一节预告

下一节（第 10 节）会引入“哈希字符串”：把动作名/事件名等字符串在编译期或运行期映射为更高效的整数 ID，用于更快的比较与查找，也为后续 ECS 与数据驱动打基础。