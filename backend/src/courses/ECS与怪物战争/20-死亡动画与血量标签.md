# 20 死亡动画与血量标签

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1KzSLB1Ef4&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1KzSLB1Ef4)

## 📖 概述

上一节我们已经把“远程攻击 → 投射物飞行 → 命中结算”打通了，但还有两个非常明显的体验问题：

1) **敌人死亡太突兀**：血量归零后实体直接消失，看起来像“被瞬间删除”，缺少反馈。  
2) **看不出单位状态**：玩家/敌人血量只能靠日志推测，战斗信息不直观。  

这一节我们补齐两块“战斗表现层”的关键拼图：

- **死亡动画（死亡特效实体）**：敌人死亡后，删除原角色实体；同时创建一个“只展示、不交互”的特效实体，播放一次 `damage` 动画，动画结束自动清理。
- **血量标签（地图血量条）**：为单位绘制简单血条，只在受伤时显示，并用颜色提示剩余血量比例。

![](../本期参考/PPT截图/怪物战争.076.png)

> PPT 第 76 页：死亡动画（特效实体 + 一次性标签）与血量标签（标签 + 统一常量）

本节对应代码标签：`20-死亡动画与血量标签`（基线：`19-远程攻击与弹道`）。

## 🎯 学习目标

- 用事件驱动的方式触发死亡特效（`EnemyDeadEffectEvent` → `EffectSystem`）
- 用实体工厂创建“只播放一次动画”的特效实体，并在动画结束后自动删除
- 为角色添加“可显示血条”的标签（`HasHealthBarTag`），并用专门系统渲染血量条（`HealthBarSystem`）
- 在渲染层补齐“画矩形”的能力（`Renderer::drawRect / drawFilledRect`），支撑简单 HUD 表现

## 🧠 思路与设计

### 1) 为什么要“死亡特效实体”，而不是在原实体上播死亡动画？

敌人死亡后，逻辑上我们希望它 **立刻退出战斗系统**：

- 不再参与寻路/阻挡/锁定
- 不再被攻击、也不再阻挡别人

如果继续保留原敌人实体，只是切换动画，很容易出现“死了还在被锁定/还在阻挡”的边界问题。

因此更简单、也更稳妥的做法是：

- **原敌人实体**：打上 `DeadTag`，交给 `RemoveDeadSystem` 删除（逻辑立刻结束）
- **死亡特效实体**：只负责展示（Transform + Sprite + Animation），播放一次性动画，结束后自删

### 2) 血量条如何做到“统一、简单、低侵入”？

血量条本质是渲染问题：它不需要新组件，也不需要参与 ECS 的各种逻辑系统。

我们只需要两件事：

- **标签**：`HasHealthBarTag` 表示“这个实体需要血条”；`InjuredTag` 表示“受伤了才显示”
- **常量**：统一的尺寸/偏移（`HEALTH_BAR_SIZE / HEALTH_BAR_OFFSET_Y`），避免每个角色各写一套

渲染时再根据血量百分比选择颜色，画两个矩形（边框 + 填充）即可。

## 🔧 实现步骤

## 🏷️ 1) 新增标签与常量：一次性特效、血量条

本节在 `src/game/defs/tags.h` 新增两个标签：

- `OneShotRemoveTag`：标记“这是一次性实体（如死亡特效）”，动画播完就删除
- `HasHealthBarTag`：标记“这个实体有血量条”

并在 `src/game/defs/constants.h` 增加统一的血条配置：

```cpp
constexpr glm::vec2 HEALTH_BAR_SIZE = {48.0f, 8.0f};
constexpr float HEALTH_BAR_OFFSET_Y = 8.0f;
```

## 🧱 2) 在 Renderer 中支持画矩形（血量条的基础能力）

原来的渲染系统主要面向精灵绘制；血量条需要更“原始”的图元支持。

本节在 `src/engine/render/renderer.h/.cpp` 增加两个接口：

- `drawFilledRect(...)`：画填充矩形
- `drawRect(...)`：画边框（支持 thickness）

为了更方便地取颜色，又在 `src/engine/utils/math.h` 里为 `FColor` 增加了一组预设颜色方法：

```cpp
engine::utils::FColor::green();
engine::utils::FColor::orange();
engine::utils::FColor::red();
```

> 这样 `HealthBarSystem` 就能直接用“语义化颜色”表达血量状态，而不需要到处手写 RGBA。

## ❤️ 3) HealthBarSystem：只在受伤时绘制血条

本节新增 `src/game/system/health_bar_system.*`，核心逻辑是：

- 只遍历同时满足 `Transform + Stats + HasHealthBarTag + InjuredTag` 的实体（满血不显示，减少干扰）
- 用 `hp/max_hp` 计算血量比例，并按比例裁剪填充矩形宽度
- 按血量百分比给出颜色（绿/橙/红）

关键片段（`src/game/system/health_bar_system.cpp`）：

```cpp
auto health_percent = static_cast<float>(stats.hp_) / static_cast<float>(stats.max_hp_);
renderer.drawRect(camera, position, size, color);
size.x = size.x * health_percent;
renderer.drawFilledRect(camera, position, size, color);
```

## 🧩 4) 给单位打上 HasHealthBarTag（由工厂统一添加）

血量条属于“所有单位都通用的表现”，所以最合适的入口就是实体工厂。

本节在 `EntityFactory::createPlayerUnit()` 和 `EntityFactory::createEnemyUnit()` 末尾补了一行：

- `registry_.emplace<game::defs::HasHealthBarTag>(entity);`

这样新创建的单位天然具备血条能力；至于“显示与否”，交给 `InjuredTag` 控制。

## 💥 5) 死亡特效的事件：EnemyDeadEffectEvent

敌人死亡发生在 `CombatResolveSystem` 的结算阶段，所以最自然的触发点也是它。

本节新增事件 `EnemyDeadEffectEvent`（`src/game/defs/events.h`）：

```cpp
struct EnemyDeadEffectEvent {
    entt::id_type class_id_{entt::null};
    glm::vec2 position_{};
    bool is_flipped_{false};
};
```

它携带的信息非常克制：**只给“创建特效实体”所需的最小数据**。

## 🧮 6) CombatResolveSystem：敌人死亡时发出特效事件

在敌人死亡分支里，我们除了打 `DeadTag`，还要发送死亡特效事件。

为了创建特效，需要知道三件事：

- 这个敌人是什么类型（`ClassNameComponent.class_id_`）
- 它死在哪（`TransformComponent.position_`）
- 当前精灵是否翻转（`SpriteComponent.sprite_.is_flipped_`）

拿到这些信息后，直接 `enqueue(EnemyDeadEffectEvent{...})` 即可。

## ✨ 7) EffectSystem + EntityFactory：创建一次性死亡特效实体

本节新增 `EffectSystem`：

- 订阅 `EnemyDeadEffectEvent`
- 回调里调用 `EntityFactory::createEnemyDeadEffect(...)`

而真正的“如何创建特效实体”，放在工厂里更合适：

- `createEnemyDeadEffect()` 会从敌人蓝图中取 `sprite_` 与动画表
- 约定：死亡动画使用敌人数据里的 `damage` 动画（PPT 也强调这一点）
- 特效实体只添加展示所需组件，并打上 `OneShotRemoveTag`

为了让“特效实体”只包含一个动画，本节在工厂中补了一个辅助函数 `addOneAnimationComponent(...)`：创建一个只含单动画的 `AnimationComponent`，默认不循环（loop=false）。

## 🧹 8) 动画结束自动删除：AnimationStateSystem 处理 OneShotRemoveTag

要让死亡特效能“播完自删”，我们需要一个统一收口点。

上一节已经有 `AnimationFinishedEvent`（动画播完会触发），本节在 `AnimationStateSystem::onAnimationFinishedEvent()` 中加了判断：

- 如果实体有 `OneShotRemoveTag`：直接打 `DeadTag`，交给 `RemoveDeadSystem` 清理

这样特效实体不会残留，也不会让工厂/系统再写一套计时逻辑。

## 🖼️ 9) GameScene：渲染顺序补齐（先单位、再血条）

血量条属于“叠加信息”，所以渲染顺序应该在单位之后：

1) `RenderSystem` 渲染所有精灵（单位/投射物/特效）
2) `HealthBarSystem` 渲染血条

本节在 `GameScene::render()` 中显式调用了 `health_bar_system_->update(...)`，并在 `initSystems()` 创建 `EffectSystem` 与 `HealthBarSystem`。

## ✅ 本节小结

- 敌人死亡的“逻辑结束”与“视觉表现”被拆成两条链路：敌人实体立刻删除，死亡特效实体负责播放一次性动画
- 血量条通过 `HasHealthBarTag + InjuredTag + 常量` 实现，侵入性低、规则统一
- 渲染层补齐矩形绘制接口，让后续更多“简单 HUD”有了实现基础

## 🔍 自检清单

- [ ] 敌人死亡后是否能看到 `damage` 死亡动画（特效实体），并在动画结束后消失
- [ ] 敌人死亡后是否不再参与阻挡/锁定等逻辑（原实体已打 `DeadTag`）
- [ ] 角色受伤后是否显示血条，且颜色能随血量比例变化（绿/橙/红）
- [ ] 满血角色是否不显示血条（减少画面干扰）

## ➡️ 下一节预告

- 下一节我们会开始做“出击选择角色肖像”：在游戏内 UI 中展示玩家拥有的角色列表，并准备把“出击/部署”做成可交互的流程。
