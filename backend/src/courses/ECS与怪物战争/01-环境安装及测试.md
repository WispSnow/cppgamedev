# 01 环境安装及测试

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1D34mzeEsE&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1D34mzeEsE)

## 📖 概述

从这一期开始，我们会频繁地“改一点、编译一下、马上验证效果”。所以第一节课先把**开发环境**和**构建流程**跑通，并且把第三方库的集成方式讲清楚：你不需要手动到处装库，也不需要把工程文件拷来拷去。

本节完成后，你应该能做到：

- 能在本机把 `MonsterWar` 代码编译通过
- 能运行起来并看到窗口/画面（哪怕只是最简场景）
- 遇到依赖下载失败时，知道怎么切换到“离线集成”的方案

## 🎯 学习目标

- 准备好最小工具链：C++ 编译器 + CMake + Git
- 学会用 CMake 的标准三连完成构建：配置（configure）→ 编译（build）→ 运行（run）
- 理解本项目的“智能依赖获取”策略：优先本机 → 其次本地源码 → 最后在线拉取

## 🧰 准备工具（最小集合）

- **CMake**：版本不低于 `3.10`
- **C++20 编译器**：
  - Windows：Visual Studio 2022（或同等级 MSVC 工具链）
  - macOS：Xcode Command Line Tools（clang）
  - Linux：gcc/clang + 基本构建工具
- **Git**：用来拉取仓库、切换课节 tag
- （可选）VS Code：配合 CMake Tools 插件体验更顺

## 🏗️ 获取代码与切换课节

仓库的每一节课都会对应一个 git tag（例如 `01-环境安装及测试`、`02-EnTT基础`），这样你可以精确对齐视频进度。

```bash
git clone https://github.com/WispSnow/MonsterWar.git
cd MonsterWar

# （可选）切到第 01 节的代码状态
git checkout 01-环境安装及测试
```

> 如果你只是想先把最新版跑通，也可以不切 tag；但跟课时建议始终对齐对应 tag。

## 🔧 一键编译（推荐）

本项目使用 CMake 管理依赖与构建流程。最常用的构建方式就是这三条命令：

```bash
cmake -S . -B build
cmake --build build
```

在 Windows（Visual Studio 多配置生成器）上，你可能更常用下面这种写法来指定配置：

```bash
cmake --build build --config Release
```

编译完成后，可执行文件通常在：

- Windows：`build/Debug/` 或 `build/Release/`
- macOS / Linux：`build/`

## 🧩 依赖库是怎么“自动集成”的？

这一期课程的依赖比较多（SDL3 全家桶、glm、spdlog、json、EnTT、以及 ImGui），如果每个库都让你手动安装，很容易在第一节课就劝退。

所以在 `CMakeLists.txt` 里我们做了一个“智能依赖获取”的策略（原注释如下）：

```cmake
# - 依赖库会自动智能选择获取方式：
#   1. 优先使用系统已安装的库（find_package）
#   2. 如果本地external/目录存在源码，则使用本地源码编译
#   3. 否则自动从GitHub在线获取并编译
# - 国内用户可从课程网盘下载依赖库放入external/目录，避免网络问题
```

你可以把它理解成一个兜底链路：

1. **你机器上已经装过库**：CMake 会优先 `find_package(...)` 直接用（最快）
2. **你把依赖源码放进 `external/`**：就离线编译依赖（更稳定）
3. **都没有**：才使用 `FetchContent` 去 GitHub 拉取并编译（最省事，但依赖网络）

> 如果你在国内网络下拉取依赖经常失败，优先选第 2 种：把网盘里的依赖源码解压到 `external/`，再重新执行 `cmake -S . -B build`。

## ✅ 运行与验证（到这一步就算环境 OK）

你不需要在第一节课就理解全部系统，只要确认“能跑起来”：

- 运行编译产物，看是否能正常打开窗口/进入游戏画面
- 如果运行时报 “找不到资源/贴图/音频”，优先检查可执行文件同目录是否有 `assets/`
  - 工程里已经做了**自动拷贝资源**的处理；通常重新编译一次就能把资源同步过去
- Windows 下如果报 “缺少某某 DLL”，一般是动态库没被放到可执行文件目录
  - 工程里也做了**DLL 自动检测与复制**；建议先用干净的 `build/` 目录重新构建验证

## ✅ 本节小结

- 用 CMake 三连跑通构建：`cmake -S . -B build` + `cmake --build build`
- 依赖集成采用“本机/本地/在线”三级策略：能跑通一次，后面每节课才能放心迭代

## ➡️ 下一节预告

下一节我们会进入 **EnTT 基础**：先把 ECS 的最小用法跑通（实体、组件、Registry），为后续的大规模重构打地基。
