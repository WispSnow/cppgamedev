# 05 游戏框架改进

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1SNWozUE3m&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1SNWozUE3m)

## 📖 概述

这一节是**纯理论课**：没有对应的代码 tag。它的作用是把“为什么下一节要从框架入手重构”讲清楚，让你在进入第 06 节写代码之前，对整体方向有一个统一的认识。

本节主要依据：

- `Lecture/本期参考/transcribe-05.txt`
- `Lecture/本期参考/课程PPT.pdf`（必要时可看 `Lecture/本期参考/PPT截图/`）

<img src="https://theorhythm.top/gamedev/MW/怪物战争.028.webp" style='width: 800px;' />

> PPT 第 28 页：上一期《阳光岛》的框架结构（Game/Scene/GameObject/Component 的调用链）

## 🎯 学习目标

- 复盘上一期“组件 + GameObject”框架的两个核心问题：**数据分散**与**组件交互成本**
- 理解“轮询式 handleInput 链”为什么不够理想，以及“事件驱动”的收益
- 明确本期框架调整方向：输入事件化、游戏对象迁移到 ECS、UI 保持传统结构、ImGui 作为调试系统叠加

## 🧠 核心观点

### 1) 组件模式的痛点：数据分散 + 组件交互困难

上一期我们用的是典型的 `GameObject + Component` 模式。它在入门阶段非常直观，但随着功能变多会暴露一些结构性问题。

**（1）数据存放分散，缓存命中率低**

组件是分散地挂在各个对象上的，更新系统时往往需要不断跳转到不同对象/组件的内存位置，CPU 缓存利用率并不高。

**（2）组件交互：缓存指针 vs 动态查询，各有代价**

以 `PlayerComponent` 为例，它更新时可能依赖音频、动画、渲染等多个组件。你想要“拿到其他组件”，通常只有两条路：

- **缓存指针（创建时保存引用）**：访问快，但会占用额外空间；更麻烦的是，如果某个组件在运行时被移除/替换，缓存指针会带来安全性隐患（需要频繁检查有效性）
- **通过 owner 动态查询（`getOwner()->getComponent<>()`）**：更安全、逻辑更清晰，但每次访问都要绕一层（先找 owner，再查组件），频繁调用会更慢

这两条路本质上是在“性能、空间、安全性、可维护性”之间做取舍；而当项目复杂度上来后，这个取舍会越来越难受。

### 2) 轮询 vs 事件驱动：把“每帧调用”变成“变化才触发”

上一期框架里有一条典型的 `handleInput()` 调用链：每帧都从 Game → Scene → GameObject → Component 逐层调用，哪怕这一帧根本没有任何按键变化也照样走一遍。

这就是“轮询”：

- 好处：简单直接
- 问题：不必要的调用很多；更重要的是，输入逻辑会被迫分散在一长串链路里

我们更希望的模式是：**只有输入发生变化时，才触发对应逻辑**（事件驱动）。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.029.webp" style='width: 800px;' />

> PPT 第 29 页：在 InputManager 的 `update()` 中更新输入并发送信号；在需要的系统/UI 中订阅信号

实现上，我们已经在第 03 节学过 EnTT 的信号/事件体系。把它用在输入上，就是：

- `InputManager::update()` 里检测“按键是否变化”
- 变化则发布信号/事件（例如 `KeyDown/KeyUp`）
- 需要响应的模块订阅它（场景、系统、UI 都可以）

这样一来，原本那条“每帧都要走一遍”的 `handleInput()` 链，很多时候就可以删掉了。

> 当然，轮询并非一无是处：例如鼠标位置这类“需要持续查询的状态”，轮询依然更直接。只是不必单独保留一条 `handleInput()` 链去做轮询，把必要的查询放进 `update()` 即可。

### 3) 本期框架改进路线：ECS + 系统化更新，但 UI 不做 ECS

综合上面的分析，本期框架会做几个关键调整：

**（1）游戏对象迁移到 ECS**

从第 06 节开始，我们会把 GameObject/Component 的主体逻辑迁移到 ECS：场景的 `update()` 变成“依次调用各个系统的 `update()`”，实体通过“多轮系统更新”逐步得到最终效果。

**（2）UI 继续保持传统结构**

UI 的首要诉求不是“极致运行效率”，而是“开发效率高、搭得快、容易改”。ECS 适合大量同构实体的批处理更新，但 UI 往往是层级关系明显、交互逻辑更复杂的少量对象。主流引擎的 UI 也通常不会使用 ECS。

所以这一期我们只会对 UI 做必要的适配，不把它强行 ECS 化。

**（3）物理引擎移除（塔防俯视角不需要）**

本期是俯视角塔防玩法，物理引擎的收益不大，因此直接删除。将来如果你的游戏需要物理，引入 ECS 后的物理也会更自然：它会变成一个独立的“物理系统”。

**（4）ImGui 作为调试系统：最后渲染、叠加显示**

ImGui 通常是开发阶段用的调试 UI，发布时可能会被移除。集成方式上更适合做成一个系统，并且放在“游戏画面 + 游戏内 UI 都渲染完之后”再渲染，这样它自然叠在最上层：

- 游戏内 UI：属于玩家看到的正式 UI
- ImGui：属于开发调试 UI（临时工具）

## ✅ 本节小结

- GameObject/Component 模式的痛点会随着项目增长越来越明显：数据分散、组件交互成本高
- 输入这类“变化触发”的逻辑，更适合用事件驱动，减少无意义的每帧轮询链路
- 本期的整体方向是：游戏对象迁移到 ECS，UI 保持传统结构，ImGui 作为调试系统叠加在最上层

## ➡️ 下一节预告

从下一节（第 06 节）开始，我们就正式进入代码：先把现有工程做一次“整理与复用”，删掉不需要的模块（如物理），并为后续 ECS 重构打好基础。