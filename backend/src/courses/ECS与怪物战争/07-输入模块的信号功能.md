# 07 输入模块的信号功能

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1D8s1zdEyn&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1D8s1zdEyn)

## 📖 概述

在上一期《阳光岛》的框架里，输入大多通过“轮询”使用：每一帧你都去问 `InputManager` ——“某个动作是否按下/是否抬起/是否持续按着”。这套方式能跑，但会把输入处理逻辑拆散到各处，并且容易形成一条“每帧都要走一遍”的 `handleInput()` 调用链。

这一节我们把输入模块升级为“信号驱动”：

- `InputManager::update()` 里负责**检测状态变化**
- 一旦某个动作进入 `PRESSED/HELD/RELEASED` 状态，就通过 EnTT 的 `sigh/sink` **发布信号**
- 需要响应输入的系统/场景只要订阅即可，不必每帧轮询

本节对应代码标签：`07-输入模块的信号功能`（基线：`06-代码的复用与整理`）。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.037.webp" style='width: 800px;' />

> PPT 第 37 页：把“具体按键/鼠标按钮”映射为“抽象动作”，每个动作都有“按下/持续/抬起”的状态

## 🎯 学习目标

- 理解输入映射的两层结构：`Config`（动作 → 按键名）→ `InputManager`（输入 → 动作列表）
- 学会为动作注册回调：`onAction(action, state).connect(...)`
- 理解 `InputManager::update()` 的三段式流程：**状态推进 → 事件处理 → 发布回调**
- 认识“轮询 + 信号”可以共存：需要时仍可用 `isActionPressed/Down/Released`

## 🧠 思路与设计

### 1) 为什么要做成信号？

对输入来说，绝大多数逻辑是“变化触发”的：只有发生按下/松开时，才需要做事。把它写成信号有三个直接收益：

- **减少无意义调用**：没有输入变化时，不必让各处 `if (isActionPressed(...))` 都跑一遍
- **降低耦合**：场景/系统只关心“动作发生了”，不关心按键来自键盘还是鼠标
- **更符合后续架构**：下一节会引入事件总线与场景切换，输入信号就是最自然的“事件源”之一

### 2) 两种用法同时保留：轮询 & 订阅

这节的实现并没有把“轮询接口”删掉，而是把它变成**可选项**：

- 若你需要“某动作是否持续按下”这类状态查询：继续用 `isActionDown(...)`
- 若你只关心“按下/抬起”这一瞬间：用 `onAction(...).connect(...)` 更直接

<img src="https://theorhythm.top/gamedev/MW/怪物战争.038.webp" style='width: 800px;' />

> PPT 第 38 页：InputManager 保留查询接口（轮询），同时在动作触发时发送信号并绑定外部函数

### 3) API 设计：为什么返回 `entt::sink`？

本节对外提供的接口是：

```cpp
entt::sink<entt::sigh<void()>> onAction(std::string_view action_name,
                                       ActionState action_state = ActionState::PRESSED);
```

`sink` 的意义是“只给你连接/断开”的权限，而不是把 `sigh` 本体暴露出去。也就是说：

- 外部：只能 `connect / disconnect`
- `InputManager` 内部：负责 `publish()`

这样“谁是事件源”非常明确，也更不容易被误用。

## 🔧 实现步骤

### 1) 从 `Config` 建立映射：动作 → 输入

输入模块的第一层抽象仍然来自配置：`Config::input_mappings_` 是“动作名 → 按键名列表”的映射（默认值在头文件里给了一套）。

例如（节选）：

```cpp
// src/engine/core/config.h
std::unordered_map<std::string, std::vector<std::string>> input_mappings_ = {
    {"jump", {"J", "Space"}},
    {"attack", {"K", "MouseLeft"}},
};
```

`InputManager::initializeMappings()` 会把这份配置转换为运行时更好用的结构：

- `action_states_`：动作当前状态（`PRESSED/HELD/RELEASED/INACTIVE`）
- `input_to_actions_`：输入（`SDL_Scancode` 或 `MouseButton`）→ 动作列表

另外它还补充了 UI 常用的默认动作（如果配置里没写就自动加）：

- `mouse_left` → `MouseLeft`
- `mouse_right` → `MouseRight`

### 2) 增加“动作回调表”：一个动作三种信号

核心数据结构是：

```cpp
// src/engine/input/input_manager.h
std::unordered_map<std::string, std::array<entt::sigh<void()>, 3>> actions_to_func_;
```

含义是：每个动作名都对应 3 个信号槽位，分别代表：

- `PRESSED`（本帧刚按下）
- `HELD`（持续按下）
- `RELEASED`（本帧刚抬起）

`ActionState::INACTIVE` 被放在枚举末尾，并且不参与数组索引（数组只有 3 个槽位）。

### 3) 提供对外接口：`InputManager::onAction(...)`

对外注册回调时，`InputManager` 返回一个 `sink`：

```cpp
// src/engine/input/input_manager.cpp
entt::sink<entt::sigh<void()>> InputManager::onAction(std::string_view action_name,
                                                      ActionState action_state) {
    // 如果 action_name 不存在，operator[] 会自动创建一组 sigh（懒加载）
    return actions_to_func_[std::string(action_name)].at(static_cast<size_t>(action_state));
}
```

### 4) 在 `update()` 里发布信号（最关键）

`InputManager::update()` 被拆成三段：

1. 推进状态：`PRESSED → HELD`，`RELEASED → INACTIVE`
2. 处理 SDL 事件：按键/鼠标事件会调用 `updateActionState(...)` 更新 `action_states_`
3. 发布回调：对非 `INACTIVE` 的动作发布对应信号

（节选）

```cpp
// src/engine/input/input_manager.cpp
void InputManager::update() {
    for (auto& [action_name_id, state] : action_states_) {
        if (state == ActionState::PRESSED) state = ActionState::HELD;
        else if (state == ActionState::RELEASED) state = ActionState::INACTIVE;
    }

    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        processEvent(event);
    }

    for (auto& [action_name_id, state] : action_states_) {
        if (state != ActionState::INACTIVE) {
            if (auto it = actions_to_func_.find(action_name_id); it != actions_to_func_.end()) {
                it->second.at(static_cast<size_t>(state)).publish();
            }
        }
    }
}
```

这也解释了为什么“信号驱动”不会破坏旧逻辑：`action_states_` 仍然存在，查询接口也仍然有效。

### 5) 在场景中订阅/解除订阅

本节用 `GameScene` 做了一个最小演示：把 `attack` 的按下、`jump` 的抬起分别绑定到两个成员函数。

```cpp
// src/game/scene/game_scene.cpp
void GameScene::init() {
    auto& input_manager = context_.getInputManager();
    input_manager.onAction("attack").connect<&GameScene::onAttack>(this);
    input_manager.onAction("jump", engine::input::ActionState::RELEASED).connect<&GameScene::onJump>(this);
}

void GameScene::clean() {
    auto& input_manager = context_.getInputManager();
    input_manager.onAction("attack").disconnect<&GameScene::onAttack>(this);
    input_manager.onAction("jump", engine::input::ActionState::RELEASED).disconnect<&GameScene::onJump>(this);
}
```

这里的约定非常重要：**谁 connect，谁 disconnect**。否则场景退出后回调还在，会导致“访问已销毁对象”的风险。

为了看到日志输出，`main.cpp` 里把日志级别调整为了 `info`：

- `spdlog::set_level(spdlog::level::info);`

## ✅ 本节小结

- 输入系统仍然以“动作（Action）”为抽象单位：配置定义映射，运行时把具体按键/鼠标事件转换为动作状态
- 在此基础上新增“信号接口”：`onAction(action, state)`，把“变化触发”的逻辑写成订阅回调
- 轮询接口仍被保留，用于少量需要“持续状态查询”的地方

## 🔍 自检清单

- [ ] 运行程序后按下 `K` 或点击鼠标左键：控制台输出 `onAttack`
- [ ] 松开 `J` 或 `Space`：控制台输出 `onJump`（因为示例绑定的是 `RELEASED`）
- [ ] 没有任何输入时：不会触发回调，但仍会推进 `ActionState`（`PRESSED → HELD` 等）

## ➡️ 下一节预告

下一节（第 08 节）我们会把“输入信号”进一步提升为“事件总线”，并在引擎层实现**场景切换**：

- 事件源不只来自输入，也可以来自任意系统（例如 UI 按钮、游戏逻辑）
- 场景切换不再依赖直接调用，而是通过事件请求（Push/Pop/Replace）