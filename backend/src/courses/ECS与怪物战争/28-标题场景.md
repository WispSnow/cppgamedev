# 28 标题场景

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1GUBHBCEgt&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1GUBHBCEgt/)

## 📖 概述

到第 27 节为止，我们的“主场景 GameScene”已经很像一个完整的塔防关卡了：能出击、能放技能、能刷波次、还能用 ImGui 调试和操作。但游戏的流程仍然缺了一块关键拼图——**入口**。

这一节我们要把启动流程从“直接进 GameScene”升级为“先进入标题场景”，并在标题场景提供最基本的交互入口：

- 开始游戏（进入关卡）
- 确认角色（查看/升级角色信息，后续可做上阵配置）
- 载入游戏（读档）
- 退出游戏

![](../本期参考/PPT截图/怪物战争.095.png)

> PPT 第 95 页：标题场景

本节对应代码标签：`28-标题场景`（基线：`27-完善主场景`）。

## 🎯 学习目标

- 新增 `TitleScene`，并把它设为游戏启动的初始场景
- 在标题场景加载一个专用 Tiled 地图：`assets/maps/title.tmj`（作为标题背景/摆件的承载）
- 把“会跨场景复用的资源与配置”整理成共享指针并传递：`BlueprintManager / SessionData / UIConfig / LevelConfig`
- 扩展 `DebugUISystem`：支持在标题场景渲染 Logo + 按钮，并复用“角色表格 / 读档面板”这些 UI 模块

## 🧠 思路与设计

标题场景的价值不只是“多一个界面”，而是把游戏的整体流程组织起来：

1) **先准备数据，再进入玩法场景**  
标题场景负责初始化“会反复用到的数据”（角色、蓝图、关卡配置、UI 配置），进入 `GameScene` 时直接复用，避免每次重进关卡都重复加载。

2) **先用 ImGui 快速做功能入口**  
这一阶段目标是把流程跑通，所以按钮与面板先用 ImGui 实现；将来再替换成游戏内 UI（`UIManager` + 自己的控件系统）。

3) **用最少的系统跑起标题地图**  
标题地图也需要渲染与动画（比如标题摆件动起来），所以 `TitleScene` 会初始化渲染、动画、移动、YSort 等基础系统，但不包含战斗/刷怪等核心玩法系统。

## 🔧 实现步骤

## 🎬 1) 启动入口：初始场景切到 TitleScene

在 `src/main.cpp`，把“启动时 push 的场景”从 `GameScene` 改为 `TitleScene`：

```cpp
auto title_scene = std::make_unique<game::scene::TitleScene>(context);
context.getDispatcher().trigger<engine::utils::PushSceneEvent>(
    engine::utils::PushSceneEvent{std::move(title_scene)}
);
```

这样一运行程序，就会先进入标题，而不是直接开打。

## 🗺️ 2) 新增 TitleScene：加载标题关卡 + 初始化基础系统

本节新增文件：

- `src/game/scene/title_scene.h`
- `src/game/scene/title_scene.cpp`

`TitleScene::init()` 的顺序非常“标题场景化”：

1) 初始化/复用共享数据（如果外部没传进来，就自己创建并加载）  
`initSessionData()` → `initLevelConfig()` → `initBlueprintManager()` → `initUIConfig()`

2) 加载标题关卡地图  
`loadTitleLevel()` 使用 `engine::loader::LevelLoader` 载入 `assets/maps/title.tmj`

3) 初始化系统  
只创建标题需要的系统：`RenderSystem / YSortSystem / AnimationSystem / MovementSystem / DebugUISystem`

4) 设置游戏状态  
把 `GameState` 切到 `Title`，并重置 `TimeScale` 为 `1.0f`

> 这套顺序的核心是：标题场景只负责“准备与入口”，不要把战斗系统也搬进来。

## 🧾 3) SessionData 增强：为“可排序的角色列表”准备数据结构

标题场景新增了“角色信息表格”（并支持排序）。但 `SessionData` 里存角色用的是 `unordered_map`，天生无序，不适合直接做排序展示。

本节在 `src/game/data/session_data.*` 做了一个很实用的小改造：

- 新增 `std::vector<UnitData*> unit_data_list_`：保存指向 `unit_map_` 值的指针，用于排序与遍历展示
- 新增 `mapUnitDataList()`：在“默认数据加载完成后”把 map 映射到 list
- `addUnit/removeUnit/clear` 时同步维护这个 list

这样 UI 只要对 `unit_data_list_` 做 `std::stable_sort`，就能实现“点击列头排序”。

## 🪟 4) DebugUISystem 扩展：标题 Logo、四个按钮与面板复用

`src/game/system/debug_ui_system.*` 新增了面向标题场景的一条入口：

- `DebugUISystem::updateTitle(TitleScene&)`

在这个入口里，我们渲染三块内容：

1) `renderTitleLogo()`：从 `ResourceManager` 取 `assets/textures/UI/title.png` 并 `ImGui::Image` 显示  
2) `renderTitleButtons()`：四个按钮（开始/确认角色/载入/退出）  
3) `renderUnitInfoUI()` + `renderLoadPanelUI()`：复用“角色表格/读档面板”

这里有一个“方便但耦合更强”的选择：`TitleScene` 把 `DebugUISystem` 设为 `friend`，使得 DebugUI 能：

- 直接读写 `show_unit_info_ / show_load_panel_`
- 直接调用 `TitleScene::onStartGameClick()` 等按钮回调

> 这在快速迭代阶段很高效；后续如果想降低耦合，可以把按钮改成“发事件”，再由场景/系统监听处理。

## 🚪 5) 从标题进入关卡：replace 成 GameScene，并复用已加载的数据

标题场景“开始游戏”按钮最终走到 `TitleScene::onStartGameClick()`：

- 如果是读档进入且 `session_data_->isLevelClear()` 为真，说明存档停在“刚通关”的状态；此时先清掉 `level_clear` 并把关卡号 +1（进入下一关）
- 然后 `requestReplaceScene(std::make_unique<GameScene>(...))`，把共享指针传给 `GameScene`，复用加载结果

这一节做完，我们已经拥有了一个更完整、更像游戏的基本流程：**标题 → 进入玩法场景**。

## ✅ 本节小结

- 新增 `TitleScene` 并作为初始场景，游戏启动流程更完整
- 标题场景载入 `assets/maps/title.tmj`，并以“最少系统集合”渲染与播放动画
- 用共享指针复用 `BlueprintManager / SessionData / UIConfig / LevelConfig`，避免跨场景重复加载
- 扩展 `DebugUISystem` 支持标题 UI：Logo、按钮与角色/读档面板（表格支持排序）

## 🔍 自检清单

- [ ] 运行后能进入标题场景，且标题地图能正常渲染
- [ ] 四个按钮可点击：开始/确认角色/载入/退出（退出能正常关闭程序）
- [ ] “确认角色”能打开角色表格，并可点击列头排序
- [ ] “载入游戏”能打开读档面板，SLOT_1 能成功加载
- [ ] 点击“开始游戏”能进入 `GameScene`，且不会重复加载导致卡顿或崩溃

## ➡️ 下一节预告

下一节我们会补齐“关卡结束之后的流程”：当胜利/失败发生时切到通关结算与结束场景，并把奖励点数、存档入口、背景音乐切换等完整串起来。

