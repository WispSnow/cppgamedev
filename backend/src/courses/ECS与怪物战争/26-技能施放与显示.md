# 26 技能施放与显示

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1E8mCBBEmc&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1E8mCBBEmc/)

## 📖 概述

到上一节为止，我们已经有了 ImGui 调试面板：可以选中单位、查看属性、显示攻击范围。但如果要把玩法推进到“可控的策略选择”，技能系统几乎是绕不开的一步。

这一节我们要做两件事：

1) **技能施放**：技能有冷却、有持续时间；就绪后可以手动激活（或被动自动激活）。  
2) **技能显示**：就绪/激活时在角色头顶显示提示，同时在 ImGui 里能看到技能状态（冷却进度、剩余时间、描述）。

技能效果本身我们先从最通用、最容易验证的方式切入：**Buff 直接修改 `StatsComponent`**，并支持一个“成本恢复（COST regen）”的被动技能。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.092.webp" style='width: 800px;' />

> PPT 第 92 页：技能施放与显示（冷却 → 就绪 → 激活 → 结束；特效显示 + 增益；以及 cost 恢复等）

本节对应代码标签：`26-技能施放与显示`（基线：`25-ImGui显示单位信息`）。

## 🎯 学习目标

- 用 JSON 配置技能与特效：`assets/data/skill_data.json` + `assets/data/effect_data.json`
- 扩展蓝图体系：新增 `SkillBlueprint/BuffBlueprint/EffectBlueprint`，并由 `BlueprintManager` 负责加载
- 给玩家单位添加 `SkillComponent`，并用 Tag 表达技能状态：`SkillReadyTag/SkillActiveTag/PassiveSkillTag`
- 扩展 `TimerSystem`：推进技能冷却/持续计时，并在状态切换时发送事件
- 新增 `SkillSystem`：响应技能事件，创建显示实体、应用/移除 Buff、处理单位移除清理
- 扩展 `EffectSystem`：支持通用 `EffectEvent`（例如治疗特效）
- 在 `DebugUISystem` 中提供技能按钮/快捷键与状态显示

## 🧠 思路与设计

技能系统本质是一个小型“状态机”：

- 冷却中（未就绪）
- 就绪（可施放）
- 激活中（持续时间倒计时）
- 结束（回到冷却中）

我们用两类手段把它做得既清晰又可扩展：

1) **Tag 做状态**：`SkillReadyTag / SkillActiveTag / PassiveSkillTag` 让系统筛选非常直接。  
2) **Event 做切换**：`SkillReadyEvent / SkillActiveEvent / SkillDurationEndEvent` 把“计时器触发”和“技能逻辑/显示”解耦。

另外，特效与技能数据都走蓝图：这样以后要加更多技能/特效，不需要改 C++ 结构，只要补 JSON 即可。

## 🔧 实现步骤

## 🗂️ 1) 数据驱动：技能与特效配置

本节新增两份配置：

- `assets/data/skill_data.json`：技能名称/描述、是否被动、冷却/持续时间，以及 Buff 参数（atk/def/range/atk_interval/cost_regen 等倍率或数值）
- `assets/data/effect_data.json`：特效 sprite sheet、切片 rect、渲染尺寸/偏移、动画帧序列与帧间隔

例如技能（节选）：

```json
{
  "power_up": {
    "name": "威能",
    "passive": false,
    "atk": 1.5,
    "range": 1.5,
    "cooldown": 20.0,
    "duration": 10.0
  }
}
```

例如特效（节选）：

```json
{
  "skill_active": {
    "sprite_sheet": "assets/textures/FX/skill_active.png",
    "width": 24,
    "height": 24,
    "size_x": 48,
    "size_y": 48,
    "offset_x": -24,
    "offset_y": -24,
    "animation": {"duration":100, "row":0, "frames":[0,1,2,3,4,5,6,7]}
  }
}
```

## 🧱 2) 蓝图扩展：`BlueprintManager` 加载 Skill/Effect

在 `src/game/data/entity_blueprint.h` 新增三类蓝图：

- `EffectBlueprint`：一个特效需要的 sprite + 单动画
- `BuffBlueprint`：对属性倍率/数值的描述（默认值都为“无变化”）
- `SkillBlueprint`：技能基本信息 + Buff + 冷却/持续 + 是否被动

然后在 `BlueprintManager` 中：

- 新增 `loadEffectBlueprints()` / `loadSkillBlueprints()`，并维护容器 `effect_blueprints_ / skill_blueprints_`
- `parsePlayer()` 解析 `player_data.json` 中的 `"skill"` 字段，转成 `skill_id_`
- 新增 `parseOneAnimation()` 解析“单动画特效”
- 新增 `parseBuff()` 从技能 JSON 中提取可选倍率字段

场景初始化时（`GameScene::initEntityFactory()`）也把这两份蓝图加载进来：

```cpp
loadEffectBlueprints("assets/data/effect_data.json");
loadSkillBlueprints("assets/data/skill_data.json");
```

## 🧩 3) 组件与 Tag：把技能挂到玩家单位上

本节新增 `SkillComponent`（`src/game/component/skill_component.h`），保存：

- 技能 id、名称、描述
- 冷却/持续时间及对应计时器
- `display_entity_`：用于显示“就绪/激活”提示的实体

并新增 `CostRegenComponent`（`src/game/component/cost_regen_component.h`）作为一种 Buff 载体：当技能带 cost_regen 时，角色身上会挂这个组件。

`EntityFactory` 增加 `addSkillComponent()`，在创建玩家单位时自动添加技能组件；若技能是被动技能，会额外添加 `PassiveSkillTag` 与 `SkillReadyTag`。

同时工厂新增两个特效创建函数：

- `createEffect(effect_id, position)`：一次性特效（带 `OneShotRemoveTag`）
- `createSkillDisplay(effect_id, position)`：角色头顶循环播放的小标识（用于 skill_ready/skill_active）

显示位置会在 `SkillSystem` 中加上偏移 `SKILL_DISPLAY_OFFSET`（`src/game/defs/constants.h`）。

## ⏱️ 4) 计时器升级：`TimerSystem` 推进技能状态

`TimerSystem` 从“只管攻击冷却”升级为“同时管技能冷却/持续时间”：

- 冷却计时推进：当 `cooldown_timer_ >= cooldown_` 时，加 `SkillReadyTag` 并发送 `SkillReadyEvent`
- 持续计时推进：当 `duration_timer_ >= duration_` 时，发送 `SkillDurationEndEvent`
- 被动技能不参与冷却/持续计时（通过 `exclude<PassiveSkillTag>` 过滤）

这样 `TimerSystem` 只负责“时间推进与状态触发”，不负责“技能做了什么”。

## ✨ 5) 技能系统：显示 + Buff 增删

本节新增 `SkillSystem`（`src/game/system/skill_system.*`），监听：

- `SkillReadyEvent`：创建 `skill_ready` 显示实体
- `SkillActiveEvent`：检查 `SkillReadyTag` 后创建 `skill_active` 显示实体；移除 `SkillReadyTag`、添加 `SkillActiveTag`；并应用 Buff
- `SkillDurationEndEvent`：移除显示实体与 `SkillActiveTag`，并移除 Buff
- `RemovePlayerUnitEvent`：单位移除时顺带清理显示实体，避免悬空特效

Buff 的实现策略很直接：根据 `SkillBlueprint.buff_` 的倍率，直接修改 `StatsComponent` 的字段；如果有 `cost_regen`，则添加/移除 `CostRegenComponent`。

## 💰 6) cost 恢复：让被动技能真正影响关卡资源

`GameRuleSystem` 在原有 cost 自增长基础上，额外遍历 `CostRegenComponent`：

```cpp
game_stats.cost_ += cost_regen.rate_ * delta_time;
```

这样被动技能（例如每秒恢复 cost）就能体现在 `GameStats.cost_` 上，从而间接影响出击 UI 的可用性。

## 🪟 7) ImGui 交互：技能按钮 + 冷却显示

`DebugUISystem` 对“选中单位窗口”补齐了技能显示：

- 如果单位有 `SkillComponent`，会显示技能按钮（快捷键 `S`）
- 只有带 `SkillReadyTag` 时按钮可用；否则显示冷却进度条
- 激活中显示剩余时间；被动技能则显示“被动技能激活中”

按钮触发时会 enqueue `SkillActiveEvent`，把“按按钮”转成事件，交给 `SkillSystem` 真正执行技能逻辑。

## 🌿 8) 特效系统复用：治疗效果

本节把特效事件做成通用版：

- 新增 `EffectEvent{name_id, position, is_flipped}`
- `EffectSystem` 监听它并调用 `EntityFactory::createEffect()`

`CombatResolveSystem` 在治疗结算后，会发一个 `EffectEvent{"heal", target_pos}`，就能在目标位置生成治疗特效。

## ✅ 本节小结

- 技能数据与特效数据完全数据驱动：加技能/改数值优先改 JSON
- 计时器（TimerSystem）与技能逻辑（SkillSystem）解耦，结构更清晰
- 技能状态用 Tag 表达、用 Event 切换：系统筛选与扩展都更自然
- Buff 先走“直接改 Stats + 可选组件（cost_regen）”的简单路线，容易验证，也为后续更复杂技能留出入口

## 🔍 自检清单

- [ ] 玩家单位是否会创建 `SkillComponent`（可在 ImGui 选中窗口看到技能信息）
- [ ] 冷却结束时是否出现 `skill_ready` 头顶提示
- [ ] 按 `S`/点击按钮后是否进入激活状态，且显示 `skill_active` 提示与剩余时间
- [ ] Buff 是否会影响攻击/范围/攻速等数值（可在 DebugUI 中对比）
- [ ] 被动技能单位放下后是否会自动激活，并推动 cost 恢复
- [ ] 治疗事件是否会生成治疗特效（`heal`）

## ➡️ 下一节预告

下一节我们会“完善主场景”：把出击/技能/调试 UI 再整合得更完整（更多操作入口、更清晰的状态与提示），让主场景更接近可玩的版本。

