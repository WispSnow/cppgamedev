# 23 出击准备与出击完成

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1rb2zBfEQb&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1rb2zBfEQb/)

## 📖 概述

上一节我们已经把“出击区域”标出来了（近战/远程放置点），也把 `GameStats` 作为关卡状态跑起来了（cost 自增长 + UI 遮罩联动）。

但距离塔防最关键的一步——**真正把单位部署到地图上**——还差一个“出击系统”：

- 点击底部肖像：进入“出击准备”状态（生成一个**跟随鼠标**的准备单位）
- 鼠标移动：实时检测是否处于合法放置点，并用**颜色反馈**（绿=可放，红=不可放）
- 鼠标左键：在目标放置点创建真实单位、扣 cost、标记放置点已占用，并从 UI 里移除该肖像
- 鼠标右键：取消准备
- 远程单位额外显示攻击范围（放置前预览）

![](../本期参考/PPT截图/怪物战争.085.png)

> PPT 第 85 页：出击准备与确认（准备单位 + 放置点检测 + 左键确认/右键取消）& 远程攻击范围显示（标签 + 系统）

本节对应代码标签：`23-出击准备与出击完成`（基线：`22-出击区域与关卡状态`）。

## 🎯 学习目标

- 用事件把 UI 点击与“出击准备”解耦：`PrepUnitEvent` / `RemoveUIPortraitEvent`
- 区分“准备单位”与“地图单位”：用 `UnitPrepComponent` 承载准备态信息
- 用 `PlaceOccupiedComponent` 管理放置点占用，防止同一地点重复部署
- 实现 `PlaceUnitSystem`：准备、检测、确认、取消、移除的一条龙闭环
- 增加渲染能力：`RenderComponent.color_` 做颜色调整 + `Renderer::drawFilledCircle` 画圆形范围
- 实现 `RenderRangeSystem`：基于 `ShowRangeTag` 渲染远程单位攻击范围预览

## 🧠 思路与设计

这一节我们刻意把“出击”拆成两种实体：

- **准备单位（UnitPrep）**：只用于交互与预览，跟随鼠标移动；它不参与战斗逻辑，也不进入 ECS 的战斗系统筛选。
- **地图单位（PlayerUnit）**：真正部署到地图上的作战单位，拥有完整的组件（Stats/Animation/Combat…）。

这样做的好处是：

- 准备态可以“随时取消/替换”，不污染战斗实体生命周期
- 放置合法性检查只针对“地点实体”（`MeleePlaceTag/RangedPlaceTag`），逻辑集中且可扩展
- 远程范围显示只要给准备态打一个 `ShowRangeTag`，渲染系统就能独立工作

同时，为了让 UI 与系统不互相依赖，我们用事件串起流程：

1) `UnitsPortraitUI` 点击 → `dispatcher.enqueue(PrepUnitEvent)`  
2) `PlaceUnitSystem` 接到事件 → 创建准备单位实体  
3) 放置成功 → `dispatcher.enqueue(RemoveUIPortraitEvent)` → UI 删除对应肖像  

## 🔧 实现步骤

## 🧾 1) 新增事件、组件与标签

本节在 `src/game/defs/events.h` 新增 3 个事件：

- `PrepUnitEvent{name_id, class_id, cost}`：点击肖像后请求进入准备态
- `RemoveUIPortraitEvent{name_id}`：成功出击后通知 UI 删除肖像
- `RemovePlayerUnitEvent{entity}`：用于统一移除地图单位（死亡/清理等），并释放地点占用

并新增两个组件：

- `UnitPrepComponent`：准备单位所需的最小信息（name/type/range/cost）
- `PlaceOccupiedComponent`：挂在地点实体上，记录“哪个单位占用了这里”

此外，在 `src/game/defs/tags.h` 新增 `ShowRangeTag` 用于驱动范围渲染；在 `src/game/defs/constants.h` 增加：

- `PLACE_RADIUS`：用于检测鼠标是否落在放置点附近
- `RANGE_COLOR`：范围圆形的颜色（透明绿色）

## 🖱️ 2) UI 点击触发“准备单位”事件

`UnitsPortraitUI`（`src/game/ui/units_portrait_ui.*`）把按钮点击回调补齐：点击时直接发送 `PrepUnitEvent`：

```cpp
[this, name_id, &unit_data, cost]() {
    context_.getDispatcher().enqueue(game::defs::PrepUnitEvent{name_id, unit_data.class_id_, cost});
}
```

同时 UI 也监听 `RemoveUIPortraitEvent`，收到后把对应 `frame_panel` 移除并重新排版：

```cpp
anchor_panel_->removeChildById(event.name_id_);
arrangeUnitsPortraitUI();
```

这样出击成功后，UI 就能自动“消耗掉”这个角色。

## 🧱 3) 创建“准备单位”实体：`EntityFactory::createUnitPrep`

为了复用蓝图数据，本节在 `EntityFactory` 新增 `createUnitPrep()`：

- 复用职业蓝图的 Sprite（准备态看起来像该单位）
- 挂上 `UnitPrepComponent`（带 range/cost/type）
- 给一个很高的渲染层（`RenderComponent(100)`），确保它显示在最上层
- 远程单位额外加 `ShowRangeTag`（触发范围渲染）

## 🧠 4) 出击系统主角：`PlaceUnitSystem`

`src/game/system/place_unit_system.*` 负责整个出击闭环。

### 4.1 准备态跟随鼠标 + 合法性检测

系统每帧让准备单位的位置同步到鼠标（注意要做 **screen → world** 转换）：

```cpp
const auto& mouse_pos_screen = context_.getInputManager().getLogicalMousePosition();
const auto mouse_pos_world = context_.getCamera().screenToWorld(mouse_pos_screen);
transform.position_ = mouse_pos_world;
```

然后根据 `UnitPrepComponent.type_`，在地图上找可放置地点实体：

- 近战：`view<MeleePlaceTag>(exclude<PlaceOccupiedComponent>)`
- 远程：`view<RangedPlaceTag>(exclude<PlaceOccupiedComponent>)`

如果鼠标落在地点中心 `PLACE_RADIUS` 内，就认为“可放置”，并把准备单位渲染色改为绿色，否则红色：

```cpp
target_place_entity_ != entt::null ? render.color_ = engine::utils::FColor::green()
                                   : render.color_ = engine::utils::FColor::red();
```

### 4.2 左键确认：创建地图单位 + 占用 + 扣 cost + UI 移除

当鼠标左键触发 `onPlaceUnit()`，且 `target_place_entity_` 有效时：

1) 计算放置点中心坐标  
2) 用 `SessionData` 查单位信息、用 `EntityFactory` 创建玩家单位  
3) 给放置点挂 `PlaceOccupiedComponent{unit_entity}`  
4) `GameStats.cost_ -= cost`  
5) 删除准备单位实体 + 通知 UI 移除肖像  
6) 播放放置音效 `unit_placed`

此外还补了一个“渲染层兜底”：如果放置点图标的 layer 很高，确保玩家单位 layer = 放置点 layer + 1，避免被图标遮住。

### 4.3 右键取消：清理准备态

右键触发 `onCancelPrepUnit()`：把所有 `UnitPrepComponent` 实体标记 `DeadTag` 即可（准备态本来就是“随时可撤销”的）。

### 4.4 单位移除统一入口：`RemovePlayerUnitEvent`

当玩家单位死亡（或按键清理）时，不直接 `destroy()`，而是发送 `RemovePlayerUnitEvent`：

- `CombatResolveSystem`：玩家 hp 归零时 enqueue 移除事件
- `GameScene::onClearAllPlayers()`：遍历玩家实体并 enqueue 移除事件
- `PlaceUnitSystem::onRemoveUnitEvent()`：标记死亡，并把占用的地点 `PlaceOccupiedComponent` 移除

这样可以避免出现“单位没了但地点一直被占用”的脏状态。

## 🟢 5) 远程攻击范围显示：标签 + 渲染系统

准备态的“攻击范围圆”由 `RenderRangeSystem` 渲染：

- 筛选：`view<ShowRangeTag, TransformComponent, UnitPrepComponent>`
- 绘制：`renderer.drawFilledCircle(camera, transform.position_, prep.range_, RANGE_COLOR)`

为了让圆形可复用，本节在 `Renderer` 新增 `drawFilledCircle()`：通过引擎自带的 `assets/textures/UI/circle.png`，配合 `SDL_SetTextureColorModFloat/AlphaModFloat` 实现“任意颜色/透明度”的圆形填充绘制。

## ✅ 本节小结

- `PrepUnitEvent → PlaceUnitSystem → RemoveUIPortraitEvent` 串起了“点击肖像 → 准备出击 → 确认出击”的完整闭环
- “准备单位”与“地图单位”职责清晰：准备态负责交互与预览，地图单位负责战斗
- `PlaceOccupiedComponent` 让放置点具备“占用语义”，为后续撤退/换人留出扩展空间
- `RenderComponent.color_ + drawFilledCircle()` 提供了更灵活的渲染表达：颜色反馈 + 范围预览

## 🔍 自检清单

- [ ] 点击亮色肖像是否会创建准备单位，且跟随鼠标移动
- [ ] 鼠标在合法放置点附近是否变绿，不合法是否变红
- [ ] 左键确认后是否扣 cost、移除肖像、放置点被占用
- [ ] 右键是否能取消准备态
- [ ] 远程单位准备态是否能显示攻击范围圆

## ➡️ 下一节预告

下一节我们会把“敌人从起点刷出”升级成“按波次生成”：

- 用 JSON 配置每关的波次数据（准备时间/间隔/敌人类型与数量）
- 用队列管理波次推进，支持多起点随机出怪
- 把关卡数据与场景/刷怪逻辑解耦，真正进入“玩法数据驱动”

