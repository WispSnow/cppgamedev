# 10 引入哈希字符串

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1vryfBvE3t&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1vryfBvE3t)

## 📖 概述

从第 06~09 节开始，我们已经把“引擎主循环 + 输入信号 + 事件总线 + 场景切换”串起来了。接下来项目会进入更偏“游戏本体”的阶段：UI、资源、ECS、关卡……会出现大量的**名字**：

- UI 状态名：`normal / hover / pressed`
- 音效/音乐名：`ui_hover / battle_bgm`
- 纹理/字体路径：`assets/textures/...`、`assets/fonts/...`

如果这些名字全都用 `std::string` 来存、来比较、来查找，会逐渐出现两个问题：

1. **性能与写法**：字符串比较/哈希比整数慢，而且路径很长，代码也很难读。
2. **可维护性**：资源路径一旦变化，所有硬编码的地方都要改，容易漏、也不利于“换皮肤/换音效包”。

这一节我们引入 EnTT 的 **哈希字符串**（`entt::hashed_string`），把“字符串 → 整数 ID（`entt::id_type`）”这件事前置，并把资源系统改造成“用整数做 key 存储/查找”。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.048.webp" style='width: 800px;' />

> PPT 第 48 页：`entt::hashed_string` 的核心思想：运行期只处理整数（哈希值）

本节对应代码标签：`10-引入哈希字符串`（基线：`09-捕获与中断信号传递`）。

## 🎯 学习目标

- 理解 `entt::hashed_string` / `entt::id_type` 的作用与使用场景
- 学会在系统里“存 ID、用 ID 比较/查找”，而不是到处传 `std::string`
- 把资源管理器的容器 key 从字符串改为 `entt::id_type`
- 引入资源映射表：用短 key（如 `battle_bgm`）映射到真实路径（如 `assets/audio/...`）

## 🧠 思路：为什么“存 ID”比“存字符串”更合适

### 1) 哈希字符串的本质：给字符串一个“稳定的整数身份证”

`entt::hashed_string` 主要做两件事：

- 根据输入字符串计算出一个哈希值（`entt::id_type`）
- 同时保存对原字符串的轻量引用（便于调试/打印）

但在工程里，我们经常会遵循一个简单原则：

> **对外传 ID、对内存 ID，字符串只负责“人类可读”。**

原因是 `entt::hashed_string` 内部引用了原字符串（指针/长度），如果你把它长期存起来，而原字符串已经释放，就可能踩到生命周期坑。第 02 节我们就提过：`_hs` 字面量安全，是因为它绑定的是**字符串字面量**。

所以在这一节的重构里，你会看到一个明确的取舍：

- **容器 key 统一用 `entt::id_type`**（纯整数、无生命周期问题）
- `entt::hashed_string` 主要用来**生成 ID**（`value()`）以及在需要时提供 `data()`

## 🧱 资源管理模块的改造：key 从字符串变成整数

<img src="https://theorhythm.top/gamedev/MW/怪物战争.049.webp" style='width: 800px;' />

> PPT 第 49 页：ResourceManager 外观模式（Facade），内部委托给 Texture/Audio/Font 三个子管理器；容器 key 改为整数

我们先看重构后的接口长什么样（只看关键点即可）。

### 1) ResourceManager：统一入口 + 两套调用方式

`ResourceManager` 仍然是“统一入口”，对外提供 `load/get/unload/clear`，内部把工作委托给三个子管理器。

同时为了兼容两种用法，它为每类资源都提供了两套接口：

1. **`(id, file_path)`**：适用于“我有一个短 key，但也知道它对应的真实路径”（例如从配置文件读出来）
2. **`(hashed_string)`**：适用于“我直接用字符串字面量（路径或 key）生成 ID 并调用”

以纹理为例（节选自 `src/engine/resource/resource_manager.h`）：

```cpp
SDL_Texture* loadTexture(entt::id_type id, std::string_view file_path);
SDL_Texture* loadTexture(entt::hashed_string str_hs);
SDL_Texture* getTexture(entt::id_type id, std::string_view file_path = "");
SDL_Texture* getTexture(entt::hashed_string str_hs);
```

> 注意：`getTexture(id)` 在没缓存且没提供 `file_path` 时会返回 `nullptr`。这是刻意的——它强迫你明确“资源应该在哪加载”，避免静默失败。

### 2) 子管理器：`unordered_map<entt::id_type, ...>` 缓存资源

以 `TextureManager` 为例（节选自 `src/engine/resource/texture_manager.h`）：

```cpp
std::unordered_map<entt::id_type,
    std::unique_ptr<SDL_Texture, SDLTextureDeleter>> textures_;
```

它的 `loadTexture(id, file_path)` 流程也很典型：

1. 先用 `id` 查缓存，命中就直接返回
2. 未命中则按 `file_path` 加载，并把结果放进 `textures_[id]`

同样的模式也用在 `AudioManager`（`sounds_ / music_`）与 `FontManager`（`FontKey = {id, size}`）上。

## 🗂️ 自定义资源映射：用短 key 替代长路径

当资源越来越多时，最让人难受的往往不是“性能”，而是“路径硬编码”：

```cpp
// 真实路径太长，不好写；换资源也麻烦
context.getAudioPlayer().playMusic("assets/audio/4 Battle Track INTRO TomMusic.ogg"_hs);
```

这节课的解决方案是：引入一个“资源映射表”，把**短 key**映射到**真实路径**，代码里只引用短 key。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.050.webp" style='width: 800px;' />

> PPT 第 50 页：通过 `id - 路径` 配置文件，解除硬编码；只在配置里改映射即可替换资源

### 1) 新增 `assets/data/resource_mapping.json`

本节新增了一个映射文件（节选）：

```json
{
  "music": {
    "battle_bgm": "assets/audio/4 Battle Track INTRO TomMusic.ogg"
  }
}
```

你可以把它理解成：“战斗 BGM 的名字叫 `battle_bgm`，它对应磁盘上的哪个文件由配置决定”。

### 2) GameApp 启动时加载映射文件并预载入

在 `GameApp::initResourceManager()` 的末尾，会加载默认映射表：

```cpp
resource_manager_->loadResources("assets/data/resource_mapping.json");
```

`ResourceManager::loadResources(...)` 会读取 JSON，把每一项的 **key** 转成 `entt::id_type`，再用真实路径把资源载入缓存。

这样一来，当我们后面写：

```cpp
context.getAudioPlayer().playMusic("battle_bgm"_hs);
```

`"battle_bgm"_hs` 会变成一个整数 ID，而真正的音频文件路径已经在启动时通过映射表载入并缓存了。

## 🧩 渲染与 UI 的衔接：Sprite/UIImage/UIButton 也改成用 ID

资源缓存的 key 变了，渲染侧也要跟着调整，否则就“找不到纹理/音效”。

### 1) Sprite：同时保存 `texture_id` 与（可选）`texture_path`

`src/engine/render/sprite.h` 里，Sprite 现在包含两份信息：

- `texture_id_`：渲染时真正用来查资源的 key
- `texture_path_`：可选，用于调试/日志/某些初始化场景

并提供两种构造方式：

```cpp
Sprite(std::string_view texture_path, ...); // 通过路径构造，并计算 texture_id_
Sprite(entt::id_type texture_id, ...);      // 直接使用 id（要求资源已加载）
```

渲染器侧（`Renderer::drawUISprite/drawSprite`）也统一改为：

```cpp
auto texture = resource_manager_->getTexture(sprite.getTextureId());
```

也就是说：**渲染链路从此不关心“纹理路径”，只关心“纹理 ID”。**

### 2) UIImage：可以直接用纹理 ID 构造

`UIImage` 新增了 `entt::id_type` 的构造函数，你可以写出更“资源化”的 UI：

```cpp
ui_manager_->addElement(
  std::make_unique<engine::ui::UIImage>("assets/textures/Buildings/Castle.png"_hs)
);
```

这里的 `_hs` 会直接变成一个 `entt::id_type`，UIImage 内部只保存 ID，渲染时通过 ID 查缓存纹理。

### 3) UIInteractive / UIButton：UI 状态名也用 `_hs` 做 key

可交互 UI（按钮）需要管理一组 sprite（normal/hover/pressed）和音效（hover/click）。本节把这套映射也改成了整数 key：

- `sprites_`：`unordered_map<entt::id_type, Sprite>`
- `sounds_`：`unordered_map<entt::id_type, entt::id_type>`

在 `UIButton` 构造里就能看到这种写法（节选自 `src/engine/ui/ui_button.cpp`）：

```cpp
addSprite("normal"_hs, engine::render::Sprite(normal_sprite_id));
addSound("hover"_hs, "assets/audio/button_hover.wav"_hs);
```

于是 UI 状态机只需要记住 `current_sprite_id_`，切换状态时用 `"hover"_hs` 就能找到对应 sprite 并播放对应音效。

## ✅ 本节小结

- `entt::hashed_string` 可以把字符串映射到整数 ID；工程上更推荐“存 `entt::id_type`”
- 资源系统的容器 key 从 `std::string` 统一改为 `entt::id_type`，降低字符串比较/哈希成本，也让接口更清晰
- 引入 `assets/data/resource_mapping.json`：用短 key（如 `battle_bgm`）映射到真实路径，支持后续的资源替换与数据驱动
- 渲染/UI 侧（Sprite/UIImage/UIButton）同步改造：只在必要时保留路径字符串，渲染链路完全走 ID 查缓存

## 🔍 自检清单

- [ ] 启动游戏后能正常播放 `"battle_bgm"_hs` 指向的背景音乐（说明映射表已加载并预缓存）
- [ ] UI 按钮在 hover/pressed 状态能正常切换图片并播放对应音效（说明 UI 内部映射已从字符串迁移为 ID）
- [ ] 任意 `getTexture/getSound/getMusic/getFont` 在没有缓存且没提供路径时会返回 `nullptr`（并打日志），不会悄悄失败

## ➡️ 下一节预告

下一节（第 11 节）我们会正式引入 ECS 框架：把“实体/组件/系统”的最小闭环落到项目结构里，并开始为塔防的核心逻辑做铺垫。