# 17 目标锁定与攻击

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1UAyuB7EQe&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1UAyuB7EQe)

## 📖 概述

上一节我们已经让玩家单位能被创建、敌人能被阻挡：近战玩家把敌人拦下来，敌人也会“停住不动”。

但“停住”只是塔防的第一步。接下来我们要解决的是更核心的战斗循环：

1) **目标锁定**：角色如何在范围内找到可攻击目标？目标失效/离开范围后怎么办？  
2) **攻击启动**：冷却结束后如何发起攻击？近战/远程/治疗有什么区别？  
3) **动画与行为解耦**：攻击会播放一段动作动画，动画结束后才恢复到“走路/待机”，这套“状态切换”应该由谁负责？  

<img src="https://theorhythm.top/gamedev/MW/怪物战争.068.webp" style='width: 800px;' />

> PPT 第 68 页：玩家（攻击/治疗）单位的目标锁定与攻击流程

<img src="https://theorhythm.top/gamedev/MW/怪物战争.069.webp" style='width: 800px;' />

> PPT 第 69 页：敌方（近战/远程）单位的目标锁定与攻击流程

本节对应代码标签：`17-目标锁定与攻击`（基线：`16-玩家实体与阻拦敌人`）。

## 🎯 学习目标

- 用 `TargetComponent` 表示“锁定目标”，并在目标失效/离开射程时清除
- 用 `AttackReadyTag` + `TimerSystem` 表示“攻击冷却”，让“能不能攻击”成为可筛选的 ECS 状态
- 用 `AttackStarterSystem` 统一启动攻击：不同阵营/职业触发不同动画与行为（并切走冷却状态）
- 用 `ActionLockTag` 解决“攻击动画期间不允许移动”的问题
- 用事件把动画生命周期串起来：`PlayAnimationEvent` 启动动画，`AnimationFinishedEvent` 通知结束，`AnimationStateSystem` 负责回到 idle/walk
- 用 `OrientationSystem` 保证面朝方向正确（面朝目标 / 面朝阻挡者 / 面朝移动方向）

## 🧩 1) 目标组件：`TargetComponent`

目标锁定的核心是一个极简组件：只保存目标实体即可（ECS 世界里“关系”也可以用 entity 引用表达）。

`src/game/component/target_component.h`：

```cpp
struct TargetComponent {
    entt::entity entity_{entt::null};
};
```

配套地，我们为“临时状态”准备了几个标签（`src/game/defs/tags.h`）：

- `AttackReadyTag`：攻击冷却结束，可以发起攻击
- `InjuredTag`：受伤（用于治疗单位筛选目标）
- `ActionLockTag`：动作锁（硬直），动画播完前不允许做下一步（例如继续移动）

这一节你会反复看到一个 ECS 写法的典型套路：

> **“状态”不是枚举，而是组件/标签**；系统通过 `view + exclude` 直接筛选出“当前应该处理的人”。

## 🎯 2) SetTargetSystem：统一处理“设置目标 / 清除目标”

`SetTargetSystem` 被拆成 4 段逻辑（对应 PPT 的分支）：

- `updateHasTarget()`：有目标 → 校验目标有效性与距离
- `updateNoTargetPlayer()`：玩家攻击型单位 → 找敌人
- `updateNoTargetEnemy()`：敌方远程单位 → 找玩家
- `updateHealer()`：治疗者 → 找“受伤且血量百分比最低”的友军

### 2.1 有目标：目标失效/离开射程则清除

```cpp
if (!registry.valid(target.entity_)) {
    registry.remove<TargetComponent>(entity);
}

auto range_radius = stats.range_ + game::defs::UNIT_RADIUS;
if (distanceSquared(self_pos, target_pos) > range_radius * range_radius) {
    registry.remove<TargetComponent>(entity);
}
```

这里新增了一个常量：`UNIT_RADIUS`（`src/game/defs/constants.h`），用于把“射程”从点到点扩展成更符合直觉的“半径判定”（射程 + 目标体积）。

### 2.2 无目标的玩家攻击单位：范围内找到一个敌人就锁定

玩家攻击单位的筛选条件很关键：**有玩家组件 + 没有 Target + 不是治疗者**。

```cpp
auto view_player_no_target = registry.view<TransformComponent, StatsComponent, PlayerComponent>(
    entt::exclude<TargetComponent, HealerTag>
);
```

然后与敌人做距离检测，找到一个就 `emplace<TargetComponent>`：

```cpp
if (distanceSquared(player_pos, enemy_pos) <= range_radius * range_radius) {
    registry.emplace<TargetComponent>(player_entity, enemy_entity);
    break;
}
```

### 2.3 治疗者：锁定“受伤且血量百分比最低”的友军

治疗单位的目标选择更像真实游戏：不治满血单位，优先救最危险的那个。

做法是：

1) 用 `InjuredTag` 筛选“需要治疗”的候选目标  
2) 在治疗射程内遍历候选者，计算 `hp/max_hp`，取最小值  
3) 用 `emplace_or_replace<TargetComponent>` 更新治疗目标（找不到则移除目标）

这套写法也体现了“标签的价值”：`InjuredTag` 让系统不用比较数值就能快速缩小搜索范围。

## ⏱️ 3) TimerSystem：把攻击冷却变成可筛选状态（AttackReadyTag）

攻击冷却计时器放在 `StatsComponent.atk_timer_` 中；`TimerSystem` 每帧推进计时器，并在冷却结束时打上 `AttackReadyTag`：

```cpp
stats.atk_timer_ += delta_time;
if (stats.atk_timer_ >= stats.atk_interval_) {
    registry.emplace_or_replace<AttackReadyTag>(entity);
    stats.atk_timer_ = 0.0f;
}
```

这样后续系统只需要筛选“带 `AttackReadyTag` 的实体”即可，不必在每个系统里写一遍冷却判断。

## ⚔️ 4) AttackStarterSystem：发起攻击（并启动动画）

攻击启动系统做一件事：**当“有目标/或被阻挡 + 冷却结束”时，触发一次攻击动作**。

它拆成 3 段处理：

### 4.1 被阻挡的敌人：目标就是阻挡者（不需要 TargetComponent）

```cpp
auto view_enemy_blocked = registry.view<EnemyComponent, BlockedByComponent, AttackReadyTag>();
```

触发攻击时：

- 加 `ActionLockTag`（确保动画播完前不会继续移动）
- 移除 `AttackReadyTag`（让冷却重新开始计时）
- 发送 `PlayAnimationEvent` 播放一次 `attack`（不循环）

```cpp
registry.emplace_or_replace<ActionLockTag>(enemy_entity);
registry.remove<AttackReadyTag>(enemy_entity);
dispatcher.enqueue(PlayAnimationEvent{enemy_entity, "attack"_hs, false});
```

### 4.2 远程敌人：有 Target 且冷却结束，播 ranged_attack

远程敌人需要 `TargetComponent`，并且未被阻挡（否则走近战分支）：

```cpp
auto view_enemy_ranged = registry.view<EnemyComponent, TargetComponent, AttackReadyTag>(
    entt::exclude<BlockedByComponent>
);
```

触发攻击时同样会 `ActionLockTag` + 清空速度 + 播 `ranged_attack`：

```cpp
registry.emplace_or_replace<ActionLockTag>(enemy_entity);
registry.emplace_or_replace<VelocityComponent>(enemy_entity, glm::vec2(0.0f, 0.0f));
dispatcher.enqueue(PlayAnimationEvent{enemy_entity, "ranged_attack"_hs, false});
```

### 4.3 玩家：有 Target 且冷却结束，攻击或治疗

玩家不移动，所以这里不需要 `ActionLockTag`；动画根据是否有 `HealerTag` 分流：

```cpp
if (registry.all_of<HealerTag>(player_entity)) {
    dispatcher.enqueue(PlayAnimationEvent{player_entity, "heal"_hs, false});
} else {
    dispatcher.enqueue(PlayAnimationEvent{player_entity, "attack"_hs, false});
}
registry.remove<AttackReadyTag>(player_entity);
```

> 这一节只做到“发起攻击并播放动画”，还没有真正扣血/治疗。下一节会把“动画帧事件 → 伤害结算”串起来。

## 🎬 5) 动画生命周期：AnimationFinishedEvent + AnimationStateSystem

### 5.1 AnimationSystem：非循环动画结束时发事件

当动画不循环且播放到最后一帧，`AnimationSystem` 会发送 `AnimationFinishedEvent`：

```cpp
dispatcher_.enqueue(AnimationFinishedEvent{entity, anim_component.current_animation_id_});
```

### 5.2 AnimationStateSystem：收到“动画结束”后回到 walk/idle，并解除 ActionLock

`AnimationStateSystem` 专门监听 `AnimationFinishedEvent`，没有 update 函数，只做状态收尾：

- 敌人：如果被阻挡 → 回 `idle`；否则 → 回 `walk`；并移除 `ActionLockTag`
- 玩家：直接回 `idle`

这一步非常关键：它把“动画结束后的切换逻辑”从各个系统里抽出来，避免“谁触发动画，谁负责善后”的耦合。

## 🧭 6) 朝向系统：OrientationSystem

角色开始攻击后，如果朝向不正确，观感会很怪。

本节新增 `OrientationSystem`，并按优先级依次处理：

1) **有目标**：面朝目标  
2) **被阻挡**：面朝阻挡者  
3) **移动中敌人**：面朝移动方向（最后处理，确保移动方向优先级最高）  

最终效果是：

- 玩家/远程敌人攻击时会面向目标
- 被阻挡敌人会面向阻挡者
- 移动中的敌人会面向速度方向

同时考虑了 `FaceLeftTag`：有些素材默认朝向不同，需要把翻转规则反过来。

## 🧩 7) 与旧系统的衔接：Block / FollowPath 的小改动

为了让“动作锁”真正生效，本节对旧系统做了两处关键调整：

- `FollowPathSystem`：排除 `ActionLockTag`，避免敌人攻击动画期间继续按路径移动
- `BlockSystem`：阻挡关系失效时顺带移除 `ActionLockTag`，并恢复 `walk` 动画

## 🧪 8) GameScene 最小验证：让治疗者有目标可选

本节为了验证“治疗者找友军”的逻辑，在测试输入里加了一点小技巧：

- 创建战士/弓箭手时，手动给它们加 `InjuredTag`，并把 `hp_` 设成 `max_hp_/2`
- 绑定 `move_left` 动作（键位见配置）用来创建 `witch`（治疗者）

这样你就能观察到：

- 治疗者在射程内会锁定受伤友军，并周期性播放 `heal` 动画
- 攻击单位在射程内会锁定敌人，并周期性播放 `attack` 动画
- 被阻挡的敌人会周期性播放 `attack`，动画结束后回到 `idle`

## ✅ 本节小结

- 用 `TargetComponent` + `SetTargetSystem` 建立了“锁定/清除目标”的通用机制（攻击/治疗通吃）
- 用 `TimerSystem` 将冷却逻辑集中处理，并通过 `AttackReadyTag` 把“可攻击”变成 ECS 状态
- 用 `AttackStarterSystem` 发起攻击：统一触发动画，并用 `ActionLockTag` 管控敌人的“硬直期”
- 用 `AnimationFinishedEvent` 把动画结束信号事件化，再由 `AnimationStateSystem` 统一做“回到 idle/walk + 解锁”
- 新增 `OrientationSystem` 修正朝向，让“走路/攻击/被阻挡”时视觉一致

## ➡️ 下一节预告

这一节我们完成了“目标锁定 + 攻击启动 + 动画状态收尾”，但还缺了最重要的一环：**真正的伤害与治疗结算**。

下一节我们会引入“动画驱动的战斗交互”：在攻击动画的关键帧触发事件，执行伤害/治疗，并让战斗逻辑与动画节奏对齐。