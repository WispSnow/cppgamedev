# 22 出击区域与关卡状态

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1KUShBREoJ&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1KUShBREoJ/)

## 📖 概述

上一节我们已经有了“出击肖像条”，但它还只是展示：玩家并没有真正进入“选择角色 → 找到可出击的位置 → 部署单位”的完整循环。

这一节，我们先把两个基础设施补齐：

1) **出击区域**：在地图上标记“哪些格子能放近战、哪些格子能放远程”，并把这些信息变成 ECS 可筛选的标签。  
2) **关卡状态（GameStats）**：把 cost / 基地血量 / 杀敌数等“全局数据”收拢到一个地方，由系统统一更新，再让 UI 用它来做反馈（例如 cost 不足时给肖像盖灰）。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.081.webp" style='width: 800px;' />

> PPT 第 81 页：出击区域与关卡状态（地点类型实体 + GameStats + 根据 cost 控制灰色遮罩）

本节对应代码标签：`22-出击区域与关卡状态`（基线：`21-出击选择角色肖像`）。

## 🎯 学习目标

- 用 `GameStats` 统一管理关卡内资源与统计数据（cost/血量/击杀/到达等）
- 用 `registry.ctx()` 存放“非组件数据”，让系统与 UI 都能方便拿到共享状态
- 新增 `GameRuleSystem`：每帧更新 cost，并为“敌人到达基地”等规则留好入口
- 在 Tiled 中用 tile properties 标记“出击区域类型”，并在 Builder 中打上 `MeleePlaceTag/RangedPlaceTag`
- 把肖像条 UI 从 `GameScene` 抽成独立类，并用 `GameStats.cost_` 驱动“灰色遮罩”显示

## 🧠 思路与设计

这一节的核心思路是：**把“关卡规则/资源/状态”从散落的 if/临时变量，升级为可复用的数据结构 + 系统更新**。

- **GameStats 是“关卡级”的数据**：它不属于某个实体，所以不适合做 component；但它又需要被多个 system/UI 读写。
- **registry.ctx() 正好解决“非 component 数据共享”**：我们可以把 `UIConfig/SessionData/BlueprintManager` 这类对象，以及 `GameStats` 的引用，都放进 ctx 里。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.082.webp" style='width: 800px;' />

> PPT 第 82 页：`registry.ctx()` 可以保存“非 component”的共享数据

与此同时，出击区域的设计也遵循同样的原则：**数据在地图里，逻辑在 Builder/系统里**。

- 地图（Tiled）负责“哪里能放什么”
- Builder 把地图信息变成“实体 + Tag”
- 后续出击系统只需要 `view<MeleePlaceTag>` 或 `view<RangedPlaceTag>` 就能找到合法位置

## 🔧 实现步骤

## 💾 1) 关卡状态：新增 `GameStats`

本节新增 `src/game/data/game_stats.h`，把关卡内常用资源/统计值收拢到一起：

```cpp
struct GameStats {
    float cost_{10.0f};
    float cost_gen_per_second_{1.0f};
    int home_hp_{5};
    int enemy_count_{0};
    int enemy_arrived_count_{0};
    int enemy_killed_count_{0};
};
```

这样之后不管是 UI 还是系统，都不需要“各自维护一份 cost/血量”，而是围绕同一个数据源工作。

## 🧺 2) 用 `registry.ctx()` 分发共享数据

为了让系统和 UI 都能拿到这些对象，我们在 `GameScene` 里新增 `initRegistryContext()`：

```cpp
registry_.ctx().emplace<std::shared_ptr<game::factory::BlueprintManager>>(blueprint_manager_);
registry_.ctx().emplace<std::shared_ptr<game::data::SessionData>>(session_data_);
registry_.ctx().emplace<std::shared_ptr<game::data::UIConfig>>(ui_config_);
registry_.ctx().emplace<game::data::GameStats&>(game_stats_);
```

其中 `GameStats` 用引用存入 ctx（指向 `GameScene` 的成员 `game_stats_`），可以避免“ctx 里复制一份状态”导致不同步。

## ⏱️ 3) 新增 `GameRuleSystem`：更新 cost、承载关卡规则

在 `src/game/system/game_rule_system.*` 中，我们新增一个规则系统：

- `update()`：每帧推进 `cost_ += cost_gen_per_second_ * dt`
- `onEnemyArriveHome()`：敌人到达基地时扣血、累计到达数（目前仍是 TODO/预留）

```cpp
void GameRuleSystem::update(float delta_time) {
    auto& game_stats = registry_.ctx().get<game::data::GameStats&>();
    game_stats.cost_ += game_stats.cost_gen_per_second_ * delta_time;
}
```

> 注意：当前 tag 里 `onEnemyArriveHome()` 还没有像 `CombatResolveSystem` 那样在构造函数里 `sink/connect` 接到事件上（代码里也保留了 TODO）。后续补上连接后，`FollowPathSystem` 发出的 `EnemyArriveHomeEvent` 才会真正改变基地血量。

## 🗺️ 4) 出击区域：Tiled 标记 + Builder 打 Tag

### 4.1 在 tileset 中为“出击点”设置属性

本节修改 `assets/maps/tileset/buildings.tsj`，新增两种 64×64 的小图块：

- `melee_place.png`：properties `place = "melee"`
- `range_place.png`：properties `place = "range"`

并在地图 `assets/maps/level1.tmj` 里新增 object layer：`placement`，把这些标记摆到地图上。

### 4.2 在 Builder 中解析属性并添加标签

在 `src/game/defs/tags.h` 新增两个标签：

- `MeleePlaceTag`
- `RangedPlaceTag`

然后在 `src/game/loader/entity_builder_mw.cpp` 里新增 `buildPlace()`：读取 tile 的 `place` 属性并给实体打标签：

```cpp
if (property.value("name", "") == "place") {
    auto type = property.value("value", "");
    if (type == "melee") {
        registry_.emplace<game::defs::MeleePlaceTag>(entity_id_);
    } else if (type == "range") {
        registry_.emplace<game::defs::RangedPlaceTag>(entity_id_);
    }
}
```

这样，“地图上的一个标记”就变成了 ECS 里的一个“地点类型实体”，后续系统可以非常自然地做筛选与判定。

## 🧩 5) 肖像条升级：封装类 + cost 遮罩

为了让 `GameScene` 不被 UI 细节淹没，本节把底部肖像条从 `GameScene::createUnitsPortraitUI()` 抽成了独立类：

- `src/game/ui/units_portrait_ui.h/.cpp`

其中最关键的更新点是：**根据 `GameStats.cost_` 决定是否显示灰色遮罩**。

实现方式也很“ECS/UI 树味道”：

- 每个 `frame_panel` 的 `order_index_` 继续保存“该角色的 cost”
- 遮罩是 `frame_panel` 的子 panel，id 为 `"cover_panel"_hs`
- 每帧只要比较 `game_stats.cost_ < frame_panel->getOrderIndex()` 即可控制遮罩显示

```cpp
auto& game_stats = registry_.ctx().get<game::data::GameStats&>();
for (auto& frame_panel : anchor_panel_->getChildren()) {
    auto cover_panel = frame_panel->getChildById("cover_panel"_hs);
    if (cover_panel) {
        cover_panel->setVisible(game_stats.cost_ < frame_panel->getOrderIndex());
    }
}
```

对应 PPT 的效果就是：cost 不够时，肖像会“盖灰”，提示当前无法出击。

## 📈 6) 补齐统计：击杀数更新（为通关判定铺垫）

在 `CombatResolveSystem` 里，敌人死亡时会更新 `enemy_killed_count_`，并预留“敌人全部处理完 → 切场景”的逻辑：

```cpp
auto& game_stats = registry_.ctx().get<game::data::GameStats&>();
game_stats.enemy_killed_count_++;
if ((game_stats.enemy_killed_count_ + game_stats.enemy_arrived_count_) >= game_stats.enemy_count_) {
    // TODO: 切换场景逻辑
}
```

`enemy_count_` 目前还没有在“刷怪/波次系统”里正式赋值，因此这里先当作“通关判定接口”预埋，下一节与后续波次系统会把它串起来。

## ✅ 本节小结

- 用 `GameStats` 把关卡资源/统计数据集中管理，并通过 `registry.ctx()` 共享给系统与 UI
- 新增 `GameRuleSystem` 推进 cost（并为“敌人到达基地/基地血量”等规则预留入口）
- 在地图中标记“近战/远程出击点”，并在 Builder 中把 tile property 转成 `MeleePlaceTag/RangedPlaceTag`
- 肖像条 UI 抽成 `UnitsPortraitUI`，并用 `GameStats.cost_` 驱动“灰色遮罩”反馈
- 在战斗结算里补上击杀统计，为后续关卡结束判定做准备

## 🔍 自检清单

- [ ] `GameStats` 是否已成功放入 `registry.ctx()`（系统与 UI 能拿到引用）
- [ ] cost 是否会随时间增长，肖像遮罩是否会随 cost 变化而消失
- [ ] `placement` 图层的实体是否能正确获得 `MeleePlaceTag/RangedPlaceTag`

## ➡️ 下一节预告

下一节我们会把“选择肖像”真正推进到“出击”：

- 点击肖像进入“出击准备”状态（准备放置的单位信息）
- 在地图上只允许放到合法的出击区域，并处理占用/扣 cost/出击完成
- 预览攻击范围（放置前提示，放置后也能显示）

