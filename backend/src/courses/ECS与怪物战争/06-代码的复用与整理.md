# 06 代码的复用与整理

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1musJzLEdQ&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1musJzLEdQ)

## 📖 概述

从这一节开始，我们正式进入“引擎重构”阶段的代码实现。

需要强调的是：第 06 节并不是“写新功能”，而是做一次**整理与减法**——把上一期《阳光岛》复用过来的工程结构先梳理清楚，删掉与本期塔防玩法无关、反而会拖慢后续重构的模块（典型代表：物理系统），让项目在一个更轻、更干净的状态下继续往 ECS 与事件驱动演进。

本节对应代码标签：`06-代码的复用与整理`（基线为“项目起点”提交 `fc0240f0...`）。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.034.webp" style='width: 800px;' />

> PPT 第 34 页：游戏分层架构（平台抽象层 / 引擎核心层 / 游戏逻辑层 / 工具层）

## 🎯 学习目标

- 认识“项目起点”的整体框架：主循环如何驱动 Scene、UI、（可选）物理等模块
- 学会用“切断依赖 → 删除实现 → 清理残留”的顺序，安全地移除一个引擎子系统
- 理解为什么塔防俯视角项目可以先删物理：未来真需要时，再以 ECS System 的形式引回

## 🧠 思路与设计

### 1) “复用”的边界：哪些该通用，哪些该具体？

从目录结构上看，这个项目已经把边界划得很清楚：

- `src/engine/`：**通用引擎层**（渲染、资源、输入、UI、场景管理……）
- `src/game/`：**具体游戏逻辑层**（本期怪物战争的场景、系统、组件等）

这就是“代码复用”的第一原则：能复用的做成工具/引擎模块；具体玩法放在 game 层。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.031.webp" style='width: 800px;' />

> PPT 第 31 页：项目起点的整体框架（Game/Scene/GameObject/Component + UI + Physics）

你可以把“项目起点”理解为：上一期框架的一个可运行版本——主循环驱动 Scene 更新；Scene 里维护一组 `GameObject`；每个对象再更新各自的 `Component`；UI 作为独立系统更新与渲染；物理引擎（如果存在）也在每帧更新中被驱动。

### 2) “整理”的策略：为什么先删物理？

站在本期玩法的角度看（俯视角塔防）：

- 单位移动通常沿“预设路径”前进（第 14 节会专门做），不需要复杂的刚体/碰撞解算
- 角色攻击/受击更多是**规则与状态机**，而不是物理碰撞反馈

物理系统在此时的作用非常有限，但它会带来真实的成本：

- 更多的类型与依赖（PhysicsEngine / Collider / CollisionLayer / 相关组件）
- 更多的更新链路（Context → Scene → PhysicsEngine）
- 更多的“后续重构要考虑的变量”（当我们把 GameObject 迁移到 ECS 时）

因此本节选择的策略是：**先删掉物理系统，把工程减负**。将来如果确实需要物理，也更推荐用 ECS 的方式引入，例如 `PhysicsSystem->update()`，而不是把 PhysicsEngine 深度耦合进 Scene。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.033.webp" style='width: 800px;' />

> PPT 第 33 页：系统更新顺序示意（物理可以是可选系统；Debug UI 往往放在最后叠加）

## 🔧 实现步骤

这一节的改动非常“工程化”，推荐你按下面的顺序做（每一步都让项目保持可编译/可运行）。

### 1) 从构建系统切断物理模块

第一步不是删代码，而是先让编译系统不要再把物理相关的 `.cpp` 编进去：

- 从 `CMakeLists.txt` 的 `SOURCES` 列表移除：
  - `src/engine/physics/*`
  - `src/engine/component/physics_component.*`
  - `src/engine/component/collider_component.*`

并且你会看到 `level_loader.cpp` 被暂时注释掉：

```cmake
set(SOURCES
    # ...
    src/engine/scene/scene.cpp
    src/engine/scene/scene_manager.cpp
    # src/engine/scene/level_loader.cpp
    # ...
)
```

原因很简单：`level_loader.cpp` 在这个阶段仍然包含了已删除的碰撞/物理相关头文件。为了让“删除物理”这件事先落地、让项目回到可编译状态，我们先把它移出编译列表，后续在“关卡载入器（第 12~13 节）”阶段再把它补齐。

### 2) 从运行时切断：GameApp → Context → Scene

物理引擎在“项目起点”里是被主循环驱动的（`GameApp` 初始化、`Context` 持有引用、`Scene` 每帧调用更新）。因此删除物理要从这条链路上逐段拆掉。

**（1）`GameApp`：不再初始化 PhysicsEngine**

`src/engine/core/game_app.cpp` 的初始化顺序里移除了 `initPhysicsEngine()`，`initContext()` 也不再把 PhysicsEngine 传进去。

**（2）`Context`：不再持有 `PhysicsEngine&`**

`Context` 的定位是“核心模块的依赖注入容器”，既然物理不在核心模块里，就把它彻底拿掉：

```cpp
// src/engine/core/context.h
class Context final {
private:
    engine::input::InputManager& input_manager_;
    engine::render::Renderer& renderer_;
    engine::render::Camera& camera_;
    engine::render::TextRenderer& text_renderer_;
    engine::resource::ResourceManager& resource_manager_;
    engine::audio::AudioPlayer& audio_player_;
    engine::core::GameState& game_state_;
public:
    // ...
};
```

**（3）`Scene`：不再每帧更新 PhysicsEngine**

`Scene::update()` 里原本“游戏进行中就更新物理 + 相机”，现在只保留相机更新：

```cpp
// src/engine/scene/scene.cpp
void Scene::update(float delta_time) {
    if (!is_initialized_) return;

    // 只有游戏进行中，才需要更新相机
    if (context_.getGameState().isPlaying()){
        context_.getCamera().update(delta_time);
    }

    // ...
}
```

这一步做完，你会发现主循环依然完整：Scene 继续更新对象与 UI，渲染也不受影响，只是物理系统这条分支彻底断开了。

### 3) 删除物理相关组件，并清理残留依赖

物理引擎删掉后，与它强绑定的组件也应该一并删除，否则会留下大量“无意义但必须维护”的代码。

本节直接删除了两类组件文件：

- `src/engine/component/physics_component.*`
- `src/engine/component/collider_component.*`

同时清理“还在引用 Collider 的地方”，例如 `TransformComponent` 在缩放时只需要通知 `SpriteComponent` 更新贴图偏移即可，不再需要更新碰撞框偏移：

```cpp
// src/engine/component/transform_component.cpp
void TransformComponent::setScale(glm::vec2 scale)
{
    scale_ = std::move(scale);
    if (owner_) {
        auto sprite_comp = owner_->getComponent<SpriteComponent>();
        if (sprite_comp) {
            sprite_comp->updateOffset();
        }
    }
}
```

以及 `TileLayerComponent` 去掉了对 PhysicsEngine 的反注册逻辑（因为碰撞层的概念也随物理一并移除）。

### 4) 小的收口：让“类型边界”更明确

这一节还有两处很小但很有“整理味道”的改动：

- `GameScene` 标记为 `final`：表达“这是具体游戏场景，不希望再被继承扩展”
- 构造函数显式写 `engine::scene::Scene(...)`：避免命名空间/继承层级变化时产生歧义

这些改动不会改变行为，但会让类型意图更清晰，也更利于后续大规模重构。

## ✅ 本节小结

- 以“项目起点”为基线，梳理并确认了本期工程的分层与主循环结构
- 删除了整个物理子系统（PhysicsEngine/Collision + 相关组件），并从 `GameApp → Context → Scene` 的调用链上彻底切断依赖
- 为了让项目先回到“可编译/可迭代”的状态，暂时把 `level_loader.cpp` 从编译列表移除，后续在关卡载入阶段再回收

## 🔍 自检清单

- [ ] 能正常编译链接（物理相关 `.cpp/.h` 删除后不应再有 include 报错）
- [ ] 运行时仍能进入场景并渲染（只是少了物理分支，不应影响主循环）
- [ ] 全局搜索 `physics`/`collider` 时，只剩下“确实还需要的注释/历史残留”而不是编译依赖

## ➡️ 下一节预告

下一节（第 07 节）我们会把输入模块做成“信号驱动”：

- 在 `InputManager::update()` 内检测输入变化并发送信号
- 需要响应输入的系统/场景/UI 通过订阅信号来处理

这样就能进一步弱化上一期那条“每帧都要调用一遍”的 `handleInput()` 链，为后续的事件总线与 ECS 更新铺路。