# 21 出击选择角色肖像

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1cWSyBJEia&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1cWSyBJEia)

## 📖 概述

从这一节开始，我们要把“塔防的核心循环”往完整玩法推进：玩家不再只用热键在鼠标位置刷出测试单位，而是要**先在 UI 里选择角色**，再进入“出击/部署”的流程。

因此第一步就是做一个“角色肖像条”：显示玩家当前拥有的角色（跨关卡数据），并在画面底部按一定规则排列，供后续点击交互。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.078.webp" style='width: 800px;' />

> PPT 第 78 页：出击选择角色肖像（父 panel + 肖像子 panel + 排序键 + 数据驱动 UI）

为了让 UI 更容易维护，本节还把“资源与布局”从代码里抽离出来：用 `ui_config.json` 配置肖像、职业图标、边框、字体与面板布局；并新增 `SessionData` 来承载玩家拥有的角色列表（跨关卡数据）。

<img src="https://theorhythm.top/gamedev/MW/怪物战争.079.webp" style='width: 800px;' />

> PPT 第 79 页：框架结构补齐（游戏内 UI 独立 update/render，保留组合 + 继承的 UI 体系）

本节对应代码标签：`21-出击选择角色肖像`（基线：`20-死亡动画与血量标签`）。

## 🎯 学习目标

- 用 `SessionData` 管理“玩家拥有的角色列表”（跨关卡数据），并支持读写 JSON
- 用 `UIConfig` 从 `ui_config.json` 加载 UI 资源与布局参数，实现数据驱动
- 在 `GameScene` 创建底部“单位面板”（unit panel）并生成每个角色的肖像子面板
- 为 UI 元素引入 `id` 与 `order_index`，支持查找与排序
- 将 UI 的交互从“轮询 handleInput”升级为“基于 InputManager 的信号回调”，使 UI 更事件化

## 🧠 思路与设计

这节课做 UI，有两个关键约束：

1) UI 结构是“组合树”：panel 里有子 panel，子 panel 里再叠 image/button/label。  
2) UI 的表现希望是“数据驱动”：换一套肖像/边框/布局，不想再改 C++。  

所以我们把实现拆成三层：

- **数据层**：`SessionData`（角色列表）+ `UIConfig`（UI 资源与布局）
- **UI 框架层**：`UIElement` 支持 `id` 与排序键；按钮状态机用信号驱动
- **场景层**：`GameScene` 读取数据，然后按“正确的添加顺序”搭建 UI 树

最终效果就是：下方出现一排可交互的肖像框，并且可以按 cost（或别的规则）排序，为下一节的“出击区域/关卡状态”铺路。

## 🔧 实现步骤

## 💾 1) 跨关卡数据：新增 `SessionData`

PPT 里提到“玩家拥有的角色（跨关卡数据）”，这类数据不应该挂在场景上（切场景就丢了），而应该由一个独立的数据对象管理。

本节新增：

- 默认数据：`assets/data/default_session_data.json`
- 数据类：`src/game/data/session_data.h/.cpp`

`SessionData` 的核心就是一个 `unit_map_`：

```cpp
std::unordered_map<entt::id_type, UnitData> unit_map_;
```

加载默认数据（节选）：

```cpp
for (const auto& [name, data] : json["unit"].items()) {
    entt::id_type name_id = entt::hashed_string(name.c_str());
    std::string class_str = data["class"].get<std::string>();
    entt::id_type class_id = entt::hashed_string(class_str.c_str());
    unit_map_[name_id] = {name_id, class_id, name, class_str, level, rarity};
}
```

这样后续 UI 只需要遍历 `unit_map_`，就能拿到“角色名/职业/等级/稀有度”等信息。

## 🧾 2) UI 数据驱动：新增 `ui_config.json` 与 `UIConfig`

为了避免把“肖像路径、切图坐标、布局参数、字体”写死在代码里，本节新增：

- 配置文件：`assets/data/ui_config.json`
- 配置类：`src/game/data/ui_config.h/.cpp`

`UIConfig` 管三类图片资源：

- 职业 icon：`icon_map_`（key: 职业 id）
- 角色肖像：`portrait_map_`（key: 角色名 id）
- 肖像框：`portrait_frame_map_`（key: 稀有度/等级）

并额外从 `layout.unit_panel` 读取面板布局（padding、frame_size、字体与偏移等）。

加载入口（节选）：

```cpp
loadIcon(json["icon"]);
loadPortrait(json["portrait"]);
loadPortraitFrame(json["portrait_frame"]);
loadLayout(json["layout"]);
```

其中每一类资源都会被解析为 `engine::render::Image(texture_path, src_rect, false)`，从而让 UI 侧能直接绘制。

## 🧱 3) UIElement 增强：`id`、排序键与查找

PPT 强调“UI 元素需要排序键，支持排序”。原因是：面板里的肖像需要按规则排列（例如按 cost 升序）。

本节对 UI 树做了三个增强点：

1) **每个 UIElement 有一个 `id_`**：便于按“角色名 id”查找某个肖像 panel  
2) **每个 UIElement 有一个 `order_index_`**：作为排序键（例如 cost）  
3) **支持按 id 移除/查找 + 支持按 order_index 排序**  

对应接口集中在 `src/engine/ui/ui_element.h/.cpp`：

- `addChild(child, order_index)`
- `getChildById(id)` / `removeChildById(id)`
- `sortChildrenByOrderIndex()`

> 注意：渲染时 children 是按顺序遍历的，所以“添加顺序”和“排序结果”都会影响最终效果。

## 🖱️ 4) UI 交互升级：从轮询 `handleInput()` 到信号驱动

为了与前面“输入信号捕获/中断传播”的体系对齐，本节把 UI 的交互从轮询改为信号回调：

- 删除 `Scene::handleInput()` / `SceneManager::handleInput()`
- `UIManager` 不再承担 “handleInput 分发”
- UI 状态机在构造/析构时对 `InputManager` 进行 `connect/disconnect`

例如悬停状态下按下鼠标左键：

- `UIHoverState` 订阅 `"mouse_left"_hs`，回调中切换到 `UIPressedState`
- 回调返回 `true`，表示输入被 UI 捕获，不再继续向下传播

这套方式的好处是：UI 不需要每帧“主动轮询按键”，而是以事件为驱动，逻辑更清晰，也更贴近我们前面建立的输入系统。

## 🧩 5) GameScene：创建底部肖像条（unit panel）

有了 `SessionData` 与 `UIConfig`，就可以在场景里组装 UI 了。

初始化阶段新增两步：

- `initSessionData()`：加载 `default_session_data.json`，拿到玩家拥有的角色列表
- `initUIConfig()`：加载 `ui_config.json`，拿到 UI 资源与布局参数

然后在 `createUnitsPortraitUI()` 里构建 UI 树：

1) 创建底部父 panel（anchor_panel），设置透明背景，并设置 id：`"unit_panel"_hs`  
2) 遍历 `session_data_->getUnitMap()`，为每个角色创建一个 `frame_panel`（子 panel）  
3) `frame_panel` 内部依次叠加四类元素（PPT 强调“正确添加顺序”）：  
   - 肖像 `UIImage(portrait)`  
   - 边框按钮 `UIButton(frame)`（未来绑定点击创建角色）  
   - 职业图标 `UIImage(icon)`  
   - COST 数字 `UILabel(cost)`  
   - 灰色遮罩 panel（cost 不足时显示，当前先占位）  
4) 将每个 `frame_panel` 以 `cost` 作为排序键加入父 panel，然后排序并重新排布位置

排序的关键点是这句（把 cost 当作 order_index）：

```cpp
anchor_panel->addChild(std::move(frame_panel), cost);
anchor_panel->sortChildrenByOrderIndex();
```

最终 UI 的 update/render 由 `Scene` 中的 `ui_manager_` 统一驱动，保持“游戏逻辑系统”和“游戏内 UI”相互独立。

## ✅ 本节小结

- `SessionData` 把“玩家拥有的角色列表”从场景中解耦，为跨关卡数据打好基础
- `UIConfig + ui_config.json` 把 UI 资源与布局参数数据化，避免硬编码
- UI 树增强 `id/order_index`，实现“可查找、可排序”的 UI 组织方式
- UI 交互从轮询转为信号驱动，进一步统一到事件/信号的体系中

## 🔍 自检清单

- [ ] 游戏启动后，画面底部出现一排角色肖像与 cost
- [ ] 肖像能按 cost 排序（而不是按 json 顺序/遍历顺序）
- [ ] 鼠标悬停/按下时按钮状态能切换（hover/pressed）
- [ ] UI 不依赖 `handleInput()` 仍能交互（输入由状态机 connect 回调驱动）

## ➡️ 下一节预告

- 下一节我们会加入“出击区域与关卡状态”：让肖像选择真正进入部署流程，并把 cost/积分、出击区域判定等状态组织起来。
