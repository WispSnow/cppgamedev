# 00 开篇：ECS、事件驱动与怪物战争

<div class="video-container">
  <div id="bilibili" class="video-content">
    <!-- B站嵌入：使用 https 明确协议（避免 file:// 或 http 导致被浏览器拦截） -->
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1xW4LzTEaj&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

[在 Bilibili 上观看](https://www.bilibili.com/video/BV1xW4LzTEaj)

## 🎮 课程简介

欢迎来到《C++游戏开发之旅》第四期：《怪物战争》（MonsterWar）。

这一期我们不再从零搭建一个游戏框架，而是**在上一期《阳光岛》的引擎层基础上继续演进**：一方面引入更现代的架构思想（ECS + 事件驱动），另一方面做一款完整的塔防游戏，实践“架构升级如何落地到具体玩法”。

![](../本期参考/PPT截图/怪物战争.004.png)

> PPT 第 4 页：使用 ImGui 快速开发原型，玩法致敬《千年战争》

## 🧭 本期你会学到什么

- **ECS 架构的正确打开方式**：用 EnTT 落地 ECS，尽量摆脱“伪 ECS / 仍然对象思维”的写法
- **事件驱动的思维方式**：用信号/事件把“轮询式调用链”改造成“变化才触发”的结构，让扩展更自然
- **调试 UI（ImGui）的高效用法**：做数值调试、单位信息展示、技能触发测试，甚至用来快速做 UI 原型
- **数据驱动**：把“经常变”的内容放到数据里（例如关卡/数值/蓝图），减少为了改参数而改代码的频率
- **塔防核心玩法的实现**：出击、阻拦、锁定、攻击、技能、波次、胜负与流程场景

## ✨ 你将完成什么（最终效果概览）

最终你会完成一款可玩、流程完整的塔防游戏：

- 关卡地图与可行走路径、敌人波次生成与推进
- 从角色头像 UI 中选择单位并部署到地图上（可撤退、可升级）
- 单位与敌人的核心交互：目标选择、动画驱动攻击、远程弹道、死亡与血量显示
- 游戏流程场景：标题、关卡、通关、结束
- 基于 ImGui 的调试面板：查看单位属性、触发技能、调整/验证规则（开发期工具）

（本节只做总览，具体实现会在后续课节逐步拆开讲解。）

## 🧰 技术栈与依赖

![](../本期参考/PPT截图/怪物战争.003.png)

> PPT 第 3 页：本期课程主要依赖库

本项目主要使用以下技术栈：

- **SDL3** 生态：`SDL3` / `SDL3_image` / `SDL3_mixer` / `SDL3_ttf`
- **数学与基础库**：`glm`、`spdlog`、`nlohmann_json`
- **关卡编辑器**：`Tiled`
- **本期新增重点**：
  - **EnTT**：ECS + 信号/事件工具
  - **ImGui**：调试 UI / 原型开发工具

构建工具为 `CMake`，推荐使用 `VS Code` 进行开发与调试。

> 环境安装与编译会在第 01 节详细说明，这里先不展开。

## 🧱 项目结构（引擎层 + 游戏层）

为了让“可复用的引擎能力”和“具体游戏玩法”边界清晰，本仓库依然延续分层思路：

- `src/engine/`：引擎层（与具体游戏无关的通用能力）
- `src/game/`：游戏层（怪物战争的玩法、数据与规则）

你会看到这一期的重构与新增，大多围绕两件事展开：

1. **用 ECS 重写/承载游戏对象的更新与渲染**
2. **用事件驱动替代一部分“每帧都要跑一遍”的轮询链路**

## ✅ 学习前置与建议

- 建议你已完成/理解上一期《阳光岛》的核心内容，尤其是引擎层（渲染、输入、资源、场景等）
  - 物理引擎部分可暂时放过：本期是俯视角塔防，不以物理为核心
- 建议你对 ECS 有基本概念（本期会讲“怎么用”，但不会从零复述“是什么”）

## 📚 课程组织方式

- 本期共有 **第 00 节（开篇） + 01~29 共 29 节课**
- 每一节课都对应仓库中的一个 git tag（以 `NN-...` 命名），方便你精确跳转到当节课完成时的代码状态

## ➡️ 下一节预告

下一节我们会完成 **环境安装与工程测试**：把依赖库与构建流程跑通，确保后续每一节课都能“改一点、跑一次、验证一次”。
