# 模板方法模式 (Template Method) - 固化流程，分离细节

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1PvVxzaEix&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * 理解模板方法模式的**核心思想**：在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中。
  * 掌握**控制反转 (Inversion of Control)** 的概念，也称“好莱坞原则”。
  * 分析从 `main()` 函数驱动到 **SDL3 回调驱动**的转变，理解其背后蕴含的模板方法思想。

## 🤔 当前代码的问题在哪里？

让我们回顾一下到目前为止我们的游戏主循环，它位于 `Game::run()` 方法中：

```cpp
// src/core/game.cpp (旧代码)
void Game::run()
{
    while (is_running_){
        // 1. 计算帧率
        auto start = SDL_GetTicksNS();
        
        // 2. 检查场景切换
        if (next_scene_){ /* ... */ }

        // 3. 处理所有事件
        handleEvents();

        // 4. 更新游戏状态
        update(dt_);

        // 5. 渲染画面
        render();

        // 6. 控制帧率
        auto end = SDL_GetTicksNS();
        // ... (帧延迟计算)
    }
}
```

这个 `run()` 方法是我们游戏的心脏，它定义了游戏运行的**完整流程**。这种方式虽然直观，但也存在一个设计上的问题：

**我们的 `Game` 类，与一个特定的“游戏循环”实现方案紧紧地绑定在了一起。**

`Game` 类不仅要负责游戏逻辑的 `update` 和 `render`，还要负责非常底层的循环控制、事件轮询 (`SDL_PollEvent`) 和帧率计算。如果 SDL 未来提供了一种更高效、更现代的循环方式（剧透：它确实提供了），我们要想采用，就必须重写整个 `run()` 方法。

## 📖 模板方法模式：“流程我定，细节你填”

<img src="https://theorhythm.top/gamedev/opt/OPT32.webp" alt="模版方法模式" style="display: block; margin: auto; width: 800px;" />

模板方法模式的核心思想非常简单，就像填写一份预设好格式的表格：

> **在一个基类中定义好一个算法的整体骨架（流程），但允许子类在不改变这个骨架的前提下，重写算法中的某些特定步骤。**

**现实世界类比**：想象一下去一家自助餐厅。餐厅规定了你的就餐流程（模板方法）：

1.  **取餐盘** (固定步骤)
2.  **选择菜品** (可变步骤 - 你可以选沙拉、热菜或甜点)
3.  **结账** (固定步骤)
4.  **找座位就餐** (固定步骤)

餐厅（基类）定义了整个流程的**骨架**，但“选择菜品”这个**具体步骤**的实现则由你（子类）来决定。你不能打乱这个流程（比如先吃再结账），但可以在流程的特定环节上“做文章”。

-----

## 🛠️ 重构实战：拥抱 SDL3 的“模板”

现在，我们将游戏的主循环从我们自己写的 `while` 循环，切换到由 **SDL3 框架提供的、基于回调的生命周期管理**。这个过程，正是对模板方法模式的一次经典应用。

在这里：

  * **“基类”** 的角色由 **SDL3 框架**扮演。
  * **“模板方法”** 是 SDL3 内部隐藏的、我们看不见的**应用程序主循环**。
  * **“子类”** 的角色由我们的 **`main.cpp`** 扮演，我们负责**填充**模板中预留的“空白步骤”。

### 步骤 1: 移除我们自己的 `run()` 循环

首先，我们将 `Game::run()` 方法以及相关的帧率计算成员变量注释掉。我们不再自己控制游戏循环了。

```diff
// src/core/game.h
class Game {
    // ...
-   Uint64 FPS_ = 60; // 游戏帧率
-   Uint64 frame_delay_ = 0; // 帧延迟，单位ns
-   float dt_ = 0.0f; // 帧间隔
    // ...
public:
-   void run(); // 运行游戏, 执行游戏主循环
};
```

这个改动意味着，我们的 `Game` 类将变得更加纯粹，只负责 `init`, `handleEvents`, `update`, `render`, `clean` 这些**具体的游戏逻辑**，而不再关心它们**何时以及如何被调用**。

### 步骤 2: 在 `main.cpp` 中“填空”

接下来，我们在 `main.cpp` 中使用 SDL3 的回调机制，来“填上” SDL3 应用程序生命周期这个“模板”的空白。

<img src="https://theorhythm.top/gamedev/opt/OPT34.webp" alt="SDL模版方法" style="display: block; margin: auto; width: 800px;" />

```cpp
// src/main.cpp (新代码)
#define SDL_MAIN_USE_CALLBACKS 1 // 告诉SDL我们将提供回调函数

#include "core/game.h"
#include <SDL3/SDL_main.h>

/* 【步骤一：初始化】此函数在启动时运行一次。 */
SDL_AppResult SDL_AppInit(void **appstate, int argc, char *argv[])
{
    Game::getInstance().init("GhostEscape", 1280, 720);
    return SDL_APP_CONTINUE;
}

/* 【步骤二：事件处理】此函数在发生新事件时运行。 */
SDL_AppResult SDL_AppEvent(void *appstate, SDL_Event *event)
{
    if (event->type == SDL_EVENT_QUIT) return SDL_APP_SUCCESS;
    
    Game::getInstance().handleEvents(*event); // 将单个事件交给Game处理
    return SDL_APP_CONTINUE;
}

/* 【步骤三：主循环迭代】此函数每帧运行一次。*/
SDL_AppResult SDL_AppIterate(void *appstate)
{
    // 帧率控制由SDL的模板来完成
    // ... (dt 计算)

    Game::getInstance().update(dt);
    Game::getInstance().render();

    // 检查游戏是否需要退出
    if (Game::getInstance().getIsRunning() == false) return SDL_APP_SUCCESS;

    return SDL_APP_CONTINUE;
}

/* 【步骤四：退出清理】此函数在程序关闭时运行一次。 */
void SDL_AppQuit(void *appstate, SDL_AppResult result)
{
    Game::getInstance().clean();
}
```

这个转变，就是典型的**控制反转 (Inversion of Control, IoC)**。

  * **之前**：是我们的 `Game::run()` **主动调用** SDL 的函数来检查事件。
  * **现在**：是我们把自己的函数 (`SDL_AppInit`, `SDL_AppEvent` 等) **注册**给 SDL 框架，由 SDL 框架在合适的时机来**回调**我们的函数。

> 💡 **好莱坞原则**
>
> 这就是著名的“好莱坞原则”：“**Don't call us, we'll call you.**”（不要给我们打电话，我们会打给你）。你（你的代码）不必主动去调用框架，只需要把你的能力告诉框架，框架会在需要的时候来“找”你。

## ✨ 总结

通过本次对模板方法模式的探讨，我们学到了：

  * **关注点分离**：该模式让框架（或基类）专注于**算法的稳定流程**，让使用者（或子类）专注于**具体步骤的个性化实现**。SDL 负责高效的循环和事件分发，我们则专注于游戏本身 `update` 和 `render` 的内容。
  * **代码复用与扩展性**：算法的骨架被固定下来，在所有子类中复用。当我们需要为不同的平台（如移动端）编写程序时，可能只需要提供不同的“填空”实现，而无需关心主循环的差异。
  * **框架设计的基石**：模板方法是构建健壮框架的基石。它定义了框架的“规矩”，使用者只需要按照规矩填空，就能快速、安全地构建功能。

虽然我们并未在 `GhostEscape` 项目中自己编写一个模板方法基类，但通过理解和使用 SDL3 的新架构，我们已经亲身体验了这一强大设计模式的思想精髓。