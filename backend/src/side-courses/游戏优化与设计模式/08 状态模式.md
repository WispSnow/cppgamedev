# 状态模式 (State Pattern) - 化繁为简的状态机

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1QNEtztEdu&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * 理解状态模式的**核心思想**：当一个对象的内在状态改变时，允许其改变行为，这个对象看起来好像改变了它的类。
  * 掌握如何将**基于 `if-else` 和布尔标志**的复杂状态管理，重构为**面向对象的状态机**。
  * 应用状态模式，彻底重构 `HUDButton` 类，使其逻辑更清晰、扩展性更强。

## 🤔 当前代码的问题在哪里？

让我们审视一下 `HUDButton` 类之前的实现。一个看似简单的按钮，为了实现“正常(Normal)”、“悬停(Hover)”和“按下(Press)”这三种状态，其内部代码是怎样的？

```cpp
// src/screen/hud_button.cpp (旧代码)
void HUDButton::update(float) {
    checkHover(); // 检查鼠标是否悬停
    checkState(); // 根据标志位更新精灵
}

bool HUDButton::handleEvents(SDL_Event &event)
{
    // 一大堆 if-else 用于处理鼠标按下和抬起事件...
    if (event.type == SDL_EVENT_MOUSE_BUTTON_DOWN) {
        if (is_hover_){
            is_press_ = true;
            // ...
        }
    } else if (event.type == SDL_EVENT_MOUSE_BUTTON_UP) {
        is_press_ = false;
        if (is_hover_){
            is_trigger_ = true;
            // ...
        }
    }
    return false;
}

void HUDButton::checkState()
{
    // 另一大堆 if-else 用于根据 is_press_ 和 is_hover_ 切换显示的Sprite
    if (!is_press_ && !is_hover_){
        // Normal State...
    }else if (!is_press_ && is_hover_){
        // Hover State...
    }else {
        // Press State...
    }
}
```

这种实现方式的问题非常突出：

1.  **逻辑高度耦合**：所有状态的判断、事件处理和视觉表现全部挤在 `HUDButton` 这一个类中，形成了一个难以维护的“上帝类”。
2.  **“标志位地狱”**：我们依赖于 `is_hover_` 和 `is_press_` 这两个布尔标志位。随着状态增多（例如增加一个“禁用”状态），标志位的数量和 `if-else` 的嵌套层级会爆炸式增长，代码将变得无法阅读。
3.  **违反开闭原则**：每当需要增加一个新状态时，我们都必须深入 `HUDButton` 的内部，修改 `update`、`handleEvents` 和 `checkState` 等多个函数，这极易引入新的 Bug。

## 📖 状态模式：“让状态自己管理自己”

<img src="https://theorhythm.top/gamedev/opt/OPT51.webp" alt="状态模式" style="display: block; margin: auto; width: 800px;" />

状态模式提供了一种优雅的解决方案：**将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。**

> **它将每种状态的行为封装到各自独立的类中，然后由“上下文”对象（Context）持有当前状态的实例，并将所有与状态相关的操作委托给它。**

**现实世界类比**：
想象一个自动售货机。它有“待机”、“已投币”、“售罄”等多种状态。

  * 当处于“待机”状态时，你投币，它会转换到“已投币”状态。
  * 当处于“已投币”状态时，你按下商品按钮，它会出货并转换回“待机”状态。
  * 当处于“售罄”状态时，无论你做什么，它都只会提示商品不足。

售货机（上下文）本身不包含复杂的 `if-else`。它只是将用户的操作（投币、按按钮）**全权委托**给它当前的“状态对象”去处理。而每个状态对象内部只关心两件事：**1. 在本状态下该做什么；2. 满足什么条件后该转换到哪个新状态。**

-----

## 🛠️ 重构实战：打造一个状态驱动的 `HUDButton`

<img src="https://theorhythm.top/gamedev/opt/OPT50.webp" alt="状态模式应用" style="display: block; margin: auto; width: 800px;" />

### 步骤 1: 定义一个抽象的 `ButtonState` 接口

我们首先创建一个 `ButtonState` 基类，它定义了所有具体状态类都必须遵守的“契约”。

```cpp
// src/state/button_state.h
#ifndef BUTTON_STATE_H
#define BUTTON_STATE_H

#include "../core/object.h"
#include "../screen/hud_button.h"

class ButtonState : public Object {
protected:
    HUDButton* parent_ = nullptr; // 持有对“上下文”HUDButton的引用

public:
    // 状态的生命周期钩子：进入和退出
    virtual void onEnter() = 0;
    virtual void onExit() = 0;

    // ... setters
};

#endif // BUTTON_STATE_H
```

`onEnter()` 和 `onExit()` 是状态机的精髓，它们确保在状态切换时，能够执行必要的初始化和清理工作（比如切换Sprite、播放音效）。

### 步骤 2: 为每种状态创建具体的实现类

现在，我们将原来 `HUDButton` 中的 `if-else` 逻辑拆分到三个独立的类中。

**正常状态 (ButtonStateNormal):**

```cpp
// src/state/button_state_normal.cpp
void ButtonStateNormal::onEnter() {
    parent_->getSpriteNormal()->setActive(true);
}
void ButtonStateNormal::onExit() {
    parent_->getSpriteNormal()->setActive(false);
}
bool ButtonStateNormal::handleEvents(SDL_Event& event) {
    if (event.type == SDL_EVENT_MOUSE_MOTION) {
        // ... 检查鼠标是否进入按钮范围
        if (/* isMouseInRect */){
            // 如果进入，则通知按钮切换到“悬停”状态
            parent_->changeState(new ButtonStateHover());
            return true;
        }
    }
    return false;
}
```

**悬停状态 (ButtonStateHover):**

```cpp
// src/state/button_state_hover.cpp
// ...
bool ButtonStateHover::handleEvents(SDL_Event& event) {
    if (/* 鼠标移出 */) {
        parent_->changeState(new ButtonStateNormal()); // 切换回“正常”状态
        return true;
    }
    if (/* 鼠标按下 */) {
        parent_->changeState(new ButtonStatePress()); // 切换到“按下”状态
        return true;
    }
    return false;
}
```

**按下状态 (ButtonStatePress)** 的逻辑也类似。注意，现在每个类只关心自己的职责，代码清晰简洁。

### 步骤 3: 改造 `HUDButton`，让它成为一个纯粹的“上下文”

最后，我们来“净化”`HUDButton`。它不再需要任何布尔标志和复杂的逻辑判断。

```cpp
// src/screen/hud_button.h
class ButtonState; // 前向声明
class HUDButton : public ObjectScreen {
protected:
    Sprite* sprite_normal_ = nullptr;
    Sprite* sprite_hover_ = nullptr;
    Sprite* sprite_press_ = nullptr;
    ButtonState* button_state_ = nullptr; // 只持有当前状态的指针
    bool is_trigger_ = false;
public:
    // 核心：状态转换方法
    void changeState(ButtonState* button_state);
    // ...
};

// src/screen/hud_button.cpp
void HUDButton::changeState(ButtonState *button_state)
{
    if (button_state_) {
        button_state_->onExit(); // 调用旧状态的退出逻辑
        button_state_->setNeedRemove(true);
    }
    button_state_ = button_state;
    // ... 设置新状态
    button_state_->onEnter(); // 调用新状态的进入逻辑
    safeAddChild(button_state_);
}
```

现在的 `HUDButton` 变得非常“干净”。它将所有事件都传递给当前的 `button_state_` 对象去处理，自己只负责提供资源（三个 `Sprite` 指针）和执行状态切换的“仪式”。

## ✨ 总结

通过应用状态模式，我们获得了巨大的收益：

  * **单一职责原则**：每个状态的行为都被封装在各自的类中。`HUDButton` 的职责也变得单一，只作为状态的管理者（上下文）。
  * **开闭原则**：如果要增加一个“禁用”状态，我们只需创建一个 `ButtonStateDisabled` 类，然后在需要的地方调用 `changeState` 即可。**完全不需要修改 `HUDButton` 和任何已有的状态类**。
  * **代码清晰可读**：我们用清晰的、可插拔的 `State` 对象，取代了混乱的、交织在一起的 `if-else` 逻辑。代码的可维护性和可读性得到了质的飞跃。

状态模式是管理具有复杂状态的对象行为的终极武器。无论是游戏中的角色（站立、行走、攻击、防御），还是UI元素，甚至是游戏流程（开始菜单、游戏中、暂停、游戏结束），都可以用状态模式来优雅地构建。