# 对象池模式 (Object Pool) - 循环利用，杜绝浪费

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1aBJ8zqEeT&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * **理解性能瓶颈**：认识到在游戏主循环中频繁使用 `new` 和 `delete` 会导致的**性能开销**与**内存碎片**问题。
  * **掌握对象池原理**：学习通过“预分配、再利用”的核心思想来管理对象生命周期。
  * **实践与泛化**：首先为“玩家子弹”实现一个具体的对象池，然后将其重构为一个**泛用的模板类**，并应用到更多对象上。

## 🤔 当前代码的问题在哪里？

`SDLShooter` 是一个飞行射击游戏，子弹、敌人、爆炸特效等对象被以极高的频率创建和销毁。让我们看看 `SceneMain.cpp` 中的代码片段：

```cpp
// src/SceneMain.cpp (旧代码)
void SceneMain::shootPlayer()
{
    // 每发射一颗子弹，就在堆上分配一次内存
    auto projectile = new ProjectilePlayer(projectilePlayerPrototype);
    projectilesPlayer.push_back(projectile);
}

void SceneMain::updatePlayerProjectiles(float deltaTime)
{
    for (auto it = projectilesPlayer.begin(); it != projectilesPlayer.end();) {
        // ...
        if (/* 子弹超出屏幕或击中敌人 */) {
            // 子弹销毁，释放内存
            delete *it;
            it = projectilesPlayer.erase(it);
        }
        // ...
    }
}
```

几乎每一帧，我们都在重复 `new` 和 `delete` 的循环。这种做法存在两大性能杀手：

1.  **高昂的内存分配开销**：`new` (`malloc`) 和 `delete` (`free`) 是相对缓慢的操作系统调用。在对性能要求极致的游戏主循环中反复执行，会消耗大量 CPU 时间，可能导致**游戏卡顿或掉帧**。
2.  **内存碎片化 (Memory Fragmentation)**：频繁申请和释放大小不一的小块内存，会导致整个内存空间像一块被挖了无数小孔的“瑞士奶酪”。虽然总的可用内存很多，但可能没有一块足够大的连续空间来满足未来的内存申请，最终导致程序崩溃。

## 📖 第一步：为玩家子弹构建一个具体的对象池

对象池模式的思想很简单，就像一个餐厅会**清洗并重复使用餐具**，而不是为每个新顾客都买一套新餐具。

**核心思想**：在游戏开始时，一次性创建出足够多的对象并放入“池”中。当需要新对象时，从池中取出一个；当对象不再需要时，不销毁它，而是将其“归还”到池中。

<img src="https://theorhythm.top/gamedev/opt/OPT58.webp" alt="对象池模式" style="display: block; margin: auto; width: 800px;" />

### Step 1: 改造子弹结构

为了让对象池能够管理这些“待用”的子弹，我们需要一种方式将它们串联起来。最简单高效的方法就是 **链表**。我们在 `ProjectilePlayer` 结构体中添加一个指向同类型对象的指针 `next`，这样就能将所有空闲的子弹链接成一个“空闲列表 (free list)”。

同时，我们对游戏做一些平衡性微调，让射击体验更好。

**`src/Object.h`**

```cpp
// ... 其他结构体 ...

struct ProjectilePlayer{
    SDL_Texture* texture = nullptr;
    ProjectilePlayer* next = nullptr; // 新增：用于构建空闲列表的指针
    SDL_FPoint position = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 800; // 调整
    int damage = 1;
};

// ... 其他代码 ...
```

### Step 2: 创建对象池类 `PlayerProjPool`

接下来，我们创建一个专门用于管理玩家子弹的对象池。

**`src/PlayerProjPool.h` (新建文件)**

```cpp
#ifndef PLAYER_PROJ_POOL_H
#define PLAYER_PROJ_POOL_H

#include "Object.h"
#include <vector>

class PlayerProjPool{
private:
    size_t poolSize;
    std::vector<ProjectilePlayer> pool; // 存储所有对象的连续内存块
    ProjectilePlayer* firstAvailable = nullptr; // 指向第一个可用对象的指针

public:
    // 构造函数：初始化池子
    PlayerProjPool(ProjectilePlayer projectilePlayerPrototype, size_t pool_size = 20):poolSize(pool_size){
        pool.reserve(poolSize); // 1. 预分配足够内存
        firstAvailable = &pool[0]; // 2. 将可用指针指向第一个对象

        // 3. 遍历所有对象，将它们链接成一个链表
        for (size_t i = 0; i < poolSize; i++){
            pool[i] = projectilePlayerPrototype; // 拷贝原型数据
            pool[i].next = &pool[i + 1];
        }
        // 链表末尾指向nullptr
        pool[poolSize - 1].next = nullptr;
    }

    // create(): 从池子中获取一个对象
    ProjectilePlayer* create(){
        if (firstAvailable == nullptr){
            // 如果池子已空，可以返回nullptr、抛出异常或动态扩容
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "No more objects in pool");
            return nullptr;
        }
        // 1. 暂存当前可用的对象
        ProjectilePlayer* result = firstAvailable;
        // 2. 将可用指针后移到下一个
        firstAvailable = firstAvailable->next;
        return result;
    }

    // release(): 将对象归还到池子
    void release(ProjectilePlayer* object){
        // 将归还的对象插入到空闲列表的头部
        object->next = firstAvailable;
        firstAvailable = object;
    }
};

#endif
```

这个类的逻辑非常清晰：

1.  **构造函数**：在创建对象池时，它就一次性地在 `std::vector<ProjectilePlayer> pool` 中创建了 `poolSize` 个子弹对象。由于 `vector` 保证了其内部元素是 **内存连续** 的，这对于CPU缓存非常友好。然后，它通过 `next` 指针将这些对象串成一个链表，`firstAvailable` 指向链表头，即第一个可用的对象。
2.  **`create()` 方法**：当需要一个子弹时，它从链表头部取下一个节点，并将 `firstAvailable` 指针后移。这个操作仅仅是几个指针的赋值，比 `new` 快几个数量级。
3.  **`release()` 方法**：当子弹需要被“销毁”时，它被重新插入到链表的头部，等待下一次被 `create()` “复活”。

### Step 3: 在 `SceneMain` 中使用对象池

现在，我们将新的对象池集成到主游戏场景中。

**`src/SceneMain.h`**

```cpp
#include "Scene.h"
#include "Object.h"
#include "PlayerProjPool.h" // 1. 包含头文件
#include <list>
// ...

class SceneMain : public Scene{
// ...
private:
    // ... 其他成员变量 ...

    // 创建每个物体的原型 (将 template 重命名为 prototype 更准确)
    Enemy enemyPrototype;
    ProjectilePlayer projectilePlayerPrototype;
    // ...

    // 2. 创建对象池指针
    PlayerProjPool* playerProjPool = nullptr;

    // ... 其他成员变量 ...
};
```

**`src/SceneMain.cpp`**

```cpp
// 在 init() 中初始化对象池
void SceneMain::init()
{
    // ... 其他初始化 ...

    // 初始化原型
    projectilePlayerPrototype.texture = IMG_LoadTexture(game.getRenderer(), "assets/image/laser-1.png");
    SDL_QueryTexture(projectilePlayerPrototype.texture, NULL, NULL, &projectilePlayerPrototype.width, &projectilePlayerPrototype.height);
    projectilePlayerPrototype.width /= 4;
    projectilePlayerPrototype.height /= 4;
    
    // ... 初始化其他原型 ...

    // 初始化内存池
    playerProjPool = new PlayerProjPool(projectilePlayerPrototype);
}

// 在 clean() 中清理对象池
void SceneMain::clean()
{
    // ... 其他清理 ...

    // 清理内存池
    if (playerProjPool != nullptr){
        delete playerProjPool;
    }

    // ... 其他清理 ...
}

// 修改射击逻辑
void SceneMain::shootPlayer()
{
    // 不再使用 new
    // auto projectile = new ProjectilePlayer(projectilePlayerPrototype);
    auto projectile = playerProjPool->create();
    if (projectile == nullptr) return; // 池子可能已满

    projectile->position.x = player.position.x + player.width / 2 - projectile->width / 2;
    projectile->position.y = player.position.y;
    projectilesPlayer.push_back(projectile);
    Mix_PlayChannel(-1, sounds["shoot"], 0);
    player.lastShootTime = SDL_GetTicks();
}

// 修改子弹更新与销毁逻辑
void SceneMain::updatePlayerProjectiles(float deltaTime)
{
    // ...
    for (auto it = projectilesPlayer.begin(); it != projectilesPlayer.end();)
    {
        // ...
        // 检查子弹是否超出屏幕
        if (projectile->position.y + margin < 0){
            // 不再使用 delete
            // delete projectile;
            playerProjPool->release(projectile); // 归还到池子
            it = projectilesPlayer.erase(it);
        }else {
            bool hit = false;
            // ... 碰撞检测 ...
            if (SDL_HasIntersection(&enemyRect, &projectileRect)){
                enemy->currentHealth -= projectile->damage;
                // 不再使用 delete
                // delete projectile;
                playerProjPool->release(projectile); // 归还到池子
                it = projectilesPlayer.erase(it);
                hit = true;
                // ...
            }
            // ...
        }
    }
}
```

至此，我们已经成功地将玩家子弹的创建和销毁过程重构为了对象池模式。运行游戏，你会发现功能和以前完全一样，但在底层，我们已经消除了玩家射击时频繁的 `new` 和 `delete` 调用，为游戏的性能和稳定性迈出了一大步。

-----

## 📖 第二步：泛化与优化

我们为玩家子弹 `ProjectilePlayer` 实现了一个对象池，这很棒。但游戏中还有敌机子弹 `ProjectileEnemy`，未来可能还有爆炸特效 `Explosion`、掉落物 `Item` 等等。难道我们要为每一种对象都复制粘贴一个 `XxxPool` 类吗？当然不！这违反了 **DRY (Don't Repeat Yourself)** 原则。

是时候使用C++的强大特性——**模板 (Template)**——来创建一个通用的对象池了。

### Step 1: 创建模板类 `ObjectPool<T>`

我们将 `PlayerProjPool.h` 的代码作为基础，将其改造成一个模板类。这样，我们就可以用 `ObjectPool<ProjectilePlayer>`、`ObjectPool<ProjectileEnemy>` 等方式来实例化任何类型的对象池。

**`src/PlayerProjPool.h` (删除此文件)**

**`src/ObjectPool.h` (新建文件)**

```cpp
#ifndef OBJECT_POOL_H
#define OBJECT_POOL_H

#include "Object.h"
#include <vector>

template<typename T> // 声明为模板类
class ObjectPool{
private:
    size_t poolSize;
    std::vector<T> pool;
    T* firstAvailable = nullptr;

public:
    ObjectPool(T Prototype, size_t pool_size = 20):poolSize(pool_size){
        // 使用resize并传入原型，可以直接完成所有对象的初始化
        pool.resize(poolSize, Prototype); 

        firstAvailable = &pool[0];
        // 链接空闲列表
        for (size_t i = 0; i < poolSize - 1; i++){
            pool[i].next = &pool[i + 1];
        }
        pool[poolSize - 1].next = nullptr;
    }

    // create() 和 release() 的逻辑完全相同，只需将类型替换为 T
    T* create(){
        if (firstAvailable == nullptr){
            SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, "No more objects in pool");
            return nullptr;
        }
        T* result = firstAvailable;
        firstAvailable = firstAvailable->next;
        return result;
    }

    void release(T* object){
        object->next = firstAvailable;
        firstAvailable = object;
    }
};

#endif
```

这个通用对象池和之前的 `PlayerProjPool` 几乎一模一样，只是把所有 `ProjectilePlayer` 的地方都换成了模板参数 `T`。

### Step 2: 内存微优化 - `union` 的妙用

我们的对象池实现已经非常高效了，但还有一个小小的优化点可以探索。

观察 `ProjectilePlayer` 结构体，`next` 指针和 `position` 坐标，它们的使用场景是 **互斥的**：

  * 当一个子弹在对象池的“空闲列表”中时，我们只需要 `next` 指针来维护链表结构，它的 `position` 是没有意义的。
  * 当一个子弹被“取出”，在游戏中飞行时，我们只需要 `position` 来更新和渲染它，它的 `next` 指针是没有意义的。

既然这两个成员变量不会同时被使用，我们就可以让它们 **共享同一块内存空间**。这就是 `union` (共用体) 的作用。

**`src/Object.h`**

```cpp
struct ProjectilePlayer{
    SDL_Texture* texture = nullptr;
    union { // 里面的成员变量共用同一块内存
        ProjectilePlayer* next; // 在池中时有意义
        SDL_FPoint position;    // 在游戏中使用时有意义
    };

    int width = 0;
    int height = 0;
    int speed = 800;
    int damage = 1;
};

struct ProjectileEnemy{
    SDL_Texture* texture = nullptr;
    union {
        ProjectileEnemy* next = nullptr;
        SDL_FPoint position;
    };
    
    SDL_FPoint direction = {0, 0};
    int width = 0;
    int height = 0;
    int speed = 400;
    int damage = 1;
};
```

通过使用 `union`，每个子弹对象的大小都能减少一个指针或一个坐标的大小（通常是8个字节），虽然不多，但在对象数量极大时也能节省可观的内存。这更是一种追求极致优化的编程思想的体现。

### Step 3: 全面应用通用对象池

现在，我们把新的 `ObjectPool<T>` 应用到游戏中，不仅用于玩家子弹，也用于敌机子弹。

**`src/SceneMain.h`**

```cpp
#include "Object.h"
#include "ObjectPool.h" // 1. 替换头文件
#include <list>
// ...

class SceneMain : public Scene{
// ...
private:
    // ... 原型 ...

    // 2. 创建对象池指针 (使用模板)
    ObjectPool<ProjectilePlayer>* playerProjPool = nullptr;
    ObjectPool<ProjectileEnemy>* enemyProjPool = nullptr;

    // ... 容器 ...
};
```

**`src/SceneMain.cpp`**

```cpp
// 在 init() 中初始化所有对象池
void SceneMain::init()
{
    // ... 初始化原型 ...

    // 初始化内存池
    playerProjPool = new ObjectPool<ProjectilePlayer>(projectilePlayerPrototype);
    enemyProjPool = new ObjectPool<ProjectileEnemy>(projectileEnemyPrototype);
}

// 在 clean() 中清理所有对象池
void SceneMain::clean()
{
    // ... 清理其他资源 ...
    if (playerProjPool != nullptr){
        delete playerProjPool;
    }
    if (enemyProjPool != nullptr){
        delete enemyProjPool;
    }
    // ...
}

// 在 shootEnemy() 中使用对象池
void SceneMain::shootEnemy(Enemy *enemy)
{
    // auto projectile = new ProjectileEnemy(projectileEnemyPrototype);
    auto projectile = enemyProjPool->create();
    if (projectile == nullptr) return;

    projectile->position.x = enemy->position.x + enemy->width / 2 - projectile->width / 2;
    projectile->position.y = enemy->position.y + enemy->height / 2 - projectile->height / 2;
    projectile->direction = getDirection(enemy);
    projectilesEnemy.push_back(projectile);
    enemy->lastShootTime = SDL_GetTicks();
}

// 在 updateEnemyProjectiles() 中使用对象池
void SceneMain::updateEnemyProjectiles(float deltaTime)
{
    // ...
    // 检查子弹是否超出屏幕
    if (/*...超出屏幕的判断...*/){
        // delete projectile;
        enemyProjPool->release(projectile); // 归还
        it = projectilesEnemy.erase(it);
    } else {
        // ...
        // 检查与玩家的碰撞
        if (SDL_HasIntersection(&projectileRect, &playerRect) && !isDead){
            player.currentHealth -= projectile->damage;
            // delete projectile;
            enemyProjPool->release(projectile); // 归还
            it = projectilesEnemy.erase(it);
            // ...
        } else {
            it++;
        }
    }
    // ...
}
```

## ✨ 总结

通过对象池模式，我们获得了革命性的性能提升：

  * **告别性能瓶颈**：将昂贵的动态内存分配转移到加载阶段的一次性操作，游戏运行中的对象获取与回收变成了**近乎无成本的指针交换**。
  * **消除内存碎片**：所有池化对象都存储在 `std::vector` 的**连续内存**中，从根本上杜绝了内存碎片问题。
  * **提高缓存命中率**：连续的内存布局使得 CPU 在遍历这些对象时，可以更有效地利用缓存（Cache），这在处理大量对象（如弹幕游戏）时，会带来惊人的性能增益。
  * **代码高度复用**：通过模板编程，我们用一个 `ObjectPool<T>` 类就满足了所有类型对象的池化需求。

对象池是游戏开发中必不可少的基础优化模式，也是构建高性能、高同屏数量游戏系统的基石。