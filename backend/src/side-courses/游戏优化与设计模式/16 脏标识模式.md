# 脏标识模式 (Dirty Flag)

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1fhnbzjEsA&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

**脏标识模式 (Dirty Flag Pattern)**是一个简单但极其有效的优化技巧，它的核心思想是**避免不必要的重复计算**。

本节课将分为两部分。在第一部分，我们将首先发现文本渲染中存在的性能问题，并通过引入**缓存**来初步优化。然后，我们会发现单纯的缓存并不完美，从而引出脏标识模式的必要性。

---

# Part 1: 缓存与性能陷阱

## 🎯 课程目标

*   **识别性能热点**：分析 `TextRenderer` 中频繁创建和销毁 `TTF_Text` 对象所带来的性能开销。
*   **应用缓存模式**：为 `TextRenderer` 实现一个简单的 `TTF_Text` 对象缓存，避免重复创建。
*   **发现缓存的问题**：理解单纯的缓存策略会导致不必要的重复计算（如每帧都调用 `TTF_SetTextFont`），从而为引入脏标识模式埋下伏笔。

## 🤔 当前代码的问题在哪里？

在我们的引擎中，`TextRenderer` 负责所有的文本绘制工作。让我们仔细看看 `drawUIText` 的实现：

**`src/engine/render/text_renderer.cpp` (旧代码)**
```cpp
void TextRenderer::drawUIText(std::string_view text, ..., const glm::vec2 &position, ...)
{
    TTF_Font* font = resource_manager_->getFont(...);
    // ...
    // 1. 每一次绘制，都创建一个临时的 TTF_Text 对象
    TTF_Text* temp_text_object = TTF_CreateText(text_engine_, font, text.data(), 0);
    // ...
    // 2. 绘制文本
    TTF_DrawRendererText(temp_text_object, ...);
    // ...
    // 3. 绘制完成后，立即销毁它
    TTF_DestroyText(temp_text_object);
}
```
问题显而易见：对于像分数、生命值这样每帧都需要重绘的UI文本，我们正在**每一帧**都进行 `TTF_CreateText` 和 `TTF_DestroyText` 的循环。`TTF_CreateText` 并不是一个廉价的操作，它涉及到内存分配和字形（glyph）的初步处理。在游戏主循环中频繁执行，会带来不必要的CPU开销。

这和我们在第10课中遇到的“对象池”问题非常相似：**频繁地创建和销毁同一种类型的对象是一种性能浪费**。

## 📖 第一步：为 `TextRenderer` 添加缓存

我们的第一反应自然是引入**缓存**，这和对象池的思想如出一辙。我们将创建一个 `std::unordered_map`，用于存储已经创建过的 `TTF_Text` 对象，避免重复创建。

### Step 1: 改造 `TextRenderer`

我们在 `TextRenderer` 中添加一个 `text_cache_` 成员变量，并为其设计一个自定义删除器，以配合 `std::unique_ptr` 自动管理 `TTF_Text` 对象的生命周期。

**`src/engine/render/text_renderer.h` (修改)**
```cpp
#pragma once
// ...
#include <unordered_map>
#include <memory>

class TextRenderer final {
private:
    // TTF_Text 的删除器
    struct TTFTextDeleter {
        void operator()(TTF_Text* text) const { if (text) TTF_DestroyText(text); }
    };

    // ...
    // 缓存 TTF_Text 对象
    std::unordered_map<uintptr_t, std::unique_ptr<TTF_Text, TTFTextDeleter>> text_cache_;
    // ...

public:
    // ...
    // 新增两个版本，一个用于一次性绘制，一个用于缓存绘制
    void drawUIText(std::string&& text, ...); // 右值引用版本，用于临时文本
    void drawUIText(const std::string& text, ...); // const左值引用版本，用于持久文本

private:
    // 新增辅助函数
    TTF_Text* getTTFText(const std::string& text);
    TTF_Text* createTTFText(const std::string& text, TTF_Font* font);
};
```
我们用 `std::string` 对象的**内存地址** (`uintptr_t`) 作为 `map` 的键。这是一个巧妙但有风险的技巧：我们假设每个UI标签（如 `UILabel`）的 `text_` 成员在其生命周期内地址是固定的。这样，`score_label->getText()` 在每次调用时返回的字符串地址都是相同的，我们就可以用这个地址作为唯一标识符来存取缓存。

> **警告**：使用地址作为键需要非常小心。如果字符串对象被移动或重新分配内存，地址就会改变，导致缓存失效。在这里，由于 `UILabel` 的 `text_` 成员是稳定的，这种做法是相对安全的。

### Step 2: 实现缓存逻辑

现在我们来实现新的 `drawUIText` 的缓存版本。

**`src/engine/render/text_renderer.cpp` (修改)**
```cpp
void TextRenderer::drawUIText(const std::string& text, ..., const glm::vec2 &position, ...)
{
    TTF_Font* font = resource_manager_->getFont(...);
    // ...
    
    // 1. 尝试从缓存获取 TTF_Text 对象
    auto text_object = getTTFText(text);
    if (!text_object) {
        // 2. 如果缓存中没有，则创建一个新的并存入缓存
        text_object = createTTFText(text, font);
        if (!text_object) return;
    }

    // 3. (问题所在！) 无论如何，每帧都重新设置字体和文本内容
    TTF_SetTextFont(text_object, font);
    TTF_SetTextString(text_object, text.data(), 0);

    // ... 绘制阴影和文本 ...
}

TTF_Text* TextRenderer::getTTFText(const std::string& text) {
    auto cach_key = reinterpret_cast<uintptr_t>(&text);
    auto it = text_cache_.find(cach_key);
    return (it != text_cache_.end()) ? it->second.get() : nullptr;
}

TTF_Text* TextRenderer::createTTFText(const std::string& text, TTF_Font* font) {
    auto cach_key = reinterpret_cast<uintptr_t>(&text);
    TTF_Text* text_object = TTF_CreateText(text_engine_, font, text.data(), 0);
    if (text_object) {
        text_cache_[cach_key] = std::unique_ptr<TTF_Text, TTFTextDeleter>(text_object);
    }
    return text_object;
}
```
我们还保留了之前的一次性绘制版本（通过接受 `std::string&&` 右值引用来区分），用于绘制那些不需要缓存的、临时的文本。

```cpp
// src/game/scene/game_scene.cpp (新增测试代码)
void GameScene::render() {
    Scene::render();
    // 按住 K 键时，每帧都绘制一个临时文本，它将使用一次性绘制的版本
    if (context_.getInputManager().isActionDown("attack")) {
        context_.getTextRenderer().drawUIText("Hello, World!", ...);
    }
}
```
至此，我们成功地为持久化文本（如分数标签）实现了 `TTF_Text` 对象的缓存，避免了每帧的 `new/delete` 开销。这是一个巨大的进步！

## 🤔 缓存带来的新问题：不必要的重复计算

我们的缓存策略看起来很完美，但仔细观察 `drawUIText` 的缓存版本，你会发现一个微妙的性能陷阱：

```cpp
// ...
// (问题所在！) 无论如何，每帧都重新设置字体和文本内容
TTF_SetTextFont(text_object, font);
TTF_SetTextString(text_object, text.data(), 0);
// ...
```
`TTF_SetTextFont` 和 `TTF_SetTextString` 这两个函数，特别是前者，可能会触发 `SDL_ttf` 内部对字形纹理的重新计算和准备，这同样是昂贵的操作。

考虑一下我们的分数标签：它的**文本内容** (`"Score: 10"`)、**字体** (`VonwaonBitmap-16px.ttf`) 和**字号** (`16`) 在绝大多数帧里都是**不变的**。只有当玩家得分时，它的内容才会改变。然而，我们当前的代码在**每一帧**都在调用 `TTF_SetTextFont` 和 `TTF_SetTextString`，即使内容和字体完全没有变化。

这就是典型的**无效重复计算**。我们虽然缓存了 `TTF_Text` 对象本身，但没有缓存它的“状态”。我们理想中的逻辑应该是：

*   **仅当**文本内容、字体或字号**发生改变时**，才去调用 `TTF_SetText...` 函数。
*   在其他情况下，直接使用缓存中已经配置好的 `TTF_Text` 对象进行绘制。

如何才能知道数据“是否发生了改变”呢？这正是**脏标识模式**将要解决的问题。

## ✨ 小结 (Part 1)

在这一部分，我们迈出了优化的第一步，但也遇到了新的挑战：

*   **识别性能瓶颈**：我们定位到 `TextRenderer` 中对 `TTF_Text` 的频繁创建和销毁是一个性能热点。
*   **应用缓存**：通过实现 `TTF_Text` 对象的缓存，我们避免了不必要的内存分配和释放，这是正确的优化方向。
*   **发现新问题**：我们意识到，单纯的缓存对象是不够的。如果不控制昂贵状态更新函数的调用时机，依然会造成性能浪费。

我们现在面临一个明确的问题：如何只在必要的时候更新 `TTF_Text` 对象的状态？这个问题的答案，就在下一部分——脏标识模式的正式登场。

---

# Part 2: 按需更新，避免浪费

## 🎯 课程目标

*   **掌握脏标识模式**：学习如何使用一个简单的布尔标志（“脏”标志）来跟踪对象的状态，以延迟或避免昂贵的计算。
*   **重构 `UILabel` 和 `TextRenderer`**：
    *   在 `UILabel` 中添加一个 `is_dirty_` 标志。
    *   修改 `UILabel` 的 `setText`, `setFont` 等方法，让它们在改变数据时只设置脏标志，而不是立即重新计算尺寸。
    *   修改 `TextRenderer` 的绘制和尺寸计算函数，让它们检查脏标志，只在为 `true` 时才执行昂贵的 `TTF_SetText...` 更新操作。
*   **实现延迟计算 (Lazy Evaluation)**：将 `UILabel` 的尺寸计算推迟到真正需要它的时候（即 `getSize()` 被调用时）。

## 📖 什么是脏标识模式？

脏标识模式的思想极其简单：
1.  为一个对象关联一个布尔标志，我们称之为“脏”标志。初始状态下，标志为 `false` (干净)。
2.  当对象的内部数据发生改变时（例如，`UILabel` 的文本被修改），我们**不立即执行**任何昂贵的更新操作。我们只做一件事：将脏标志设置为 `true`。
3.  在未来的某个时刻（通常是渲染或更新循环中），当需要使用该对象的最终计算结果时，我们**首先检查**脏标志。
    *   如果标志为 `false` (干净)，说明数据没有变过，我们可以直接使用上一次的计算结果。
    *   如果标志为 `true` (脏)，说明数据已变，我们**此时才执行**昂贵的更新计算，然后将脏标志重置为 `false` (干净)，并缓存新的计算结果供后续使用。

这个模式就像一个洗衣篮。你不会每扔进一件脏衣服就立刻跑去开洗衣机。你会先把脏衣服攒在篮子里（设置脏标志），等到洗衣篮满了或者你需要干净衣服的时候（检查脏标志），才一次性把所有脏衣服都洗了（执行昂贵计算）。

<img src="https://theorhythm.top/gamedev/opt/OPT.031.webp" alt=脏标识模式" style="display: block; margin: auto; width: 800px;" />

## 📖 第一步：在 `UILabel` 中引入脏标志

我们将为 `UILabel` 添加一个 `is_dirty_` 成员，并在所有修改其核心数据（文本、字体、字号）的 `set` 方法中更新这个标志。

**`src/engine/ui/ui_label.h` (修改)**
```cpp
// ...
class UILabel final : public UIElement, public engine::interface::Observer {
private:
    // ...
    bool is_dirty_ = true; // 初始为 true，确保第一次渲染时会更新
    // ...
public:
    // ...
    const glm::vec2& getSize() override; // 重写父类方法，实现延迟计算
    // ...
    void setText(std::string_view text);
    void setFontId(std::string_view font_id);
    void setFontSize(int font_size);
    // ...
};
```

**`src/engine/ui/ui_label.cpp` (修改)**
```cpp
// ...
void UILabel::setText(std::string_view text)
{
    text_ = text;
    is_dirty_ = true;   // 数据变了，标记为“脏”，但不做任何计算！
}

void UILabel::setFontId(std::string_view font_id)
{
    font_id_ = font_id;
    is_dirty_ = true;   // 同上
}

void UILabel::setFontSize(int font_size)
{
    font_size_ = font_size;
    is_dirty_ = true;   // 同上
}

// ...
```
现在，`UILabel` 的 `set` 方法变得非常轻量，它们只改变数据和标志位，没有任何昂贵的函数调用。

## 📖 第二步：实现延迟计算 (Lazy Evaluation)

之前，我们在 `UILabel` 的 `set` 方法中立即调用 `text_renderer_.getTextSize()` 来更新 `size_` 成员。这是一种**即时计算 (Eager Evaluation)**。现在，我们将其改为**延迟计算 (Lazy Evaluation)**。

我们重写 `UIElement::getSize()` 方法。只有当外部代码（比如布局系统）真正需要知道标签尺寸时，`getSize()` 才会被调用。这时，我们才去执行尺寸计算。

**`src/engine/ui/ui_label.h` (修改)**
```cpp
// 在 UIElement 中，将 getSize() 声明为 virtual
const virtual glm::vec2& getSize() { return size_; }
```
**`src/engine/ui/ui_label.cpp` (修改)**
```cpp
const glm::vec2& UILabel::getSize() {
    // 只有在需要尺寸时，才调用昂贵的计算函数
    size_ = text_renderer_.getTextSize(text_, font_id_, font_size_, is_dirty_);
    is_dirty_ = false; // 计算完成后，清除脏标志
    return size_;
}
```
`getTextSize` 会将脏标志 `is_dirty_` 传递给 `TextRenderer`，并在内部使用它。计算完成后，我们立即将标志设回 `false`，因为此刻 `TTF_Text` 对象的状态已经和 `UILabel` 的数据同步了。

## 📖 第三步：改造 `TextRenderer` 以响应脏标志

现在是最关键的一步。我们修改 `TextRenderer` 的 `draw...` 和 `getTextSize` 方法，让它们接收一个 `is_dirty` 参数。

**`src/engine/render/text_renderer.h` (修改)**
```cpp
// ...
class TextRenderer final {
    // ...
public:
    // ...
    void drawUIText(const std::string& text, ..., bool is_dirty = true);
    glm::vec2 getTextSize(const std::string& text, ..., bool is_dirty = true);
    // ...
};
```
我们为 `is_dirty` 提供了一个默认值 `true`，以保持向后兼容（如果调用者不提供此参数，行为将和以前一样，总是更新）。

**`src/engine/render/text_renderer.cpp` (修改)**
```cpp
void TextRenderer::drawUIText(const std::string& text, ..., bool is_dirty)
{
    TTF_Text* text_object = nullptr;

    if (is_dirty) { // 只有在“脏”的时候才执行更新
        TTF_Font* font = resource_manager_->getFont(...);
        // ...
        text_object = getTTFText(text);
        if (!text_object) {
            text_object = createTTFText(text, font);
            // ...
        }

        // 昂贵的调用只在这里发生！
        TTF_SetTextFont(text_object, font);
        TTF_SetTextString(text_object, text.data(), 0);
        spdlog::info("drawUIText 重新设置了 TTF_Text 的文本和字体: {}", text);

    } else { // 如果是“干净”的
        // 直接从缓存获取已经配置好的对象
        text_object = getTTFText(text);
        if (!text_object) {
            // ... 错误处理，理论上不应该发生，因为干净意味着之前已创建
            return;
        }
    }

    // ... 绘制逻辑 ...
}
```
最后，在 `UILabel::render` 中，我们将自己的脏标志传递给 `TextRenderer`。

**`src/engine/ui/ui_label.cpp` (修改)**
```cpp
void UILabel::render(engine::core::Context& context) {
    if (!visible_ || text_.empty()) return;

    text_renderer_.drawUIText(text_, font_id_, font_size_, getScreenPosition(), text_fcolor_, is_dirty_);
    
    is_dirty_ = false; // 渲染完成后，数据和渲染结果同步了，清除脏标志
}
```
现在整个流程是这样的：
1.  `UILabel` 的文本被 `setText("Score: 20")` 修改。`is_dirty_` 变为 `true`。
2.  进入渲染循环，调用 `UILabel::render()`。
3.  `render()` 调用 `text_renderer_.drawUIText(..., is_dirty_ = true)`。
4.  `drawUIText` 发现 `is_dirty` 为 `true`，于是执行 `TTF_SetTextFont` 和 `TTF_SetTextString` 来更新缓存中的 `TTF_Text` 对象。
5.  `UILabel::render()` 执行完毕后，将 `is_dirty_` 设回 `false`。
6.  进入下一帧渲染循环，再次调用 `UILabel::render()`。
7.  `render()` 再次调用 `text_renderer_.drawUIText(..., is_dirty_ = false)`。
8.  `drawUIText` 发现 `is_dirty` 为 `false`，它会**跳过所有** `TTF_Set...` 调用，直接使用缓存中已经完美配置好的 `TTF_Text` 对象进行绘制。
9.  这个过程会一直持续，直到下一次 `setText` 被调用，脏标志再次被设置。

## ✨ 总结

通过引入脏标识模式，我们实现了高效的“按需更新”：

*   **避免冗余计算**：我们消除了在每一帧都对**未改变**的文本执行昂贵的 `SDL_ttf` 更新操作，显著提升了文本渲染的性能。
*   **实现延迟计算**：`UILabel` 的尺寸计算被推迟到了 `getSize()` 真正被调用的那一刻，避免了在 `set` 方法中可能发生的、但结果却从未使用过的计算。
*   **简单有效**：脏标识模式的实现非常简单——只需要一个布尔标志和一些 `if` 判断——但它所带来的性能收益在很多场景下都非常可观。

脏标识模式的应用非常广泛，远不止于文本渲染。在游戏中，任何涉及昂贵计算或资源更新的场景都可以考虑使用它：
*   **复杂的UI布局**：只有当某个子元素的位置或大小改变时，才重新计算整个面板的布局。
*   **寻路网格生成**：只有当地形发生变化时，才重新生成AI的寻路网格。
*   **3D模型变换**：只有当模型的位置、旋转或缩放改变时，才重新计算其世界变换矩阵，而不是每帧都算。

掌握脏标识模式，是你优化工具箱里一把锋利而轻便的“瑞士军刀”。