# 视窗裁剪 (View Frustum Culling) - 只看该看的

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1iFJVzbEjm&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * 理解**视窗裁剪 (View Frustum Culling)** 的核心原理及其在游戏性能优化中的重要性。
  * 掌握如何通过**包围盒 (Bounding Box)** 检测来判断对象是否在屏幕可视范围内。
  * 应用视窗裁剪技术，优化 `Enemy` 的 `update` 和 `render` 调用，显著提升游戏帧率。

## 🤔 当前代码的问题在哪里？

到目前为止，我们的游戏引擎虽然功能完善，但在渲染和更新逻辑上存在一个巨大的性能浪费。在我们的 `Scene::update()` 和 `Scene::render()` 方法中，我们是这样做的：

```cpp
// 伪代码
void Scene::update() {
    for (Object* child : all_children) {
        child->update();
    }
}

void Scene::render() {
    for (Object* child : all_children) {
        child->render();
    }
}
```

我们**遍历了场景中的每一个对象**，并调用了它们的 `update` 和 `render` 方法。

**问题在于**：如果一个 `Enemy` 远在世界地图的另一端，完全处于玩家的视野之外，我们真的有必要：

1.  **更新它吗？** (计算它的 AI、动画、物理状态等)
2.  **渲染它吗？** (把它和它的组件（Sprite, Collider）提交给渲染器)

答案显然是**否定的**。当屏幕上有成百上千个敌人时，对那些玩家根本看不见的对象进行更新和渲染，是对 CPU 和 GPU 资源的巨大浪费。这就是导致游戏在对象增多时帧率下降的罪魁祸首。

## 📖 视窗裁剪：“看不见，就不算”

**视窗裁剪 (View Frustum Culling)** 是一种基础且极其高效的优化技术。它的原理非常简单：**在执行更新和渲染之前，先检查一个对象是否位于摄像机的可视区域（视锥体，对于2D游戏来说就是一个矩形）内。如果不在，就直接跳过它。**

为了实现这个检测，我们通常使用一种简化的几何体来代表游戏对象，这个几何体被称为**包围体 (Bounding Volume)**。最常用的就是**轴对齐包围盒 (Axis-Aligned Bounding Box, AABB)**。

-----

## 🛠️ 重构实战：剔除屏幕外的 `Enemy`

### 步骤 1: 添加包围盒碰撞检测工具

首先，我们在 `Game` 类中添加一个通用的工具函数，用于判断两个矩形（AABB）是否相交。这将是我们实现裁剪的核心算法。

```cpp
// src/core/game.h
class Game {
    // ...
public:
    bool isRectCollideRect(const glm::vec2& rect1_top_left, const glm::vec2& rect1_botton_right, const glm::vec2& rect2_top_left, const glm::vec2& rect2_botton_right);
};

// src/core/game.cpp
bool Game::isRectCollideRect(...)
{
    // 如果两个矩形在x轴或y轴上没有任何重叠部分，则它们不相交
    if (rect1_top_left.x > rect2_botton_right.x || rect1_botton_right.x < rect2_top_left.x || rect1_top_left.y > rect2_botton_right.y || rect1_botton_right.y < rect2_top_left.y){
        return false;
    }
    return true;
}
```

### 步骤 2: 优化坐标转换时机

在之前的代码中，`ObjectWorld` 的 `render_position_` (屏幕坐标) 是在 `update` 中被**每帧更新**的，无论它是否需要被渲染。这是一个可以优化的点。我们将其修改为**懒加载 (Lazy Evaluation)**：只有在真正需要获取屏幕坐标时（即 `getRenderPosition()` 被调用时）才进行计算。

```diff
// src/core/object_world.cpp
void ObjectWorld::update(float dt)
{
    ObjectScreen::update(dt);
-   render_position_ = Game::getInstance().getCurrentScene()->worldToScreen(position_);
}

+ glm::vec2 ObjectWorld::getRenderPosition()
+ {
+   // 只在需要时才计算
+   render_position_ = Game::getInstance().getCurrentScene()->worldToScreen(position_);
+   return render_position_;
+ }
```

### 步骤 3: 在 `Enemy` 中应用裁剪逻辑

这是最核心的一步。我们在 `Enemy` 的 `update` 和 `render` 方法的**最开始**，就进行裁剪检测。

```cpp
// src/enemy.h
class Enemy : public Actor
{
public:
    // ...
    virtual void update(float dt) override;
    virtual void render() override; // 如果超出屏幕区域就不要调用绘制函数
};

// src/enemy.cpp
void Enemy::update(float dt){
    // --- Culling Check ---
    auto render_pos_start = getRenderPosition() + current_anim_->getOffset();
    auto render_pos_end = render_pos_start + current_anim_->getSize();
    // 用敌人的包围盒与屏幕的包围盒 (0, screenSize) 进行检测
    if(!Game::getInstance().isRectCollideRect(render_pos_start, render_pos_end, glm::vec2(0), Game::getInstance().getScreenSize())) {
        return; // 如果不在屏幕内，直接返回，不执行任何更新逻辑！
    }

    // --- Original Update Logic ---
    if (target_->getActive()){ /* ... */ }
    checkState();
    remove();
    Actor::update(dt);
}

void Enemy::render()
{
    // --- Culling Check ---
    auto render_pos_start = getRenderPosition() + current_anim_->getOffset();
    auto render_pos_end = render_pos_start + current_anim_->getSize();
    if(!Game::getInstance().isRectCollideRect(render_pos_start, render_pos_end, glm::vec2(0), Game::getInstance().getScreenSize())) {
        return; // 如果不在屏幕内，直接返回，不执行任何渲染逻辑！
    }
    
    SDL_Log("render enemy"); // 用于调试，确认裁剪生效
    Actor::render();
}
```

通过在 `update` 和 `render` 的入口处增加这个“**哨兵**”，我们有效地阻止了对屏幕外对象的不必要计算和绘制调用。

## ✨ 总结

视窗裁剪是一项“低投入，高回报”的优化。我们仅仅增加了几行包围盒检测代码，就获得了巨大的性能提升：

  * **CPU 节省**：跳过了屏幕外所有对象的 `update` 逻辑，包括AI计算、物理更新、动画状态机等，极大地减轻了 CPU 负担。
  * **GPU 节省**：跳过了屏幕外所有对象的 `render` 逻辑，避免了向 GPU 发送不必要的绘制指令 (Draw Call)，降低了 GPU 的负载和总线带宽的占用。
  * **可扩展性**：这种优化是可持续的。即使我们在世界中放置一万个敌人，只要玩家视野内的敌人数量是有限的，游戏就能保持流畅运行。

> 💡 **优化永无止境**
>
> 视窗裁剪只是游戏优化的冰山一角。更高级的技术还包括**遮挡剔除 (Occlusion Culling)**（剔除被其他物体挡住的对象）和**细节层次 (Level of Detail, LOD)**（远处物体使用低精度模型）等。但无论如何，视窗裁剪都是你优化工具箱中必不可少的第一把利器。