# 15 观察者模式: 解决悬垂指针问题

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV15jWAzkECH&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

这一课我们将继续探讨**观察者模式**，但焦点将从“如何实现”转向“如何安全地实现”。我们将直面传统观察者模式中最棘手的问题之一——**悬垂指针 (Dangling Pointers)**，并通过建立双向联系来构建一个更健壮、更安全的观察者系统。

## 🎯 课程目标

*   **理解悬垂指针风险**：认识到在经典的观察者模式中，如果 `Observer` 先于 `Subject` 被销毁，`Subject` 的观察者列表中就会留下一个无效的“悬垂指针”。
*   **掌握解决方案**：学习通过在 `Observer` 和 `Subject` 之间建立**双向联系**来解决此问题。
*   **重构观察者系统**：
    *   在 `Observer` 中添加一个 `Subject` 列表。
    *   在 `Observer` 的析构函数中，自动通知其订阅的所有 `Subject` 将自己从它们的观察者列表中移除。
    *   修改 `Subject` 的 `addObserver` 和 `removeObserver` 方法，以维护这种双向关系。

## 🤔 问题的根源：单向依赖与生命周期不匹配

让我们回顾一下上一课实现的观察者模式。`Subject` (如 `HealthComponent`) 持有一个 `std::vector<Observer*>` 列表，而 `Observer` (如 `GameScene`) 对 `Subject` 一无所知。这是一种**单向**的依赖关系。

<img src="https://theorhythm.top/gamedev/opt/OPT.029.webp" alt="悬垂指针" style="display: block; margin: auto; width: 800px;" />

这种设计的隐患在于**生命周期管理**。考虑以下场景：

1.  `GameScene` (Observer) 订阅了 `player` 的 `HealthComponent` (Subject)。
2.  `HealthComponent` 的 `observers_` 列表中现在有一个指向 `GameScene` 实例的指针。
3.  游戏流程发生变化，`GameScene` 被销毁了（比如切换到了 `TitleScene`）。
4.  在 `GameScene` 销毁前，**我们忘记了**调用 `health_component->removeObserver(this)`。
5.  `GameScene` 的内存被释放，但 `HealthComponent` 的 `observers_` 列表中那个指针**依然存在**，它现在指向一块无效的内存——这就是一个**悬垂指针**。
6.  稍后，玩家受到伤害，`HealthComponent` 调用 `notifyObservers()`。当它试图通过那个悬垂指针调用 `observer->onNotify()` 时，程序会尝试访问非法内存，导致**未定义行为**，通常表现为**程序崩溃**。

这个问题非常普遍且难以调试，因为它依赖于对象的销毁顺序和程序员是否记得手动解除订阅。一个健壮的系统不应该依赖于程序员的记忆。

## 📖 解决方案：建立双向联系

要从根本上解决这个问题，我们需要让 `Observer` 也“知道”它订阅了哪些 `Subject`。这样，当 `Observer` 即将被销毁时，它可以主动地、自动地通知所有它订阅过的 `Subject`：“我要消失了，请把我从你们的列表中移除！”

### Step 1: 改造 `Observer` 接口

我们为 `Observer` 添加一个 `std::vector<Subject*>` 成员 `subjects_`，用于记录它订阅的所有 `Subject`。

**`src/engine/interface/observer.h` (修改)**
```cpp
#pragma once
#include <any>
#include <vector>

namespace engine::interface {
    class Subject; // 前向声明

class Observer {
    friend class Subject; // 允许 Subject 调用其私有方法
private:
    std::vector<Subject*> subjects_; // 记录所有订阅的 Subject

public:
    virtual ~Observer(); // 析构函数实现将移至 .cpp

    virtual void onNotify(const EventType event, const std::any& data) = 0;

private:
    // 这组方法只应由 Subject 调用，以维护双向链接的完整性
    void addSubject(Subject* subject);
    void removeSubject(Subject* subject);
    void clearSubjects();
};

} // namespace engine::interface 
```
最关键的改动在析构函数 `~Observer()`。我们将在 `.cpp` 文件中实现它，让它在对象销毁的最后一刻，遍历 `subjects_` 列表并完成“自我移除”的壮举。

**`src/engine/interface/observer.cpp` (新建)**
```cpp
#include "observer.h"
#include "subject.h"
#include <algorithm>

namespace engine::interface {

Observer::~Observer() {
    clearSubjects(); // 在析构时自动清理所有订阅关系
}

void Observer::addSubject(Subject* subject) {
    subjects_.push_back(subject);
}

void Observer::removeSubject(Subject* subject) {
    subjects_.erase(std::remove(subjects_.begin(), subjects_.end(), subject), subjects_.end());
}

void Observer::clearSubjects() {
    // 遍历所有订阅的 Subject
    for (auto* subject : subjects_) {
        if (subject) {
            // 让 Subject 移除对自身的引用
            subject->removeObserver(this);
        }
    }
    subjects_.clear();
}

} // namespace engine::interface
```
现在，任何 `Observer` 子类的实例在被销毁时，都会自动执行 `clearSubjects()`，确保它从所有 `Subject` 的列表中被安全移除。

### Step 2: 改造 `Subject` 接口

`Subject` 的 `addObserver` 和 `removeObserver` 方法现在需要承担额外的责任：维护双向链接。

**`src/engine/interface/subject.h` (修改)**
```cpp
// ...
class Subject {
    // ...
public:
    virtual ~Subject(); // 析构函数实现移至 .cpp

    void addObserver(Observer* observer);
    void removeObserver(Observer* observer);
    void clearObservers();

protected:
    void notifyObservers(const EventType& event, const std::any& data);
};
```

**`src/engine/interface/subject.cpp` (新建)**
```cpp
#include "subject.h"
#include "observer.h"
#include <algorithm>
// ...

namespace engine::interface {

Subject::~Subject() {
    clearObservers(); // Subject 销毁时，也需要解除与所有 Observer 的联系
}

void Subject::addObserver(Observer* observer) {
    // ... (检查 observer 是否为空和是否已存在) ...
    
    // 1. 将 observer 添加到自己的列表
    observers_.push_back(observer);
    // 2. 通知 observer，让它也将自己（this）添加到其 subject 列表
    observer->addSubject(this);
}

void Subject::removeObserver(Observer* observer) {
    auto it = std::find(observers_.begin(), observers_.end(), observer);
    if (it != observers_.end()) {
        observers_.erase(it);
        // 只有当 Subject 主动移除 Observer 时，才需要通知 Observer
        // 如果是 Observer 析构时调用，则不需要再次通知
        if(observer) observer->removeSubject(this); 
    }
}

void Subject::clearObservers() {
    for (auto* observer : observers_) {
        if (observer) {
            // 通知所有 observer 解除对自己的订阅
            observer->removeSubject(this);
        }
    }
    observers_.clear();
}
// ...
} // namespace engine::interface
```
现在，`addObserver` 和 `removeObserver` 不再是简单的 `vector` 操作，它们是建立和断开**双向链接**的原子操作。

### Step 3: 验证与清理

我们的重构已经完成！`GameScene`、`UILabel`、`HealthComponent` 等类的代码完全不需要任何改动。我们只是强化了 `Observer` 和 `Subject` 这两个基类的内部实现。

现在，我们甚至可以移除之前为安全起见在 `GameScene` 构造函数中添加的代码：

**`src/game/scene/game_scene.cpp` (修改)**
```cpp
GameScene::GameScene(...)
{
    // ...
    // game_session_data_->clearObservers(); // 不再需要！
    // 因为当旧场景（比如另一个GameScene实例）被销毁时，
    // 它的析构函数（继承自Observer）会自动将自己从 session_data_ 的列表中移除。
    spdlog::trace("GameScene 构造完成。");
}
```
我们的观察者模式现在是“生命周期安全的”。无论 `Observer` 和 `Subject` 谁先被销毁，它们之间的链接都会被安全地、自动地断开，彻底杜绝了悬垂指针的风险。

## ✨ 总结

在本节课中，我们为经典的观察者模式打上了一个重要的“安全补丁”，解决了其最令人头疼的悬垂指针问题。

*   **识别风险**：我们认识到，单向依赖关系在对象生命周期不匹配时会导致悬垂指针和程序崩溃。
*   **建立双向链接**：通过让 `Observer` 记录其订阅的 `Subject`，我们获得了在 `Observer` 销毁时**主动**解除订阅关系的能力。
*   **自动化生命周期管理**：我们将解绑逻辑放在了 `Observer` 和 `Subject` 的**析构函数**中，利用 C++ 的 RAII (资源获取即初始化) 特性，将手动、易错的解绑操作变成了自动、可靠的机制。

这个改进版的观察者模式更加健壮，大大降低了开发者的心智负担。虽然它增加了一点点内存开销（每个 `Observer` 多了一个 `vector`），但在现代应用中，这点开销换来的**程序稳定性**和**安全性**是完全值得的。在构建大型、复杂的事件系统时，这种健壮的设计是必不可少的。