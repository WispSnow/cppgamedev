# 外观模式与策略模式 - 简化接口，封装变化

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV19nHozDEw9&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

*   **理解外观模式 (Facade)**：学习如何为复杂的子系统提供一个统一、简化的接口，降低模块间的耦合度。
*   **识别项目中的外观**：在 `SunnyLand` 代码中，找出 `ResourceManager` 是如何作为经典的外观模式应用的。
*   **理解策略模式 (Strategy)**：学习如何定义一系列算法，将它们各自封装，并使它们可以相互替换，从而让算法的变化独立于使用它的客户。
*   **识别项目中的策略**：分析 `AIComponent` 是如何利用策略模式，灵活地为不同敌人配置巡逻、跳跃等不同行为的。

在 `SunnyLand` 项目中，我们已经不自觉地使用了这两种模式。本节课的目标就是将它们明确地指出来，让你理解其设计思想，从而能在未来的项目中更主动、更优雅地运用它们。

## 📖 外观模式 (Facade Pattern) - 复杂系统的“总服务台”

想象一下你去一家大公司办事。你不需要知道财务部在哪、人事部在哪、技术支持又在哪。你只需要走到前台（总服务台），告诉前台你的需求，前台就会帮你联系相应的部门处理。这个“前台”就扮演了外观的角色。

**外观模式**的核心思想是：**为一组复杂的子系统接口提供一个更高级别的、统一的接口。** 客户端只需要与这个统一的接口（外观）交互，而不需要了解内部子系统的复杂实现和相互关系。

<img src="https://theorhythm.top/gamedev/opt/OPT.004.webp" alt="外观模式" style="display: block; margin: auto; width: 800px;" />

### 🤔 项目中的问题场景（假如没有外观模式）

在我们的引擎中，资源管理是一个复杂的系统，它包含：

*   **TextureManager**：负责加载、缓存和卸载 `SDL_Texture`。
*   **AudioManager**：负责加载、缓存和卸载 `Mix_Chunk` (音效) 和 `Mix_Music` (音乐)。
*   **FontManager**：负责加载、缓存和卸载不同字号的 `TTF_Font`。

如果没有一个统一的管理者，那么任何需要资源的代码（比如 `SpriteComponent`、`AudioPlayer`、`TextRenderer`）都必须分别持有这三个管理器的实例，并调用它们各自的接口。代码会变得像这样：

```cpp
// 伪代码：假如没有 ResourceManager
class SpriteComponent {
    TextureManager* texManager;
    //...
    void render() {
        SDL_Texture* tex = texManager->getTexture(...);
        //...
    }
};

class AudioPlayer {
    AudioManager* audioManager;
    //...
    void playSound() {
        Mix_Chunk* chunk = audioManager->getSound(...);
        //...
    }
};
```

这会导致客户端代码与多个子系统紧密耦合，非常混乱且难以维护。

### ✨ `ResourceManager`：一个经典的外观

<img src="https://theorhythm.top/gamedev/opt/OPT.005.webp" alt="外观模式2" style="display: block; margin: auto; width: 800px;" />

幸运的是，我们的 `ResourceManager` 完美地解决了这个问题。它正是外观模式的体现。

**`src/engine/resource/resource_manager.h`**

```cpp
class ResourceManager final{
private:
    // 内部封装了复杂的子系统
    std::unique_ptr<TextureManager> texture_manager_;
    std::unique_ptr<AudioManager> audio_manager_;
    std::unique_ptr<FontManager> font_manager_;

public:
    explicit ResourceManager(SDL_Renderer* renderer);
    // ...

    // --- 统一资源访问接口 (外观接口) ---
    SDL_Texture* getTexture(std::string_view file_path);
    Mix_Chunk* getSound(std::string_view file_path);
    Mix_Music* getMusic(std::string_view file_path);
    TTF_Font* getFont(std::string_view file_path, int point_size);
    // ... 其他接口 ...
};
```

`ResourceManager` 将 `TextureManager`、`AudioManager` 和 `FontManager` 的复杂性完全隐藏了起来。任何需要资源的代码（客户端），只需要与 `ResourceManager` 这一个“总服务台”打交道。

**客户端使用范例 (`src/engine/audio/audio_player.cpp`)**

```cpp
// AudioPlayer 只需要知道 ResourceManager
int AudioPlayer::playSound(std::string_view sound_path, int channel) {
    // 通过统一接口获取资源，无需关心内部实现
    Mix_Chunk* chunk = resource_manager_->getSound(sound_path);
    if (!chunk) {
        // ...
        return -1;
    }
    // ...
}
```

通过外观模式，我们实现了：
1.  **解耦**：客户端与复杂的资源管理子系统解耦，只依赖于简单的外观接口。
2.  **简化**：客户端的使用变得极其简单，提升了开发效率。
3.  **封装**：未来如果想替换某个子系统（比如把 `SDL_mixer` 换成 `FMOD`），只需要修改 `ResourceManager` 内部，客户端代码完全不受影响。

---

## 📖 策略模式 (Strategy Pattern) - 行为的“热插拔”

假设你在开发一个AI系统，敌人有多种行为模式：一种只会在地面左右巡逻，一种会在空中上下飞行，还有一种会不停地跳跃。你会怎么实现？

最直接的想法可能是在 `AIComponent::update` 中写一个巨大的 `switch` 或 `if-else` 结构：

```cpp
// 伪代码：不好的设计
void AIComponent::update(float dt) {
    switch (enemyType) {
        case PATROL:
            // ... 巡逻逻辑 ...
            break;
        case FLYING:
            // ... 上下飞行逻辑 ...
            break;
        case JUMPING:
            // ... 跳跃逻辑 ...
            break;
    }
}
```
这种做法的问题显而易见：`AIComponent` 类会变得越来越臃肿，每次增加一种新行为，都必须修改这个类，违反了 **开闭原则**（对扩展开放，对修改关闭）。

**策略模式** 优雅地解决了这个问题。它将每一种行为（算法）都封装到一个独立的对象中，让它们可以互相替换。

<img src="https://theorhythm.top/gamedev/opt/OPT.007.webp" alt="策略模式" style="display: block; margin: auto; width: 800px;" />

### ✨ `AIComponent` 与 `AIBehavior`：一个标准的策略模式实现

在 `SunnyLand` 项目中，我们的 AI 系统就是策略模式的绝佳范例。

<img src="https://theorhythm.top/gamedev/opt/OPT.008.webp" alt="策略模式2" style="display: block; margin: auto; width: 800px;" />

#### 1. The Strategy Interface (策略接口): `AIBehavior`

我们首先定义了一个所有具体行为都必须遵守的“合同”——`AIBehavior` 抽象基类。

**`src/game/component/ai/ai_behavior.h`**
```cpp
class AIBehavior {
public:
    virtual ~AIBehavior() = default;
protected:
    // 定义了一个统一的接口，所有具体策略都必须实现它
    virtual void update(float, AIComponent&) = 0;
    virtual void enter(AIComponent&) {} // 进入行为时的可选初始化
};
```

#### 2. Concrete Strategies (具体策略): `PatrolBehavior`, `UpDownBehavior`, `JumpBehavior`

然后，我们将每一种敌人的行为逻辑分别封装在独立的类中，它们都继承自 `AIBehavior`。

**`src/game/component/ai/patrol_behavior.h`**
```cpp
// 巡逻策略
class PatrolBehavior final : public AIBehavior {
private:
    void update(float delta_time, AIComponent& ai_component) override;
    // ...
};
```
**`src/game/component/ai/updown_behavior.h`**
```cpp
// 上下飞行策略
class UpDownBehavior final : public AIBehavior {
private:
    void update(float delta_time, AIComponent& ai_component) override;
    // ...
};
```
**`src/game/component/ai/jump_behavior.h`**
```cpp
// 跳跃策略
class JumpBehavior final : public AIBehavior {
private:
    void update(float delta_time, AIComponent& ai_component) override;
    // ...
};
```

#### 3. The Context (上下文): `AIComponent`

`AIComponent` 就是使用这些策略的“上下文”。它持有一个指向 `AIBehavior` 的指针，但它不关心具体是哪种行为。它的 `update` 方法只是简单地将工作 **委托** 给当前持有的行为对象。

**`src/game/component/ai_component.h`**
```cpp
class AIComponent final : public engine::component::Component {
private:
    // 持有一个策略接口的指针
    std::unique_ptr<ai::AIBehavior> current_behavior_ = nullptr;
    // ...
public:
    // 允许在运行时动态切换策略
    void setBehavior(std::unique_ptr<ai::AIBehavior> behavior);
    // ...
private:
    void update(float delta_time, engine::core::Context&) override;
};
```
**`src/game/component/ai_component.cpp`**
```cpp
void AIComponent::update(float delta_time, engine::core::Context&) {
    // 将工作委托给当前的行为策略对象
    if (current_behavior_) {
        current_behavior_->update(delta_time, *this);
    }
}
```

#### 4. 组装与应用

最后，在 `GameScene` 初始化敌人时，我们根据敌人的类型，为它的 `AIComponent` “装配”上对应的行为策略。

**`src/game/scene/game_scene.cpp`**
```cpp
bool GameScene::initEnemyAndItem()
{
    // ...
    for (auto& game_object : game_objects_){
        if (game_object->getName() == "eagle"){
            if (auto* ai_component = game_object->addComponent<game::component::AIComponent>(); ai_component){
                // ...
                // 为老鹰装配“上下飞行”策略
                ai_component->setBehavior(std::make_unique<game::component::ai::UpDownBehavior>(y_min, y_max));
            }
        }
        if (game_object->getName() == "frog"){
            if (auto* ai_component = game_object->addComponent<game::component::AIComponent>(); ai_component){
                // ...
                // 为青蛙装配“跳跃”策略
                ai_component->setBehavior(std::make_unique<game::component::ai::JumpBehavior>(x_min, x_max));
            }
        }
        // ...
    }
    return true;
}
```
通过策略模式，我们实现了：
1.  **封装变化**：每种AI行为的逻辑都封装在自己的类中，相互独立。
2.  **开闭原则**：未来要增加新的AI行为（比如“追踪玩家”），我们只需创建一个新的 `TraceBehavior` 类，而无需修改任何现有代码。
3.  **灵活性**：我们甚至可以在游戏运行时通过 `setBehavior()` 动态改变敌人的行为模式（比如 boss 进入第二阶段）。

> **旁注：策略模式 vs 状态模式**
> 你可能会发现，`PlayerComponent` 和 `PlayerState` 的结构与策略模式几乎一模一样。这其实是 **状态模式 (State Pattern)**。
>
> *   **策略模式**：侧重于**封装可互换的算法**。客户端主动选择使用哪个策略。
> *   **状态模式**：侧重于**管理对象内部状态的变迁**。状态的切换通常由当前状态对象或上下文内部逻辑决定。
>
> 尽管意图不同，但它们的类图结构是相同的，都是面向接口编程、实现行为委托的典范。

## ✨ 总结

本节课我们没有写一行新功能的代码，而是回顾了项目中已有的优秀结构，并为它们贴上了“设计模式”的标签。

*   **外观模式 (Facade)**：通过 `ResourceManager`，我们学会了如何用一个简单的“门面”来隐藏一个复杂系统的内部细节，从而降低耦合，简化客户端代码。
*   **策略模式 (Strategy)**：通过 `AIComponent` 和 `AIBehavior`，我们学会了如何将不同的行为算法封装成独立的对象，使得它们可以灵活地组合和替换，让代码更符合开闭原则，易于扩展。

理解并运用这些模式，是从业余爱好者向专业软件工程师进阶的关键一步。它们能帮助你写出更清晰、更健壮、更能适应未来变化的高质量代码。