# 装饰模式 (Decorator) - 在运行时为对象“穿上”新功能

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1ZSnqzKE3Q&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

**装饰模式 (Decorator Pattern)**是一个结构型设计模式，它允许你**在运行时动态地**向对象添加新的功能或行为，而无需修改其源代码。

本节课将紧接上一课的服务定位器模式，展示如何利用装饰模式为我们的音频系统“穿上”一层日志记录的功能，并且这个功能可以像开关一样，在编译时轻松地启用或禁用。

## 🎯 课程目标

*   **理解装饰模式**：学习如何通过“包装”对象的方式，在不改变其接口的前提下，为其附加额外的职责。
*   **识别应用场景**：认识到当需要为一个类添加多种可选功能（如日志、缓存、性能分析）时，装饰模式是比继承更好的选择。
*   **实践装饰模式**：
    *   创建一个 `LogAudioPlayer` 装饰器类，它同样实现 `IAudioPlayer` 接口。
    *   `LogAudioPlayer` 内部持有一个 `IAudioPlayer` 实例（被包装的对象）。
    *   在它的每个方法中，先执行日志记录，然后调用被包装对象的同名方法。
*   **结合CMake实现条件编译**：学习如何使用 CMake 的 `option()` 和 `target_compile_definitions()` 来创建一个编译开关，从而在不修改C++代码的情况下，控制是否启用日志装饰器。

## 🤔 当前代码的问题在哪里？（或者说，我们想实现什么？）

我们的 `AudioPlayer` 目前工作得很好，但假设在开发和调试阶段，我们希望**记录下每一次音频播放的调用**，以便追踪声音是否被正确触发。

最直接的想法是直接修改 `AudioPlayer` 的代码：

**`src/engine/audio/audio_player.cpp` (不好的做法)**
```cpp
int AudioPlayer::playSound(std::string_view sound_path, int channel) {
    spdlog::info("正在播放音效: {}", sound_path); // 在这里添加日志
    
    Mix_Chunk* chunk = resource_manager_->getSound(sound_path);
    // ...
}
```
这种做法的问题在于：
1.  **违反开闭原则**：为了增加一个新功能（日志），我们修改了现有类的代码。
2.  **功能耦合**：日志记录的逻辑和音频播放的逻辑被混在了一起。
3.  **不够灵活**：如果我们想在发布版本中关闭这些日志（因为它们会带来性能开销），我们就必须回去把这些 `spdlog` 代码删掉或用 `#ifdef` 包围起来，非常麻烦。如果未来还想添加性能分析、错误重试等功能，`AudioPlayer` 会变得越来越臃肿。

我们真正想要的是一种能够**像插件一样**、按需为 `AudioPlayer` 附加功能的方法。这就是装饰模式的用武之地。

## 📖 装饰模式的核心思想

装饰模式就像给一个普通人穿上不同的衣服，赋予他不同的能力：穿上宇航服就能上太空，穿上潜水服就能下深海。但无论穿什么，他本质上还是那个人。

**核心思想**：创建一个“装饰器”类，它与被装饰的对象**实现相同的接口**。装饰器内部持有一个被装饰对象的实例，并将所有请求转发给它。在转发请求的前后，装饰器可以执行额外的操作。

由于装饰器和被装饰对象有相同的接口，客户端可以毫无察觉地使用装饰后的对象。更妙的是，装饰器可以被**层层嵌套**，就像套娃一样，为对象叠加多种功能。

<img src="https://theorhythm.top/gamedev/opt/OPT.038.webp" alt="装饰模式" style="display: block; margin: auto; width: 800px;" />

## 📖 第一步：创建 `LogAudioPlayer` 装饰器

我们将创建一个 `LogAudioPlayer` 类，它将作为 `IAudioPlayer` 的一个装饰器。

**`src/engine/audio/log_audio_player.h` (新建)**
```cpp
#pragma once
#include "iaudio_player.h"
#include <memory>
#include <spdlog/spdlog.h>

namespace engine::audio {

class LogAudioPlayer final : public IAudioPlayer {
private:
    std::unique_ptr<IAudioPlayer> wrapped_; // “包装”着另一个 IAudioPlayer 对象

public:
    // 构造时接收一个被包装的对象
    explicit LogAudioPlayer(std::unique_ptr<IAudioPlayer> wrapped) : wrapped_(std::move(wrapped)) {}
    ~LogAudioPlayer() = default;

    // --- 在每个方法中，先打日志，再调用被包装对象的方法 ---
    int playSound(std::string_view sound_path, int channel = -1) override {
        spdlog::info("LogAudioPlayer: 播放音频: {}", sound_path);
        return wrapped_->playSound(sound_path, channel);
    }

    bool playMusic(std::string_view music_path, int loops = -1, int fade_in_ms = 0) override {
        spdlog::info("LogAudioPlayer: 播放音乐: {}", music_path);
        return wrapped_->playMusic(music_path, loops, fade_in_ms);
    }
    
    // ... 其他所有 IAudioPlayer 方法的实现 ...
};

} // namespace engine::audio
```
这个类的结构非常清晰：
1.  它也实现了 `IAudioPlayer` 接口，所以从外部看，它就是一个音频播放器。
2.  它通过 `std::unique_ptr<IAudioPlayer> wrapped_` 持有另一个 `IAudioPlayer` 的实例。这个 `wrapped_` 对象可以是真正的 `AudioPlayer`，也可以是另一个装饰器！
3.  在它实现的每个方法中，它首先执行自己的附加职责（打印日志），然后将原始请求**委托**给 `wrapped_` 对象去执行。

## 📖 第二步：利用 CMake 和宏在 `GameApp` 中动态“穿上”装饰器

现在，我们如何决定何时使用 `AudioPlayer`，何时使用 `LogAudioPlayer` 呢？我们可以利用 CMake 和C++的预处理器宏来创建一个编译时开关。

### Step 1: 在 CMakeLists.txt 中添加开关

我们添加一个 `option`，让开发者在配置 CMake 时可以选择是否启用音频日志。

**`CMakeLists.txt` (修改)**
```cmake
# ...

# 创建一个名为 ENABLE_AUDIO_LOG 的开关，描述为“启用音频日志”，默认值为 ON
option(ENABLE_AUDIO_LOG "启用音频日志" ON)

# 检查开关的状态
if(ENABLE_AUDIO_LOG)
    # 如果开关为 ON，就为我们的目标（可执行文件）添加一个编译定义
    # 这相当于在编译所有源文件时都加上了 -DENABLE_AUDIO_LOG 选项
    target_compile_definitions(${TARGET} PRIVATE ENABLE_AUDIO_LOG)
endif()

# ...
```
现在，我们可以在编译时通过 `cmake .. -DENABLE_AUDIO_LOG=OFF` 来轻松关闭这个功能。

### Step 2: 在 `GameApp` 中根据宏来应用装饰器

在 `GameApp::initAudioPlayer` 中，我们使用 `#ifdef` 来检查 `ENABLE_AUDIO_LOG` 这个宏是否被定义。

**`src/engine/core/game_app.cpp` (修改)**
```cpp
#include "../audio/audio_player.h"
#include "../audio/log_audio_player.h" // 包含装饰器头文件
#include "../audio/audio_locator.h"
// ...

bool GameApp::initAudioPlayer()
{
    try {
        // 1. 首先，总是创建一个基础的 AudioPlayer 实例
        audio_player_ = std::make_unique<engine::audio::AudioPlayer>(resource_manager_.get());
        audio_player_->setMusicVolume(config_->music_volume_);
        audio_player_->setSoundVolume(config_->sound_volume_);

// 2. 如果 ENABLE_AUDIO_LOG 宏被定义...
#ifdef ENABLE_AUDIO_LOG
        // ...就用 LogAudioPlayer 把刚才创建的 audio_player_ “包”起来
        audio_player_ = std::make_unique<engine::audio::LogAudioPlayer>(std::move(audio_player_));
#endif

        // 3. 最后，将最终的对象（可能是原始的，也可能是装饰过的）注册到服务定位器
        engine::audio::AudioLocator::provide(audio_player_.get());
    } catch (...) {
        // ...
    }
    return true;
}
```
这段代码非常巧妙：
*   无论开关是否打开，我们都会创建一个 `AudioPlayer` 实例。
*   如果 `ENABLE_AUDIO_LOG` 被定义，我们就创建一个 `LogAudioPlayer`，并将刚刚创建的 `AudioPlayer` 实例**移动**给它作为被包装的对象。`audio_player_` 这个 `unique_ptr` 现在指向了 `LogAudioPlayer` 实例。
*   如果宏未定义，这段代码块在预处理阶段就会被完全移除，`audio_player_` 依然指向原始的 `AudioPlayer` 实例。
*   最后，`AudioLocator::provide()` 接收到的 `audio_player_.get()`，可能是 `AudioPlayer*`，也可能是 `LogAudioPlayer*`。但由于它们都实现了 `IAudioPlayer` 接口，服务定位器和所有客户端代码都毫不在意，它们只会通过接口调用方法。

现在运行游戏，你会看到控制台输出了所有音频播放的日志。然后，尝试用 `cmake .. -DENABLE_AUDIO_LOG=OFF` 重新配置并编译，再次运行游戏，日志就消失了。我们实现了一个**零运行时开销**的、可配置的功能开关！

## ✨ 总结

装饰模式为我们提供了一种极其灵活的对象功能扩展方式：

*   **遵循开闭原则**：我们为 `AudioPlayer` 添加了日志功能，却没有修改 `AudioPlayer` 的任何一行代码。
*   **运行时动态组合**：虽然本例中我们使用了编译时开关，但装饰模式完全支持在运行时根据条件决定是否以及如何装饰对象。比如，我们可以只在“调试模式”下为对象添加日志装饰器。
*   **避免子类爆炸**：想象一下，我们还有 `CachedAudioPlayer` 和 `ProfilingAudioPlayer` 两种功能。如果用继承，我们就需要创建 `LogCachedAudioPlayer`, `LogProfilingAudioPlayer`, `CachedProfilingAudioPlayer`, `LogCachedProfilingAudioPlayer`... 各种组合，导致类的数量急剧膨胀。而使用装饰模式，我们可以像搭积木一样，按需将它们组合起来：
    ```cpp
    auto player = std::make_unique<AudioPlayer>(...);
    player = std::make_unique<CachedAudioPlayer>(std::move(player));
    player = std::make_unique<LogAudioPlayer>(std::move(player));
    player = std::make_unique<ProfilingAudioPlayer>(std::move(player));
    ```
*   **与服务定位器完美结合**：服务定位器依赖于接口，而装饰模式正是通过共享接口来实现透明包装的。这两者结合，使得我们可以轻松地为全局服务添加或移除各种横切关注点（cross-cutting concerns）如日志、缓存、权限控制等。

装饰模式是面向对象设计中一个优雅而强大的工具，它体现了“**组合优于继承**”的设计原则。当你需要为对象添加功能，但又不希望通过继承来创建一大堆子类时，就应该考虑使用装饰模式。