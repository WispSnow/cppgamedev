# 责任链模式 (Chain of Responsibility) - 事件的传递与处理

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1uYGdzHEVG&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * 理解责任链模式的**核心思想**：将请求的发送者和接收者解耦，让多个对象都有机会处理这个请求，并将这些对象连成一条链，沿着这条链传递该请求，直到有一个对象处理它为止。
  * 学习如何利用**游戏场景图（Scene Graph）**这一天然的树形结构来实现责任链模式。
  * 通过重构，将**输入事件处理**的责任从 `Player` 下放给 `MoveControl` 组件，并实现一个有趣的“**角色附身**”效果。

## 🤔 当前代码的问题在哪里？

在上一课中，我们成功地将移动控制逻辑封装到了 `MoveControl` 类中，这是一个巨大的进步。但是，事件处理的流程仍然不够理想：

1.  **控制权不够灵活**：`MoveControl` 只是一个**被动**的状态容器。它自己不处理输入，而是由 `Player::handleEvents` 来读取键盘状态，并调用 `setMoveControl` 来切换实例。`Player` 仍然是输入处理的“决策中心”。
2.  **责任不够下放**：我们希望 `MoveControl` 成为一个完全独立的组件，它应该**自己负责处理输入事件**，并**直接影响其父对象**（`Actor`）的状态。`Player` 不应该关心 `MoveControl` 的内部实现。
3.  **潜力未被挖掘**：既然“移动控制”已经是一个独立的组件，为什么只有 `Player` 能拥有它？如果一个 `Enemy` 也能拥有这个组件，会怎么样？我们当前的设计将 `move_control_` 成员放在 `Player` 中，限制了这种可能性。

## 📖 责任链模式：让事件“顺流而下”

<img src="https://theorhythm.top/gamedev/opt/OPT26.webp" alt="指责链模式1" style="display: block; margin: auto; width: 800px;" />

责任链模式的思想其实很简单：当一个请求（在我们的游戏中，就是一个**事件**，如键盘按下、鼠标点击）发生时，你把它交给一个对象链中的第一个对象。这个对象看看自己能不能处理，如果能，就处理掉，流程结束；如果不能，它就把这个请求**传递给链上的下一个对象**。这个过程持续下去，直到请求被处理，或者传递到链的末尾。

**现实世界类比**：想象一下公司的审批流程。你提交一份报销单，首先由你的直属经理审批（链的第一环），如果金额超出他的权限，他就会把报销单上交给他/她的上级（链的第二环），以此类推，直到找到有足够权限的管理者签字为止。

在我们的游戏中，**场景图（Scene Graph）** 就是一条天然的责任链！

<img src="https://theorhythm.top/gamedev/opt/OPT27.webp" alt="指责链模式2" style="display: block; margin: auto; width: 800px;" />

`Game::handleEvents()` -\> `Scene::handleEvents()` -\> `UI元素::handleEvents()` / `Player::handleEvents()` / `Enemy::handleEvents()` -\> `组件::handleEvents()`

一个鼠标点击事件传来，`Scene` 首先把它交给最上层的UI元素（比如暂停按钮）。

  * 如果暂停按钮发现点击位置在自己范围内，它就处理这个事件（暂停游戏），并返回 `true`，表示“事件已被处理”，事件传递就此**中断**。
  * 如果按钮发现点击位置不在自己范围内，它就返回 `false`，`Scene` 就会继续把这个事件交给下一个对象（比如玩家 `Player`），让它来判断。

这就是利用树形组合结构实现的责任链。

-----

## 🛠️ 重构实战：打造“可附身”的控制权

### 步骤 1: 强化 `MoveControl`，使其成为主动的事件处理器

我们不再让 `Player` 管理输入，而是让 `MoveControl` 自己监听并处理键盘事件，并直接更新其父对象的速度。

```cpp
// src/raw/move_control.h (关键改动)
class Actor; // 前向声明
class MoveControl : public Object
{
protected:
    // ...
    Actor* parent_ = nullptr; // 需要一个指向父对象的指针来施加影响
    float max_speed_ = 500.0f;

public:
    void update(float dt) override;
    virtual bool handleEvents(SDL_Event& event) override; // 拥有自己的事件处理函数！

    // ... setters and getters
    void setParent(Actor* actor) { parent_ = actor; }
};
```

```cpp
// src/raw/move_control.cpp (关键改动)
#include "move_control.h"
#include "../core/actor.h"

// 在 update 中直接影响父节点
void MoveControl::update(float dt)
{
    if (parent_ == nullptr) return;
    Object::update(dt);
    // 速度衰减和施加新的速度，现在是 MoveControl 的责任
    parent_->setVelocity(parent_->getVelocity() * 0.9f);
    auto direction = glm::vec2(is_right_ - is_left_, is_down_ - is_up_);
    if (glm::length(direction) > 0.1f) direction = glm::normalize(direction);
    if (glm::length(direction) > 0.1f) parent_->setVelocity(direction * max_speed_);
}

// 真正处理键盘事件的地方
bool MoveControl::handleEvents(SDL_Event &event)
{
    if (event.type == SDL_EVENT_KEY_DOWN){
        if (event.key.scancode == SDL_SCANCODE_W) is_up_ = true;
        // ... 其他按键
        return true; // 消耗掉事件
    }
    if (event.type == SDL_EVENT_KEY_UP){
        if (event.key.scancode == SDL_SCANCODE_W) is_up_ = false;
        // ... 其他按键
        return true; // 消耗掉事件
    }
    return false; // 如果不是我关心的事件，就返回 false，让链上的其他对象处理
}
```

通过这个改动，`MoveControl` 从一个数据容器，**蜕变**成了一个功能完整的、独立的事件处理单元。

### 步骤 2: 提升 `MoveControl` 的通用性

为了让任何 `Actor`（无论是 `Player` 还是 `Enemy`）都能被控制，我们将 `move_control_` 成员从 `Player` 类**提升**到其父类 `Actor` 中。

```diff
// src/core/actor.h
class Actor : public ObjectWorld
{
protected:
+   MoveControl* move_control_ = nullptr; // 移动控制
    Stats *stats_ = nullptr; // 角色属性
    // ...
public:
    // ...
+   void removeMoveControl();
+   MoveControl* getMoveControl() const { return move_control_; }
+   void setMoveControl(MoveControl *move_control);
};
```

现在，`setMoveControl` 成为了所有 `Actor` 的通用能力。

### 步骤 3: 实现“控制权转移”

这是最激动人心的部分！我们在 `Spawner`（怪物生成器）里增加一个逻辑：每当新一波敌人生成时，将**控制权从玩家身上剥离，并赋予给新生成的第一个敌人**！

```cpp
// src/spawner.cpp
void Spawner::update(float dt)
{
    // ... (计时和生成逻辑)
    for (int i = 0; i < num_; i++)
    {
        // ... (创建 enemy)
        Effect::addEffectChild(Game::getInstance().getCurrentScene(), "assets/effect/184_3.png", pos, 1.0f, enemy);
        
        // 核心：控制权转移！
        if (i == 0){
            // 1. 给第一个新生成的敌人装上“移动控制”组件
            enemy->setMoveControl(new MoveControl());
            // 2. 移除玩家身上的“移动控制”组件
            target_->removeMoveControl();
        }
    }
}
```

同时，我们让 `Player` 在失去控制权后，执行 `autoEscape` 逻辑（目前为空，但为未来的AI行为留下了接口）。

```diff
// src/player.cpp
void Player::update(float dt)
{
    Actor::update(dt);
-   velocity_ *= 0.9f;
-   moveControl();
+   if (!move_control_) autoEscape(); //如果没有移动控制，则自动逃跑
    checkState();
    move(dt);
    syncCamera();
    checkIsDead();
}
```

现在运行游戏，你会发现一个全新的玩法：游戏开始时你可以控制主角，但一旦第一波怪物刷新，你的控制权就会被“**附身**”到其中一个幽灵身上！你将扮演幽灵去追杀之前的主角。

## ✨ 总结

通过应用责任链模式，我们获得了巨大的收益：

  * **完全解耦**：事件的发送者（`Game`主循环）完全不知道谁会处理这个事件。它只是把事件投入到场景图这条“责任链”中。
  * **高度灵活**：我们可以**在运行时动态地修改这条链**，比如把处理事件的责任（`MoveControl`组件）从一个对象（`Player`）转移到另一个对象（`Enemy`），从而创造出新颖的游戏机制。
  * **职责清晰**：每个对象（`Scene`, `UI`, `MoveControl`）都只关心自己能处理的事件，不能处理的就传递下去。这让每个类的代码都更加简洁和专注。

责任链模式是构建可扩展、数据驱动的输入系统和UI系统的基石。掌握它，你就能创造出更丰富、更有趣的交互体验。
