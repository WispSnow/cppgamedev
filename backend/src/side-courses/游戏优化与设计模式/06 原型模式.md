# 原型模式 (Prototype Pattern) - 复制，而非重建

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1Xn53zBEg5&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * 理解原型模式的**核心思想**：通过**复制**一个现有的实例（原型）来创建新的对象，而不是通过 `new` 关键字和构造函数。
  * 掌握如何在 C++ 中实现 `clone()` 方法来支持原型模式。
  * 应用原型模式，将 `Weapon` 和 `Spell` 的创建过程解耦，实现**数据驱动**的武器配置。

## 🤔 当前代码的问题在哪里？

在之前的版本中，我们虽然将 `Weapon` 和 `MoveControl` 进行了组件化，但仍然存在一些僵化设计：

1.  **武器类型僵化**：我们有一个通用的 `Weapon` 基类和一个具体的 `WeaponThunder` 子类。这意味着每当我们想创造一种新武器（比如火球、冰霜），就必须创建一个新的 C++ 子类。这会导致**类爆炸**，并且很不灵活。
2.  **创建过程耦合**：在 `WeaponThunder` 的攻击逻辑中，我们是这样创建法术的：`Spell::addSpellChild(nullptr, "assets/effect/Thunderstrike...", ...)`。这使得 `WeaponThunder` **必须知道**创建雷电法术所需的所有参数（贴图路径、伤害值、大小等）。如果法术的构造函数改变了，所有使用它的武器类都得跟着改。

我们理想中的系统应该是：`Weapon` 类不关心它发射的是什么法术，它只负责“在某个时机，在某个位置，发射一个法术”。法术“长”什么样，有什么效果，应该由法术自己决定。

-----

## 📖 第一步：实现基础原型

原型模式正是为了解决上述问题。它的核心是让一个“原型”对象实现一个 `clone()` 方法，这个方法能够返回一个与自己一模一样的新对象。

<img src="https://theorhythm.top/gamedev/opt/OPT41.webp" alt="原型模式" style="display: block; margin: auto; width: 800px;" />

**现实世界类比**：想象一下细胞分裂。一个细胞（原型）分裂成两个完全相同的新细胞（克隆体）。我们不需要从零开始，用各种蛋白质和分子（构造函数参数）去“构建”一个新细胞。

### 步骤 1: 让 `Spell` 能够“克隆”自己

我们在 `Spell` 类中添加一个 `clone()` 方法。这个方法会调用 `addSpellChild` 静态函数，并使用自身已有的属性（如图纸路径、伤害、大小）来创建一个全新的、一模一样的 `Spell` 实例。

```cpp
// src/world/spell.h
class Spell : public ObjectWorld
{
protected:
    std::string file_path_; // 保存这些变量是为了克隆
    float scale_ = 1.0f;
    // ...
public:
    Spell* clone();
    // ...
};

// src/world/spell.cpp
Spell *Spell::clone()
{
    // 调用静态创建函数，用自己的属性来创建一个副本
    return addSpellChild(
        Game::getInstance().getCurrentScene(), 
        file_path_, 
        getPosition(), 
        damage_, 
        scale_, 
        sprite_->getAnchor()
    );
}
```

### 步骤 2: 改造 `Weapon`，让它持有“法术原型”

我们现在可以移除 `WeaponThunder` 这个子类了，让 `Weapon` 变成一个通用的、可配置的类。它的核心改动是：不再关心具体的法术创建，而是持有一个 `Spell*` 成员，我们称之为 `spell_prototype_`。

```cpp
// src/raw/weapon.h
class Weapon : public Object
{
protected:
    Actor* parent_ = nullptr;
    Spell* spell_prototype_ = nullptr; // 持有一个法术原型！
    // ...
public:
    void attack(glm::vec2 position);
    // ... getters and setters
    void setSpellPrototype(Spell* spell) { spell_prototype_ = spell; }
};
```

### 步骤 3: 在攻击时“克隆”原型

现在，`Weapon` 的攻击逻辑变得极其简单和通用。它不需要知道法术的任何细节，只需要调用原型对象的 `clone()` 方法，然后设置新克隆出来法术的位置即可。

```cpp
// src/raw/weapon.cpp
void Weapon::attack(glm::vec2 position)
{
    if (!spell_prototype_ || !canAttack()) return;
    
    // ... (处理冷却和法力消耗)

    // 关键：不再是 new Spell()，而是 clone()！
    auto spell = spell_prototype_->clone();
    spell->setPosition(position);
    // clone() 内部已经将 spell 添加到场景中了
}
```

### 步骤 4: 在 `Player` 中“配置”武器

最后，我们在 `Player::init()` 中完成武器的“组装”。我们先创建一个“雷电法术”的实例，但**不激活它**（`setActive(false)`），让它成为一个隐藏的“原型”。然后，我们把这个原型交给 `Weapon`。

```cpp
// src/player.cpp
void Player::init()
{
    // ...
    // 创建一个通用的 Weapon 组件
    weapon_ = Weapon::addWeaponChild(this, 2.0f, 40.0f);

    // 创建一个法术原型，并隐藏它
    auto spell_prototype = Spell::addSpellChild(
        Game::getInstance().getCurrentScene(), 
        "assets/effect/Thunderstrike w blur.png", 
        glm::vec2(0), 40.0f, 3.0f, Anchor::CENTER
    );
    spell_prototype->setActive(false);

    // 将原型“安装”到武器上
    weapon_->setSpellPrototype(spell_prototype);
    // ...
}
```

至此，我们完成了第一步重构。`Weapon` 和 `Spell` 成功解耦！`Weapon` 现在是一个通用的发射器，它可以发射任何**支持 `clone()` 方法的 `Spell` 对象**。

-----

## 📖 第二步：利用原型模式实现武器多样性

原型模式的威力不止于此。它让我们能够通过**配置数据**而非**编写代码**来创造多样性。现在，我们来给玩家添加第二把武器——火球术，而**无需创建任何新的 C++ 类**。

<img src="https://theorhythm.top/gamedev/opt/OPT45.webp" alt="原型模式2" style="display: block; margin: auto; width: 800px;" />

### 步骤 1: 升级 `clone()` 接口

为了让克隆成为一种通用能力，我们可以在基类 `ObjectWorld` 中定义一个虚函数 `clone()`。这样，任何继承自 `ObjectWorld` 的对象都有了“可克隆”的潜力。

```diff
// src/core/object_world.h
class ObjectWorld : public ObjectScreen
{
public:
    // ...
+   virtual ObjectWorld* clone() { return nullptr; } // 需要用到clone的子类进行重写
};

// src/world/spell.h
class Spell : public ObjectWorld
{
public:
    // ...
-   Spell* clone();
+   virtual Spell* clone() override;
};
```

### 步骤 2: 在 `Player` 中配置第二把武器

这步操作和配置第一把武器几乎完全一样，只是使用了不同的资源和参数。

```cpp
// src/player.cpp
void Player::init()
{
    // ... (第一把武器的配置不变)

    // 配置第二把武器 (weapon2_)
    weapon2_ = Weapon::addWeaponChild(this, 1.0f, 10.0f); // 不同的CD和蓝耗

    // 创建一个新的“火球”法术原型
    auto spell_prototype2 = Spell::addSpellChild(
        Game::getInstance().getCurrentScene(), 
        "assets/effect/Explosion 2 SpriteSheet.png", // 不同的贴图
        glm::vec2(0), 20.0f, 3.0f, Anchor::CENTER
    );
    spell_prototype2->setActive(false);

    // 将新原型安装到第二把武器上
    weapon2_->setSpellPrototype(spell_prototype2);
    weapon2_->setSoundPath("assets/sound/fire-magic-6947.mp3"); // 不同的音效
    weapon2_->setTriggerButton(SDL_BUTTON_MIDDLE); // 不同的触发键（鼠标中键）
}
```

看！我们仅仅是通过调用 `setter` 函数，传入不同的**数据**（贴图、音效、CD、触发键），就“创造”出了一把全新的武器。这就是**数据驱动设计**的魅力。

## ✨ 总结

通过应用原型模式，我们的武器系统发生了质的飞跃：

  * **告别类爆炸**：我们不再需要为每一种武器和法术组合创建新的子类。一个通用的 `Weapon` 类和一个通用的 `Spell` 类就足够了。
  * **配置极其灵活**：武器的所有属性——它发射的法术、音效、冷却时间、触发方式——都可以在运行时动态配置。这些配置信息甚至可以从外部文件（如 JSON 或 XML）中读取，让策划人员不碰代码就能设计新武器！
  * **真正的解耦**：`Weapon` 彻底从 `Spell` 的构建细节中解放出来。它只与 `Spell` 的 `clone()` 接口交互，符合“面向接口编程”的原则。

原型模式是游戏开发中实现**可配置性**和**内容多样性**的强大工具，尤其适用于需要大量创建相似但又略有不同的对象的场景，如子弹、敌人、技能特效等。