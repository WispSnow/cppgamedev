# 工厂方法模式 (Factory Method) - 封装创建过程

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1hAEAzXEJC&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * 理解工厂方法模式的**核心思想**：定义一个用于创建对象的接口，但让子类决定实例化哪一个类。
  * 学习如何将对象的**创建逻辑**从**使用者**代码中分离出来，封装到专门的“工厂”类中。
  * 对比**工厂方法**与**原型模式**，理解它们在不同场景下的优缺点。

## 🤔 当前代码的问题在哪里？

在上一课中，我们使用**原型模式**成功地将 `Weapon` 和 `Spell` 解耦。`Player::init()` 负责创建并配置一个“法术原型”，然后将其交给 `Weapon`。`Weapon` 在攻击时只需要克隆这个原型即可。

这已经很不错了，但仍然存在一个**不够优雅**的地方：

**`Player::init()` 方法知道得太多了！**

```cpp
// src/player.cpp (旧代码)
void Player::init()
{
    // ...
    // Player 必须知道创建雷电法术的所有细节
    auto spell_prototype = Spell::addSpellChild(Game::getInstance().getCurrentScene(), "assets/effect/Thunderstrike w blur.png", glm::vec2(0), 40.0f, 3.0f, Anchor::CENTER);
    weapon_->setSpellPrototype(spell_prototype);

    // Player 也必须知道创建火球法术的所有细节
    auto spell_prototype2 = Spell::addSpellChild(Game::getInstance().getCurrentScene(), "assets/effect/Explosion 2 SpriteSheet.png", glm::vec2(0), 20.0f, 3.0f, Anchor::CENTER);
    weapon2_->setSpellPrototype(spell_prototype2);
    // ...
}
```

`Player` 本应该只关心玩家自身的逻辑，但现在它却成了配置各种法术的“大杂烩”。如果游戏中有几十种法术，`Player::init()` 方法将会变得异常臃肿和混乱。这违反了**单一职责原则**。

我们需要一种方法，将“**如何创建某个特定法术**”这个具体的知识，从 `Player` 中**抽离**出去。

-----

## 📖 工厂方法模式：“我需要一个产品，但别告诉我它是怎么造的”

工厂方法模式的核心，就是将**对象的创建过程**封装起来。

<img src="https://theorhythm.top/gamedev/opt/OPT46.webp" alt="工厂方法模式" style="display: block; margin: auto; width: 800px;" />

> **它定义一个创建产品对象的抽象方法（工厂方法），并将这个方法的具体实现留给子类。**

**现实世界类比**：
你（客户端）想喝一杯饮料（产品）。你走到一家饮品店（工厂）。你不需要知道可乐是怎么配比的，也不需要知道橙汁是怎么鲜榨的。你只需要对店员说“来一杯可乐”，可乐制作机（具体工厂）就会为你生产一杯可乐；你说“来一杯橙汁”，榨汁机（另一个具体工厂）就会为你生产一杯橙汁。

你只管**提出需求**，而**具体的创建过程**则由对应的“机器”来完成。

-----

## 🛠️ 重构实战：为每种法术建立专属“工厂”

现在，我们用工厂方法模式来重构法术的创建流程。

### 步骤 1: 定义一个抽象的“法术工厂”接口

我们首先创建一个 `SpellCreator` 接口（抽象基类），它规定了所有法术工厂都必须提供一个 `createSpell()` 方法。

```cpp
// src/raw/spell_creator.h
#ifndef SPELL_CREATOR_H
#define SPELL_CREATOR_H

#include "../core/object.h"
#include "../world/spell.h"

class SpellCreator : public Object{
public:
    // 这是一个“工厂方法”，它是一个纯虚函数，强制子类去实现
    virtual Spell* createSpell() = 0;
};

#endif // SPELL_CREATOR_H
```

### 步骤 2: 创建具体的法术工厂

现在，我们为雷电法术和火球法术分别创建具体的工厂。所有关于如何创建该法术的“知识”（贴图路径、伤害值等）都被**封装**在了各自的工厂内部。

**雷电法术工厂：**

```cpp
// src/raw/thunder_spell_creator.cpp
#include "thunder_spell_creator.h"
#include "../core/scene.h"

Spell *ThunderSpellCreator::createSpell()
{
    // 所有创建雷电法术的细节都封装在这里
    return Spell::addSpellChild(Game::getInstance().getCurrentScene(), "assets/effect/Thunderstrike w blur.png", glm::vec2(0), 40.0f, 3.0f);
}
```

**火球法术工厂：**

```cpp
// src/raw/fire_spell_creator.cpp
#include "fire_spell_creator.h"
#include "../core/scene.h"

Spell *FireSpellCreator::createSpell()
{
    // 所有创建火球法术的细节都封装在这里
    return Spell::addSpellChild(Game::getInstance().getCurrentScene(), "assets/effect/Explosion 2 SpriteSheet.png", glm::vec2(0), 20.0f, 3.0f);
}
```

### 步骤 3: 改造 `Weapon`，让它使用“工厂”而非“原型”

接下来，我们让 `Weapon` 类不再持有一个 `Spell` 原型，而是持有一个 `SpellCreator` 工厂。

```diff
// src/raw/weapon.h
class Weapon : public Object
{
protected:
    Actor* parent_ = nullptr;
-   Spell* spell_prototype_ = nullptr;
+   SpellCreator* spell_creator_ = nullptr;
    // ...
public:
    // ...
-   void setSpellPrototype(Spell* spell) { spell_prototype_ = spell; }
+   void setSpellCreator(SpellCreator* spell) { spell_creator_ = spell; }
};
```

当 `Weapon` 需要攻击时，它不再调用 `clone()`，而是请求其持有的工厂为它生产一个新的法术。

```diff
// src/raw/weapon.cpp
void Weapon::attack(glm::vec2 position)
{
-   if (!spell_prototype_ || !canAttack()) return;
+   if (!spell_creator_ || !canAttack()) return;
    // ...
-   auto spell = spell_prototype_->clone();
+   auto spell = spell_creator_->createSpell();
    spell->setPosition(position);
}
```

`Weapon` 现在完全不知道它将要发射的 `Spell` 是如何被创建的。它的职责被进一步简化了。

### 步骤 4: 简化 `Player`，让它只负责“组装”

最后，我们来看 `Player::init()` 方法，它现在变得前所未有的清爽。它不再关心任何法术的细节，只负责高层逻辑的“组装”工作。

```cpp
// src/player.cpp
void Player::init()
{
    // ...
    // 为第一把武器装配一个“雷电法术工厂”
    weapon_ = Weapon::addWeaponChild(this, 2.0f, 40.0f);
    auto thunder_spell_creator = new ThunderSpellCreator();
    weapon_->setSpellCreator(thunder_spell_creator);

    // 为第二把武器装配一个“火球法术工厂”
    weapon2_ = Weapon::addWeaponChild(this, 1.0f, 10.0f);
    auto fire_spell_creator = new FireSpellCreator();
    weapon2_->setSpellCreator(fire_spell_creator);
    // ...
}
```

## ✨ 总结：工厂方法 vs. 原型

| 特性 | **原型模式** (上一课) | **工厂方法模式** (本课) |
| :--- | :--- | :--- |
| **创建方式** | 通过 `clone()` 复制一个现有对象 | 通过 `create()` 调用工厂方法创建一个新对象 |
| **创建逻辑位置** | 分散在使用方（如`Player::init`中创建原型）| **集中**在具体的工厂类中 |
| **优点** | 性能高（内存拷贝通常比构造快），适合创建复杂对象 | **封装性好**，职责清晰，符合开闭原则 |
| **适用场景** | 当对象创建成本高，或者需要动态创建多种相似对象时 | 当需要将对象的创建与使用分离，或者由子类决定创建何种对象时 |

通过本次重构，我们：

  * **封装了创建逻辑**：将复杂的、易变的创建细节从客户端代码 (`Player`) 中移除，放入了稳定、独立的工厂类中。
  * **提升了代码可维护性**：现在，如果要修改火球的伤害，我们只需要去 `FireSpellCreator.cpp` 这一个地方修改，而不会影响到任何其他文件。
  * **遵循了开闭原则**：如果想增加一个“冰霜法术”，我们只需要新增一个 `IceSpellCreator` 类，而完全不需要修改 `Weapon` 或 `Player` 的代码。

工厂方法模式是**解耦**对象创建和使用的利器，它让我们的代码结构更加清晰，也为未来的扩展打下了坚实的基础。
