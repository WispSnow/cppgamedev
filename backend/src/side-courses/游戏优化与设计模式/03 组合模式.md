# 组合模式 (Composite Pattern) - 分解与重组

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1oTGbzWEFz&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * 理解组合模式的**核心思想**：将对象组合成树形结构以表示“部分-整体”的层次结构，并能统一地处理单个对象和组合对象。
  * 掌握**组合优于继承**的设计原则。
  * 应用组合模式重构 `Player` 类，将**输入控制**逻辑从 `Player` 中分离出来，形成一个独立的组件。

## 🤔 当前代码的问题在哪里？

在之前的版本中，`Player` 的移动控制逻辑是直接写在 `player.cpp` 里的：

```cpp
// src/player.cpp (旧代码)
void Player::keyboardControl()
{
    auto currentKeyStates = SDL_GetKeyboardState(NULL);
    if (currentKeyStates[SDL_SCANCODE_W]){
        velocity_.y = -max_speed_;
    }
    if (currentKeyStates[SDL_SCANCODE_S]){
        velocity_.y = max_speed_;
    }
    // ... A and D keys
}
```

这种“硬编码”的方式存在几个显著的缺点：

1.  **职责不单一**：`Player` 类既要负责自己的状态（移动、受伤、死亡），又要关心具体的输入设备（键盘的哪个键被按下），违反了**单一职责原则**。
2.  **扩展性差**：如果我们想增加对**方向键**的支持怎么办？或者想支持**游戏手柄**？甚至允许玩家**自定义按键**？每增加一种新的控制方式，我们都必须去修改 `Player` 类的内部代码，这违反了**开闭原则**（对扩展开放，对修改关闭）。
3.  **代码不可复用**：这套 WASD 的输入逻辑，如果将来有另一个可操控的单位也需要，我们只能复制粘贴代码，造成冗余。

## 📖 组合模式：像搭乐高一样构建对象

组合模式的精髓在于，它允许我们将对象组合成**树形结构**，并且可以用同样的方式去对待**单个对象**（叶子节点）和**对象组合**（树枝节点）。
<img src="https://theorhythm.top/gamedev/opt/OPT21.webp" alt="组合模式1" style="display: block; margin: auto; width: 800px;" />

<img src="https://theorhythm.top/gamedev/opt/OPT22.webp" alt="组合模式2" style="display: block; margin: auto; width: 800px;" />

我们游戏引擎中的**场景图 (Scene Graph)** 就是一个天然的组合模式实现：

  * `Scene` 是根节点。
  * `Player`, `Enemy` 等是 `Scene` 的子节点（可以看作是树枝）。
  * `Sprite`, `Collider` 是 `Player` 的子节点（可以看作是叶子）。

调用 `scene->update()` 时，`Scene` 会遍历并调用所有子对象的 `update()`，子对象又会调用它自己的子对象的 `update()`... 这样，无论是复杂的 `Player` 还是简单的 `Sprite`，都被 `update()` 这一操作统一处理了。

这次重构，我们将利用这种思想，将“移动控制”这个功能，从 `Player` 内部**剥离**出来，做成一个独立的、可插拔的“零件”对象。

-----

## 🛠️ 重构实战：分离 `Player` 的移动控制

### 步骤 1: 创建抽象的 `MoveControl` 基类

首先，我们定义一个“移动控制”零件的**通用接口**。它需要继承自 `Object`，这样它才能被加入到我们的场景图中。

```cpp
// src/raw/move_control.h
#ifndef MOVE_CONTROL_H
#define MOVE_CONTROL_H

#include "../core/object.h"

class MoveControl : public Object
{
protected:
    // 这四个布尔值是所有具体控制方式都需要提供的状态
    bool is_up_ = false;
    bool is_down_ = false;
    bool is_left_ = false;
    bool is_right_ = false;

public:
    // 提供统一的接口，让外部（Player）查询状态
    bool isUp() const { return is_up_; }
    bool isDown() const { return is_down_; }
    bool isLeft() const { return is_left_; }
    bool isRight() const { return is_right_; }
};

#endif // MOVE_CONTROL_H
```

### 步骤 2: 创建具体的控制类

现在，我们可以基于这个通用接口，创建出具体的控制方式。

**WASD 控制器：**

```cpp
// src/move_control_wasd.cpp
#include "move_control_wasd.h"

void MoveControlWASD::update(float dt)
{
    MoveControl::update(dt);
    auto keyboard = SDL_GetKeyboardState(NULL);
    is_up_ = keyboard[SDL_SCANCODE_W];
    is_down_ = keyboard[SDL_SCANCODE_S];
    is_left_ = keyboard[SDL_SCANCODE_A];
    is_right_ = keyboard[SDL_SCANCODE_D];
}
```

**方向键控制器：**

```cpp
// src/move_control_arrow.cpp
#include "move_control_arrow.h"

void MoveControlArrow::update(float dt)
{
    MoveControl::update(dt);
    auto keyboard = SDL_GetKeyboardState(NULL);
    is_up_ = keyboard[SDL_SCANCODE_UP];
    is_down_ = keyboard[SDL_SCANCODE_DOWN];
    is_left_ = keyboard[SDL_SCANCODE_LEFT];
    is_right_ = keyboard[SDL_SCANCODE_RIGHT];
}
```

看，现在每种控制逻辑都封装在自己的类里，职责非常清晰！

### 步骤 3: 改造 `Player` 类，让它“组合”一个 `MoveControl`

最后，我们来改造 `Player`。它不再关心具体的按键，而是持有一个 `MoveControl` 的指针，并将移动控制的任务**委托**给它。

```cpp
// src/player.h (关键改动)
class Player : public Actor
{
protected:
    MoveControl* move_control_ = nullptr;
    // ...

public:
    // 提供一个方法来切换控制方式
    void setMoveControl(MoveControl* move_control);

private:
    // 原来的 keyboardControl() 变成了 moveControl()
    void moveControl();
    // ...
};
```

```cpp
// src/player.cpp (关键改动)
void Player::init()
{
    // ...
    // 默认使用WASD控制，并将其作为子对象添加到Player中
    move_control_ = new MoveControlWASD();
    addChild(move_control_);
}

// 核心：Player不再自己检查键盘，而是询问 move_control_ 组件
void Player::moveControl()
{
    if (move_control_ == nullptr) return;
    if (move_control_->isUp()){
        velocity_.y = -max_speed_;
    }
    if (move_control_->isDown()){
        velocity_.y = max_speed_;
    }
    // ... Left and Right
}

// 允许在运行时动态地更换“零件”
void Player::setMoveControl(MoveControl *move_control)
{
    if (move_control_ != nullptr) {
        // 标记旧的组件需要被移除
        move_control_->setNeedRemove(true);
    }
    move_control_ = move_control;
    // 将新的组件作为子对象添加进来
    safeAddChild(move_control);
}

// 在事件处理中，增加切换逻辑
bool Player::handleEvents(SDL_Event& event)
{
    if (Actor::handleEvents(event)) return true;
    // 按C键切换WASD，按V键切换箭头
    if (event.type == SDL_EVENT_KEY_DOWN)
    {
        if (event.key.scancode == SDL_SCANCODE_C) setMoveControl(new MoveControlWASD());
        if (event.key.scancode == SDL_SCANCODE_V) setMoveControl(new MoveControlArrow());
        return true;
    }
    return false;
}
```

## ✨ 总结：我们得到了什么？

通过这次重构，我们的代码质量得到了显著提升：

  * **高内聚，低耦合**：`Player` 和 `MoveControl` 各司其职。`Player` 不再依赖于具体的键盘扫描码，`MoveControl` 也不需要知道 `Player` 的存在。
  * **灵活性与扩展性**：现在，想增加手柄支持？只需要创建一个 `MoveControlGamepad` 类，在 `handleEvents` 里加一个切换按键即可。`Player` 的代码**一行都不用改**！
  * **组合优于继承**：我们没有创建 `PlayerWASD` 和 `PlayerArrow` 这样的子类，而是通过给 `Player` "插上"不同的 `MoveControl` 组件来改变其行为。这种组合的方式比继承要灵活得多，避免了类爆炸的问题。

> 💡 **模式的融合**
>
> 你可能已经发现，这种“定义一个通用接口，提供多种具体实现，在运行时动态切换”的做法，也非常符合**策略模式 (Strategy Pattern)** 的思想。没错！设计模式之间常常是相通和融合的。在这里，我们利用了引擎的**组合模式 (Scene Graph)**，来实现了一种灵活的**组件化策略切换**。
