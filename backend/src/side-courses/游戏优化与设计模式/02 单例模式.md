# # 单例模式 (Singleton Pattern)

<div class="video-container">
  <div id="bilibili" class="video-content">
    <iframe
      class="video-frame"
      src="https://player.bilibili.com/player.html?bvid=BV1ixGDzDEZy&page=1&autoplay=0&danmaku=0&high_quality=1"
      width="100%"
      height="480"
      scrolling="no"
      frameborder="0"
      allowfullscreen>
    </iframe>
  </div>
</div>

## 🎯 课程目标

  * 理解单例模式的**核心思想**与**设计意图**。
  * 掌握 C++ 中实现单例模式的几种**典型方式**及其优缺点。
  * 分析 `GhostEscape` 项目中 `Game` 类的实现，理解为何它是一种**现代且推荐**的单例模式实践。

## 🤔 为什么要确保“唯一”？

在软件系统中，总有一些组件是“天生唯一”的。

  * **现实世界类比**：一个国家只有一个中央政府，一台电脑只有一个操作系统内核。
  * **游戏世界应用**：在我们的 `GhostEscape` 项目中，`Game` 类就是这样的核心。它负责管理**渲染器**、**资源库**、**场景切换**、**主循环**等全局唯一的服务。

想象一下，如果项目中不小心创建了两个 `Game` 实例，会发生什么？

  * 哪个实例负责渲染到屏幕？
  * 玩家的分数应该记录在哪个实例中？
  * 资源（如图片、声音）被加载了两次，造成内存浪费？

这会引发混乱和不可预知的 Bug。为了从设计上杜绝这种可能性，我们需要一种机制来保证 `Game` 类在程序的整个生命周期中，**只有一个实例存在**。这就是单例模式的使命。

<img src="https://theorhythm.top/gamedev/opt/OPT14.webp" alt="单例模式" style="display: block; margin: auto; width: 800px;" />

-----

## 📖 单例模式的“三大纪律”

要实现一个真正的单例，必须在类的设计上遵循三条核心原则，以“堵死”所有可能创建新实例的途径。

1.  **构造函数私有化 (Private Constructor)**
    这是最关键的一步。将构造函数设为 `private`，可以防止任何外部代码通过 `Game myGame;` 的方式直接实例化对象。

2.  **拷贝和赋值操作禁用 (Delete Copy/Assignment)**
    即便构造函数私有了，C++ 仍然可能通过拷贝构造函数或赋值运算符从现有实例创建新实例。我们必须明确地将它们禁用。

3.  **提供全局静态访问点 (Public Static Accessor)**
    既然外部无法创建实例，就必须由类自身提供一个“官方”的、唯一的获取实例的通道。这个通道通常是一个名为 `getInstance()` 或 `instance()` 的 `static` 方法。

-----

## 💻 创建单例的几种方式

了解不同的实现方式有助于我们理解模式的演进，以及 `GhostEscape` 中为何采用当前方案。

### 方式一：饿汉式 (Eager Initialization)

“饿汉”，顾名思义，就是“迫不及待”。它在程序启动时就直接创建实例，不管后续是否会用到。

```cpp
// EagerSingleton.h
class EagerSingleton {
public:
    static EagerSingleton& getInstance() {
        return instance;
    }
private:
    EagerSingleton() {} // 构造函数私有
    static EagerSingleton instance; // 在程序入口前就已初始化
};

// EagerSingleton.cpp
EagerSingleton EagerSingleton::instance; // 定义并初始化静态实例
```

  * **优点**：实现简单，天生线程安全（因为初始化发生在 `main` 函数之前）。
  * **缺点**：如果实例很大且不一定被使用，会造成资源浪费。同时可能受“静态初始化顺序灾难”的影响。

### 方式二：懒汉式 (Lazy Initialization)

“懒汉”，即“能拖就拖”。直到第一次请求实例时，它才进行创建。

```cpp
// LazySingleton.h
class LazySingleton {
public:
    static LazySingleton* getInstance() {
        if (instance == nullptr) { // 第一次调用时创建
            instance = new LazySingleton();
        }
        return instance;
    }
private:
    LazySingleton() {}
    static LazySingleton* instance;
};

// LazySingleton.cpp
LazySingleton* LazySingleton::instance = nullptr;
```

  * **优点**：实现了延迟加载，避免了资源浪费。
  * **缺点**：**线程不安全**。在多线程环境下，两个线程可能同时通过 `if (instance == nullptr)` 的判断，从而创建出两个实例，违背了单例的初衷。

### 方式三：Meyers' Singleton (现代C++最佳实践)

这是由 C++ 大师 Scott Meyers 提出的，利用**函数局部静态变量 (function-local static variable)** 特性实现的方案。它巧妙地结合了“懒汉式”和“饿汉式”的优点。

```cpp
// MeyersSingleton.h
class MeyersSingleton {
public:
    static MeyersSingleton& getInstance() {
        // 局部静态变量在第一次被访问时才初始化
        // C++11及以后版本保证了其初始化过程是线程安全的
        static MeyersSingleton instance;
        return instance;
    }
private:
    MeyersSingleton() {} // 构造函数私有
    MeyersSingleton(const MeyersSingleton&) = delete; // 禁止拷贝
    MeyersSingleton& operator=(const MeyersSingleton&) = delete; // 禁止赋值
};
```

  * **优点**：
      * **延迟加载**：和懒汉式一样，实例在 `getInstance()` 首次被调用时才创建。
      * **线程安全**：自 C++11 标准起，局部静态变量的初始化被规定为原子操作，完全线程安全。
      * **代码简洁**：实现非常简单，无需手动加锁或使用指针。

-----

## ✅ `GhostEscape` 项目代码剖析

现在，让我们回头看 `GhostEscape` 中 `Game.h` 的代码，它正是 **Meyers' Singleton** 的完美应用。

```cpp
// src/core/game.h
class Game
{
private:
    Game(){} // 1. 构造函数私有
    Game(const Game&) = delete; // 2. 禁止拷贝
    Game& operator=(const Game&) = delete; // 3. 禁止赋值

public:
    // 4. 提供全局静态访问点
    static Game& getInstance()
    {
        static Game instance; // Meyers' Singleton 核心实现
        return instance;
    }
    // ... 其他功能函数
};
```

本课我们将项目内所有 `game_.` 的调用方式改为 `Game::getInstance().`，是一次非常好的**代码优化**。它并非引入新模式，而是**巩固了单例模式的应用**，移除了 `Object` 基类中不必要的 `game_` 成员，让所有模块都通过统一的全局入口访问 `Game` 实例，使代码的依赖关系更清晰、更规范。

## ✨ 总结

本节课，我们深入探讨了单例模式。

  * **核心价值**：在于**控制实例数量**，节约系统资源，并避免因多重实例导致的逻辑混乱。
  * **实现权衡**：我们学习了从“饿汉”到“懒汉”再到 **Meyers' Singleton** 的演进，理解了线程安全和延迟加载是其关键考量。
  * **项目实践**：我们确认了 `GhostEscape` 使用的是当前 C++ 环境下**最受推崇的单例实现方式**，它兼具安全、简洁与高效。

> **友情提示**：单例虽好，不可贪杯。过度使用单例会使模块间的依赖关系变得隐晦，给单元测试带来困难。请务必只在那些真正需要“全局唯一”的场景下使用它。